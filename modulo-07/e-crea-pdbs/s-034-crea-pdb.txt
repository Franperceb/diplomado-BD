##@Autor: Jorge Francisco Pereda Ceballos
##@Fecha creación: 23/02/2024
##@Descripción:Ejercicio 04 - Módulo 07. E04 Creando una PDB a partir de una non CDB

-------------------------------------------
**SCRIPT
--@Autor: Jorge Francisco Pereda Ceballos
--@Fecha creación: 23/02/2024
--@Descripción: Ejercicio 04 - Módulo 07. E04 Creando una PDB a partir de una non CDB


--   EJERCICIO
--   Completar el script en las secciones marcadas con TODO
--
spool /unam-diplomado-bd/modulos/modulo-07/e-crea-pdbs/s-033-crea-pdb-spool.txt

prompt Hacer  jpcdip01 -> jpcdip04_s2  Ahora con DB links

prompt Iniciando jpcdip01
!sh s-030-start-cdb.sh jpcdip01 system3

prompt Iniciando jpcdip04
!sh s-030-start-cdb.sh jpcdip04 system4

prompt conectando a jpcdip01
connect sys/system3@jpcdip01 as sysdba

-- TODO: Crear un usuario en común (nivel CDB) para realizar conexiones a través
-- de un DB link
prompt creando usuario en jpcdip01
create user jorge_remote identified by jorge;
grant create session, create pluggable database to jorge_remote;

prompt conectando a jpcdip04 para crear DB Link
--TODO:  realizar la conexión
Pause cambiar ORACLE_SID a nueva cdb [Enter] para continuar

conn sys/system4 as sysdba 

--TODO: Crear el DB Link, agregar el alias de servicio de ser necesario
create database link clone_link
  connect to jorge_remote identified by jorge
  using 'jpcdip01';

prompt Creando pdb jpcdip04_s2
--TODO:  clonar la PDB en  jpcdip04_s2
create pluggable database jpcdip04_s2
  from jpcdip01@clone_link
  file_name_convert=(
    '/u01/app/oracle/oradata/JPCDIP01', 
    '/u01/app/oracle/oradata/JPCDIP04/jpcdip04_s2'
  );

prompt ejecutando el script noncdb to_pdb.sql
--TODO: Incluir la ejecución del script
alter session set container=jpcdip04_s2;
@$ORACLE_HOME/rdbms/admin/noncdb_to_pdb.sql

prompt Abriendo y verificando la nueva pdb
alter pluggable database jpcdip04_s2 open read write;
show pdbs

Prompt mostrando datafiles de la CDB
set linesize window
col file_name format A60
select file_id, file_name from cdb_data_files;

pause Analizar resultados, [Enter] para continuar con Limpieza

prompt borrar PDB
alter pluggable database jpcdip04_s2 close;
drop  pluggable database jpcdip04_s2 including datafiles;

drop database link clone_link;

prompt eliminando usuario en jpcdip01
connect sys/system3@jpcdip01 as sysdba

--TODO: ELiminar al usuario 
drop user jorge_remote cascade;

spool off
exit


------------------------------------------------------------
**SALIDA DE EJECUCIÓN


sys@jpcdip01> start s-034-crea-pdb.sql
Hacer  jpcdip01 -> jpcdip04_s2	Ahora con DB links
Iniciando jpcdip01
Iniciando jpcdip01

SQL*Plus: Release 19.0.0.0.0 - Production on Wed Mar 6 22:43:22 2024
Version 19.3.0.0.0

Copyright (c) 1982, 2019, Oracle.  All rights reserved.


Connected to:
Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.3.0.0.0

sys@jpcdip01> ORA-01081: cannot start already-running ORACLE - shut it down first
sys@jpcdip01> USER is "SYS"
sys@jpcdip01> Disconnected from Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.3.0.0.0

Iniciando jpcdip04
Iniciando jpcdip04

SQL*Plus: Release 19.0.0.0.0 - Production on Wed Mar 6 22:43:23 2024
Version 19.3.0.0.0

Copyright (c) 1982, 2019, Oracle.  All rights reserved.


Connected to:
Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.3.0.0.0

sys@jpcdip04> ORA-01081: cannot start already-running ORACLE - shut it down first
sys@jpcdip04> USER is "SYS"
sys@jpcdip04> Disconnected from Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.3.0.0.0

conectando a jpcdip01
Connected.
creando usuario en jpcdip01

User created.


Grant succeeded.

Mostrando ORACLE_SID
jpcdip04

es correcto? [Enter] para continuar

Connected.
create database link clone_link
                     *
ERROR at line 1:
ORA-02011: duplicate database link name


Creando pdb jpcdip04_s2

Pluggable database created.

ejecutando el script noncdb to_pdb.sql

Session altered.

sys@jpcdip04> SET FEEDBACK 1
sys@jpcdip04> SET NUMWIDTH 10
sys@jpcdip04> SET LINESIZE 80
sys@jpcdip04> SET TRIMSPOOL ON
sys@jpcdip04> SET TAB OFF
sys@jpcdip04> SET PAGESIZE 100
sys@jpcdip04> SET VERIFY OFF
sys@jpcdip04> 
sys@jpcdip04> -- save settings
sys@jpcdip04> STORE SET ncdb2pdb.settings.sql REPLACE
SP2-0606: Cannot create STORE file "ncdb2pdb.settings.sql"
sys@jpcdip04> 
sys@jpcdip04> SET TIME ON
22:43:44 sys@jpcdip04> SET TIMING ON
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> WHENEVER SQLERROR EXIT;
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> DOC
22:43:44 DOC>#######################################################################
22:43:44 DOC>#######################################################################
22:43:44 DOC>   The following statement will cause an "ORA-01403: no data found"
22:43:44 DOC>   error if we're not in a PDB.
22:43:44 DOC>   This script is intended to be run right after plugin of a PDB,
22:43:44 DOC>   while inside the PDB.
22:43:44 DOC>#######################################################################
22:43:44 DOC>#######################################################################
22:43:44 DOC>#
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> VARIABLE cdbname VARCHAR2(128)
22:43:44 sys@jpcdip04> VARIABLE pdbname VARCHAR2(128)
22:43:44 sys@jpcdip04> BEGIN
22:43:44   2    SELECT sys_context('USERENV', 'CDB_NAME')
22:43:44   3      INTO :cdbname
22:43:44   4      FROM dual
22:43:44   5      WHERE sys_context('USERENV', 'CDB_NAME') is not null;
22:43:44   6    SELECT sys_context('USERENV', 'CON_NAME')
22:43:44   7      INTO :pdbname
22:43:44   8      FROM dual
22:43:44   9      WHERE sys_context('USERENV', 'CON_NAME') <> 'CDB$ROOT';
22:43:44  10  END;
22:43:44  11  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> @@?/rdbms/admin/loc_to_common0.sql
22:43:44 sys@jpcdip04> Rem
22:43:44 sys@jpcdip04> Rem $Header: rdbms/admin/loc_to_common0.sql /main/9 2018/07/25 13:49:55 surman Exp $
22:43:44 sys@jpcdip04> Rem
22:43:44 sys@jpcdip04> Rem loc_to_common0.sql
22:43:44 sys@jpcdip04> Rem
22:43:44 sys@jpcdip04> Rem Copyright (c) 2015, 2018, Oracle and/or its affiliates.
22:43:44 sys@jpcdip04> Rem All rights reserved.
22:43:44 sys@jpcdip04> Rem
22:43:44 sys@jpcdip04> Rem    NAME
22:43:44 sys@jpcdip04> Rem      loc_to_common0.sql - <one-line expansion of the name>
22:43:44 sys@jpcdip04> Rem
22:43:44 sys@jpcdip04> Rem    DESCRIPTION
22:43:44 sys@jpcdip04> Rem      <short description of component this file declares/defines>
22:43:44 sys@jpcdip04> Rem
22:43:44 sys@jpcdip04> Rem    NOTES
22:43:44 sys@jpcdip04> Rem      <other useful comments, qualifications, etc.>
22:43:44 sys@jpcdip04> Rem
22:43:44 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:43:44 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/loc_to_common0.sql
22:43:44 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/loc_to_common0.sql
22:43:44 sys@jpcdip04> Rem    SQL_PHASE: PDB
22:43:44 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:43:44 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:43:44 sys@jpcdip04> Rem    SQL_CALLING_FILE:
22:43:44 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:43:44 sys@jpcdip04> Rem
22:43:44 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:43:44 sys@jpcdip04> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
22:43:44 sys@jpcdip04> Rem    sanagara    04/04/18 - Back out fix for bug 27464252
22:43:44 sys@jpcdip04> Rem    surman      03/13/18 - 27464252: Generic phase
22:43:44 sys@jpcdip04> Rem    vsampeng    11/23/17 - Bug 27158226: case sensitive PDB name
22:43:44 sys@jpcdip04> Rem    thbaby      04/21/17 - Bug 25940936: set _enable_view_pdb
22:43:44 sys@jpcdip04> Rem    sankejai    01/22/16 - 16076261: session parameters scoped to container
22:43:44 sys@jpcdip04> Rem    pyam        12/22/15 - 21927236: rename pdb_to_fedpdb to pdb_to_apppdb
22:43:44 sys@jpcdip04> Rem    pyam        09/22/15 - 20959267: check for version mismatch
22:43:44 sys@jpcdip04> Rem    pyam        07/15/15 - Created
22:43:44 sys@jpcdip04> Rem
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> SET ECHO ON
22:43:44 sys@jpcdip04> SET FEEDBACK 1
22:43:44 sys@jpcdip04> SET NUMWIDTH 10
22:43:44 sys@jpcdip04> SET LINESIZE 80
22:43:44 sys@jpcdip04> SET TRIMSPOOL ON
22:43:44 sys@jpcdip04> SET TAB OFF
22:43:44 sys@jpcdip04> SET PAGESIZE 100
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> COLUMN pdbname NEW_VALUE pdbname
22:43:44 sys@jpcdip04> COLUMN pdbid NEW_VALUE pdbid
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
22:43:44 sys@jpcdip04> select :pdbname pdbname from dual;

PDBNAME
--------------------------------------------------------------------------------
JPCDIP04_S2

1 row selected.

Elapsed: 00:00:00.00
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> select TO_CHAR(con_id) pdbid from v$pdbs where name='&pdbname';

PDBID
----------------------------------------
4

1 row selected.

Elapsed: 00:00:00.00
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> -- save pluggable database open mode
22:43:44 sys@jpcdip04> -- Bug 27158226:This transaction encloses the pdb name with in the double quotes
22:43:44 sys@jpcdip04> --    to make the pdb name case sensitive one.
22:43:44 sys@jpcdip04> --    This is an extension of fix 25663931.
22:43:44 sys@jpcdip04> COLUMN open_state_col NEW_VALUE open_sql;
22:43:44 sys@jpcdip04> COLUMN restricted_col NEW_VALUE restricted_state;
22:43:44 sys@jpcdip04> SELECT decode(open_mode,
22:43:44   2                'READ ONLY', 'ALTER PLUGGABLE DATABASE "&pdbname" OPEN READ ONLY',
22:43:44   3                'READ WRITE', 'ALTER PLUGGABLE DATABASE "&pdbname" OPEN',
22:43:44   4                'MIGRATE', 'ALTER PLUGGABLE DATABASE "&pdbname" OPEN UPGRADE', '')
22:43:44   5           open_state_col,
22:43:44   6         decode(restricted, 'YES', 'RESTRICTED', '')
22:43:44   7           restricted_col
22:43:44   8         from v$pdbs where name='&pdbname';

OPEN_STATE_COL                                        RESTRICTED
----------------------------------------------------- ----------


1 row selected.

Elapsed: 00:00:00.01
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> alter session set container=CDB$ROOT;

Session altered.

Elapsed: 00:00:00.00
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> -- if pdb was already closed, don't exit on error
22:43:44 sys@jpcdip04> WHENEVER SQLERROR CONTINUE;
22:43:44 sys@jpcdip04> alter pluggable database "&pdbname" close immediate instances=all;
alter pluggable database "JPCDIP04_S2" close immediate instances=all
*
ERROR at line 1:
ORA-65020: pluggable database JPCDIP04_S2 already closed


Elapsed: 00:00:00.00
22:43:44 sys@jpcdip04> WHENEVER SQLERROR EXIT;
22:43:44 sys@jpcdip04> 
22:43:44 sys@jpcdip04> alter pluggable database "&pdbname" open upgrade;

Pluggable database altered.

Elapsed: 00:00:00.56
22:43:45 sys@jpcdip04> 
22:43:45 sys@jpcdip04> -- check that PDB and CDB versions match
22:43:45 sys@jpcdip04> SELECT TO_NUMBER('VERSION MISMATCH') from sys.dual
22:43:45   2   WHERE (select count(*) from pdb_alert$ where name='&pdbname' and cause#=65
22:43:45   3                                            and status=1) > 0;

no rows selected

Elapsed: 00:00:00.00
22:43:45 sys@jpcdip04> 
22:43:45 sys@jpcdip04> alter session set container = "&pdbname";

Session altered.

Elapsed: 00:00:00.01
22:43:45 sys@jpcdip04> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.01
22:43:45 sys@jpcdip04> 
22:43:45 sys@jpcdip04> -- initial setup before beginning the script
22:43:45 sys@jpcdip04> -- Bug 16076261: nls_length_semantics is not a parameter, so the value is not
22:43:45 sys@jpcdip04> -- lost after set container in further scripts.
22:43:45 sys@jpcdip04> alter session set NLS_LENGTH_SEMANTICS=BYTE;

Session altered.

Elapsed: 00:00:00.00
22:43:45 sys@jpcdip04> 
22:43:45 sys@jpcdip04> 
22:43:45 sys@jpcdip04> ---------------------------------------------------------------------------
22:43:45 sys@jpcdip04> -- PRE-SCRIPT CHECKS GO HERE:
22:43:45 sys@jpcdip04> 
22:43:45 sys@jpcdip04> -- Check that we have no invalid (not upgraded) table data from
22:43:45 sys@jpcdip04> -- ALTERing Oracle-Maintained Types
22:43:45 sys@jpcdip04> DOC
22:43:45 DOC>#######################################################################
22:43:45 DOC>#######################################################################
22:43:45 DOC>
22:43:45 DOC>     The following statement will cause an "ORA-01722: invalid number"
22:43:45 DOC>     error, if the database contains invalid data as a result of type
22:43:45 DOC>     evolution which was performed without the data being converted.
22:43:45 DOC>
22:43:45 DOC>     To resolve this specific "ORA-01722: invalid number" error:
22:43:45 DOC>       Perform the data conversion (details below) in the pluggable database.
22:43:45 DOC>
22:43:45 DOC>     Please refer to Oracle Database Object-Relational Developer's Guide
22:43:45 DOC>     for more information about type evolution.
22:43:45 DOC>
22:43:45 DOC>     Data in columns of evolved Oracle-Maintained types must be converted
22:43:45 DOC>     before the database can be converted.
22:43:45 DOC>
22:43:45 DOC>     The following commands, run inside the PDB, will perform the data
22:43:45 DOC>     conversion for Oracle supplied tables:
22:43:45 DOC>
22:43:45 DOC>     @?/rdbms/admin/catuptabdata.sql
22:43:45 DOC>
22:43:45 DOC>     You should then confirm that any non-Oracle supplied tables that
22:43:45 DOC>     are dependent on Oracle-Maintained types are also converted.
22:43:45 DOC>     You should review the data and determine if it needs
22:43:45 DOC>     to be converted or removed.
22:43:45 DOC>
22:43:45 DOC>     To view the columns affected by type evolution, execute the
22:43:45 DOC>     following inside the PDB:
22:43:45 DOC>
22:43:45 DOC>     SELECT rpad(u.name,128) TABLENAME, rpad(o.name,128) OWNER,
22:43:45 DOC>            rpad(c.name,128) COLNAME
22:43:45 DOC>     FROM SYS.OBJ$ o, SYS.COL$ c, SYS.COLTYPE$ t, SYS.USER$ u
22:43:45 DOC>     WHERE BITAND(t.FLAGS, 256) = 256  -- UPGRADED = NO
22:43:45 DOC>       AND o.OBJ# = t.OBJ# AND c.OBJ# = t.OBJ# AND c.COL# = t.COL#
22:43:45 DOC>       AND t.INTCOL# = c.INTCOL#
22:43:45 DOC>       AND o.owner# = u.user#
22:43:45 DOC>       AND o.owner# NOT IN -- NOT a COMMON user
22:43:45 DOC>           (SELECT user# FROM sys.user$
22:43:45 DOC>            WHERE type#=1 and bitand(spare1, 256)= 256)
22:43:45 DOC>       AND t.OBJ# IN  -- A dependent of an Oracle-Maintained type
22:43:45 DOC>           (SELECT DISTINCT d_obj#
22:43:45 DOC>            FROM sys.dependency$
22:43:45 DOC>            START WITH p_obj# IN -- Oracle-Maintained types
22:43:45 DOC>                   (SELECT obj# from sys.obj$
22:43:45 DOC>                    WHERE type#=13 AND
22:43:45 DOC>                          bitand(flags, 4194304) = 4194304)
22:43:45 DOC>            CONNECT BY PRIOR d_obj# = p_obj#);
22:43:45 DOC>
22:43:45 DOC>     Once the data is confirmed, the following commands, run inside the PDB,
22:43:45 DOC>     will convert the data returned by the above query.
22:43:45 DOC>
22:43:45 DOC>     @?/rdbms/admin/utluptabdata.sql
22:43:45 DOC>
22:43:45 DOC>     Depending on the amount of data involved, converting the evolved type
22:43:45 DOC>     data can take a significant amount of time.
22:43:45 DOC>
22:43:45 DOC>     After this is complete, please rerun noncdb_to_pdb.sql.
22:43:45 DOC>
22:43:45 DOC>#######################################################################
22:43:45 DOC>#######################################################################
22:43:45 DOC>#
22:43:45 sys@jpcdip04> 
22:43:45 sys@jpcdip04> set serveroutput on
22:43:45 sys@jpcdip04> 
22:43:45 sys@jpcdip04> DECLARE
22:43:45   2    do_abort boolean := false;
22:43:45   3    t_null varchar2(1);
22:43:45   4  BEGIN
22:43:45   5  
22:43:45   6    -- check for Oracle-Maintained tables that are not UPGRADED
22:43:45   7    BEGIN
22:43:45   8      SELECT NULL INTO t_null
22:43:45   9      FROM sys.coltype$ t, sys.obj$ o
22:43:45  10      WHERE BITAND(t.flags, 256) = 256  -- UPGRADED = NO
22:43:45  11        AND t.obj# = o.obj#
22:43:45  12        AND o.owner# IN -- An Oracle-Supplied user
22:43:45  13            (SELECT user# FROM sys.user$
22:43:45  14             WHERE type#=1 and bitand(spare1, 256)= 256)
22:43:45  15        AND rownum <=1;
22:43:45  16      do_abort := TRUE;
22:43:45  17      dbms_output.put_line('Oracle-Maintained tables need to be UPGRADED.');
22:43:45  18    EXCEPTION
22:43:45  19      WHEN NO_DATA_FOUND THEN NULL;
22:43:45  20    END;
22:43:45  21  
22:43:45  22    -- check for user tables dependent on Oracle-Maintained types
22:43:45  23    -- that are not upgraded
22:43:45  24    BEGIN
22:43:45  25      SELECT NULL INTO t_null
22:43:45  26      FROM sys.obj$ o, sys.coltype$ t
22:43:45  27      WHERE BITAND(t.FLAGS, 256) = 256   -- UPGRADED = NO
22:43:45  28        AND t.obj# = o.obj#
22:43:45  29        AND o.owner# NOT IN -- Not an Oracle-Supplied user
22:43:45  30            (SELECT user# FROM sys.user$
22:43:45  31             WHERE type#=1 and bitand(spare1, 256)= 256)
22:43:45  32        AND t.obj# IN
22:43:45  33           (SELECT DISTINCT d_obj#
22:43:45  34            FROM sys.dependency$
22:43:45  35            START WITH p_obj# IN -- Oracle-Maintained types
22:43:45  36                  (SELECT obj# from sys.obj$
22:43:45  37                   WHERE type#=13 AND
22:43:45  38                         bitand(flags, 4194304) = 4194304)
22:43:45  39            CONNECT BY PRIOR d_obj# = p_obj#)
22:43:45  40        AND rownum <=1;
22:43:45  41      do_abort := TRUE;
22:43:45  42      dbms_output.put_line('User tables dependent on Oracle-Maintained types');
22:43:45  43      dbms_output.put_line('need to be UPGRADED.');
22:43:45  44    EXCEPTION
22:43:45  45      WHEN NO_DATA_FOUND THEN NULL;
22:43:45  46    END;
22:43:45  47  
22:43:45  48  
22:43:45  49    If do_abort THEN
22:43:45  50      dbms_output.put_line ('Non-CDB conversion aborting.');
22:43:45  51      dbms_output.put_line ('For instructions, look for ORA-01722 in this script.');
22:43:45  52      dbms_output.put_line ('Please resolve these and rerun noncdb_to_pdb.sql.');
22:43:45  53      RAISE INVALID_NUMBER;
22:43:45  54    END IF;
22:43:45  55  END;
22:43:45  56  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.56
22:43:45 sys@jpcdip04> 
22:43:45 sys@jpcdip04> -- END PRE-SCRIPT CHECKS
22:43:45 sys@jpcdip04> ---------------------------------------------------------------------------
22:43:45 sys@jpcdip04> -- NOTE: SHARING bits in OBJ$.FLAGS are:
22:43:45 sys@jpcdip04> -- - 65536  = MDL (Metadata Link)
22:43:45 sys@jpcdip04> -- - 131072 = DL (Data Link, formerly OBL)
22:43:45 sys@jpcdip04> -- - 4294967296 = EDL (Extended Data Link)
22:43:45 sys@jpcdip04> define mdl=65536
22:43:45 sys@jpcdip04> define dl=131072
22:43:45 sys@jpcdip04> define edl=4294967296
22:43:45 sys@jpcdip04> define sharing_bits=(&mdl+&dl+&edl)
22:43:45 sys@jpcdip04> 
22:43:45 sys@jpcdip04> select count(*) from sys.obj$
22:43:45   2  where bitand(flags, &sharing_bits) <> 0;

  COUNT(*)
----------
     66334

1 row selected.

Elapsed: 00:00:00.01
22:43:45 sys@jpcdip04> 
22:43:45 sys@jpcdip04> -- 22465938: if obj$ common bits are already set for certain objects,
22:43:45 sys@jpcdip04> -- the noncdb_to_pdb conversion might fail to validate these objects.
22:43:45 sys@jpcdip04> -- When the first time noncdb_to_pdb.sql is run on a legacy database
22:43:45 sys@jpcdip04> -- which is plugged into the CDB, clear any such common bits.
22:43:45 sys@jpcdip04> declare
22:43:45   2    to_pdb varchar2(128);
22:43:45   3  begin
22:43:45   4    select value$ into to_pdb from props$ where name = 'NONCDB_TO_PDB.SQL';
22:43:45   5    if to_pdb = 'TRUE' then
22:43:45   6      update sys.obj$
22:43:45   7         set flags = flags - bitand(flags, &sharing_bits)
22:43:45   8       where bitand(flags, &sharing_bits) <> 0;
22:43:45   9      dbms_output.put_line('Common bits are cleared for ' ||
22:43:45  10                           sql%rowcount || ' objects.');
22:43:45  11      commit;
22:43:45  12    else
22:43:45  13      dbms_output.put_line('No need to clear common bits twice.');
22:43:45  14    end if;
22:43:45  15  exception
22:43:45  16    when no_data_found then
22:43:45  17      dbms_output.put_line('No need to clear common bits at all.');
22:43:45  18  end;
22:43:45  19  /
Common bits are cleared for 66334 objects.

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.30
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> select count(*) from sys.obj$
22:43:46   2  where bitand(flags, &sharing_bits) <> 0;

  COUNT(*)
----------
         0

1 row selected.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> set serveroutput off;
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> @@?/rdbms/admin/loc_to_common1.sql 1
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem $Header: rdbms/admin/loc_to_common1.sql /st_rdbms_19/1 2018/12/08 04:29:56 nneeluru Exp $
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem loc_to_common1.sql
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem Copyright (c) 2014, 2018, Oracle and/or its affiliates.
22:43:46 sys@jpcdip04> Rem All rights reserved.
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    NAME
22:43:46 sys@jpcdip04> Rem      loc_to_common1.sql - helper script for converting local to common
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    DESCRIPTION
22:43:46 sys@jpcdip04> Rem      Does the first set of operations needed to convert local to common.
22:43:46 sys@jpcdip04> Rem      Creates object-linked views.
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    NOTES
22:43:46 sys@jpcdip04> Rem      Called by noncdb_to_pdb.sql, apex_to_common.sql, pdb_to_apppdb.sql
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:43:46 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/loc_to_common1.sql
22:43:46 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/loc_to_common1.sql
22:43:46 sys@jpcdip04> Rem    SQL_PHASE: PDB
22:43:46 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:43:46 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:43:46 sys@jpcdip04> Rem    SQL_CALLING_FILE: rdbms/admin/noncdb_to_pdb.sql
22:43:46 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:43:46 sys@jpcdip04> Rem    nneeluru    12/06/18 - Backport nneeluru_bug-28745878 from main
22:43:46 sys@jpcdip04> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
22:43:46 sys@jpcdip04> Rem    sanagara    04/04/18 - Back out fix for bug 27464252
22:43:46 sys@jpcdip04> Rem    surman      03/13/18 - 27464252: Generic phase
22:43:46 sys@jpcdip04> Rem    thbaby      04/21/17 - Bug 25940936: set _enable_view_pdb
22:43:46 sys@jpcdip04> Rem    pyam        01/05/17 - set/clear scriptparam separately per container
22:43:46 sys@jpcdip04> Rem    pyam        09/08/16 - RTI 19633354: remove duplicate set &scriptparam
22:43:46 sys@jpcdip04> Rem    akruglik    01/25/16 - (22132084): handle Extended Data links
22:43:46 sys@jpcdip04> Rem    sankejai    01/22/16 - 16076261: session parameters scoped to container
22:43:46 sys@jpcdip04> Rem    pyam        12/22/15 - 21927236: rename pdb_to_fedpdb to pdb_to_apppdb
22:43:46 sys@jpcdip04> Rem    akruglik    11/24/15 - (21193922) App Common users are marked with both
22:43:46 sys@jpcdip04> Rem                           common and App-common bits
22:43:46 sys@jpcdip04> Rem    thbaby      09/02/15 - Bug 21774247: handle COMMON_DATA
22:43:46 sys@jpcdip04> Rem    juilin      09/01/15 - 21458522: rename syscontext FEDERATION_NAME
22:43:46 sys@jpcdip04> Rem    pyam        04/30/15 - 20989123: fix fed flags for user$
22:43:46 sys@jpcdip04> Rem    pyam        04/19/15 - 20795461: change to _application_script for
22:43:46 sys@jpcdip04> Rem                           pdb_to_apppdb
22:43:46 sys@jpcdip04> Rem    syetchin    04/06/15 - Fix for diffs in lrgdbconc0e3ee and
22:43:46 sys@jpcdip04> Rem                           lrgdbconc0e4ee by mjungerm
22:43:46 sys@jpcdip04> Rem    surman      01/08/15 - 19475031: Update SQL metadata
22:43:46 sys@jpcdip04> Rem    pyam        09/16/14 - Helper script #1 for converting local objects to
22:43:46 sys@jpcdip04> Rem                           common in a CDB environment.
22:43:46 sys@jpcdip04> Rem    pyam        09/16/14 - Created
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> exec dbms_pdb.noncdb_to_pdb(&&1);

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> COLUMN rootcon NEW_VALUE rootcon
22:43:46 sys@jpcdip04> select decode(&&1, 5, SYS_CONTEXT('USERENV', 'APPLICATION_NAME'), 'CDB$ROOT')
22:43:46   2         rootcon from dual;

ROOTCON
--------------------------------------------------------------------------------
CDB$ROOT

1 row selected.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> COLUMN scriptparam NEW_VALUE scriptparam
22:43:46 sys@jpcdip04> select decode(&&1, 5, '"_APPLICATION_SCRIPT"', '"_ORACLE_SCRIPT"') scriptparam
22:43:46   2    from dual;

SCRIPTPARAM
----------------
"_ORACLE_SCRIPT"

1 row selected.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> alter session set container=&rootcon;

Session altered.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> alter session set &scriptparam=true;

Session altered.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- CDB Common Users/Roles have 128 (Common) set in user$.spare1 while App
22:43:46 sys@jpcdip04> -- Common Users/Roles have both 128 (Common) and 4096 (App Common) set.
22:43:46 sys@jpcdip04> -- If we are looking for App Common Users/Roles, CDB Common users/Roles get
22:43:46 sys@jpcdip04> -- skipped because we check whether user$.spare1 has both 128 and 4096 set,
22:43:46 sys@jpcdip04> -- but if we are interested in CDB Common Users/Roles, we need to restrict
22:43:46 sys@jpcdip04> -- ourselves to USER$ rows which have 128 but not 4096 set in spare1
22:43:46 sys@jpcdip04> COLUMN cmnusrflag NEW_VALUE cmnusrflag
22:43:46 sys@jpcdip04> select decode(&&1, 5, '4224', '128') cmnusrflag from dual;

CMN
---
128

1 row selected.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- if this is for federation conversion, only treat federation objects
22:43:46 sys@jpcdip04> -- as common
22:43:46 sys@jpcdip04> COLUMN fedobjflag NEW_VALUE fedobjflag
22:43:46 sys@jpcdip04> select decode(&&1, 5, '134217728', '0') fedobjflag from dual;

F
-
0

1 row selected.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- create temporary object-linked view to get list of objects marked as common
22:43:46 sys@jpcdip04> -- in CDB$ROOT
22:43:46 sys@jpcdip04> --
22:43:46 sys@jpcdip04> -- NOTE: SHARING bits in OBJ$.FLAGS are:
22:43:46 sys@jpcdip04> -- - 65536  = MDL (Metadata Link)
22:43:46 sys@jpcdip04> -- - 131072 = DL (Data Link, formerly OBL)
22:43:46 sys@jpcdip04> -- - 4294967296 = EDL (Extended Data Link)
22:43:46 sys@jpcdip04> define mdl=65536
22:43:46 sys@jpcdip04> define dl=131072
22:43:46 sys@jpcdip04> define edl=4294967296
22:43:46 sys@jpcdip04> define sharing_bits=(&mdl+&dl+&edl)
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> create or replace view sys.cdb$common_root_objects&pdbid sharing=object as
22:43:46   2  select u.name owner, o.name object_name, o.type# object_type, o.namespace nsp,
22:43:46   3         o.subname object_subname, o.signature object_sig,
22:43:46   4         decode(bitand(o.flags, &sharing_bits),
22:43:46   5                &edl+&mdl, 'EDL', &dl, 'DL', 'MDL') sharing
22:43:46   6    from sys.obj$ o, sys.user$ u
22:43:46   7   where o.owner#=u.user# and bitand(o.flags, &sharing_bits) <> 0
22:43:46   8     and bitand(o.flags,&fedobjflag)=&fedobjflag;

View created.

Elapsed: 00:00:00.05
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- Bug 21774247: Handle COMMON_DATA tables.
22:43:46 sys@jpcdip04> -- create temporary object-linked view to get list of tables marked as
22:43:46 sys@jpcdip04> -- common_data in Root
22:43:46 sys@jpcdip04> create or replace view sys.cdb$cdata_root_tables&pdbid sharing=object as
22:43:46   2  select u.name owner, o.name object_name
22:43:46   3    from sys.obj$ o, sys.user$ u, sys.tab$ t
22:43:46   4   where o.owner#=u.user# and o.obj#=t.obj#
22:43:46   5     and bitand(t.property, power(2,52))=power(2,52);

View created.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- Bug 21774247: Handle COMMON_DATA views.
22:43:46 sys@jpcdip04> -- create temporary object-linked view to get list of views marked as
22:43:46 sys@jpcdip04> -- common_data in Root
22:43:46 sys@jpcdip04> create or replace view sys.cdb$cdata_root_views&pdbid sharing=object as
22:43:46   2  select u.name owner, o.name object_name
22:43:46   3    from sys.obj$ o, sys.user$ u, sys.view$ v
22:43:46   4   where o.owner#=u.user# and o.obj#=v.obj#
22:43:46   5     and bitand(v.property, power(2,52))=power(2,52);

View created.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> create or replace view sys.cdb$cmn_root_types&pdbid sharing=object as
22:43:46   2  select u.name owner, o.name object_name, o.type# object_type, o.namespace nsp,
22:43:46   3         o.subname object_subname, o.signature object_sig, t.hashcode hashcode,
22:43:46   4         decode(bitand(o.flags, &sharing_bits),
22:43:46   5                &edl+&mdl, 'EDL', &dl, 'DL', 'MDL') sharing
22:43:46   6    from sys.obj$ o, sys.user$ u, sys.type$ t where
22:43:46   7    o.type#=13 and o.oid$=t.tvoid and o.owner#=u.user# and
22:43:46   8    bitand(o.flags, &sharing_bits) <> 0 and
22:43:46   9    bitand(o.flags,&fedobjflag)=&fedobjflag;

View created.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- object-linked view for list of common users
22:43:46 sys@jpcdip04> create or replace view sys.cdb$common_users&pdbid sharing=object as
22:43:46   2  select name, type# from sys.user$
22:43:46   3  where bitand(spare1,4224) = &cmnusrflag;

View created.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- object-linked view for accessing dependency$
22:43:46 sys@jpcdip04> create or replace view sys.cdb$rootdeps&pdbid sharing=object as select du.name as owner, do.name as name, do.type# as d_type#, do.namespace as d_namespace,pu.name as referenced_owner, po.name as referenced_name, po.type# as p_type#, po.namespace as p_namespace,d.order#,d.property,d.d_attrs,d.d_reason from sys.obj$ do, sys.obj$ po, sys.user$ du, sys.user$ pu, sys.dependency$ d where du.user#=do.owner# and pu.user#=po.owner# and do.obj#=d_obj# and po.obj#=p_obj#;

View created.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- TODO: update to include fed flags
22:43:46 sys@jpcdip04> -- object-linked view for accessing sysauth$: common system privileges
22:43:46 sys@jpcdip04> create or replace view sys.cdb$commonsysprivs&pdbid sharing=object as
22:43:46   2  select u.name, s.privilege# from sys.user$ u, sys.sysauth$ s
22:43:46   3  where s.grantee#=u.user# and bitand(s.option$,8)=8 and s.privilege#<0;

View created.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- TODO: update to include fed flags
22:43:46 sys@jpcdip04> -- object-linked view for accessing sysauth$: common role grants
22:43:46 sys@jpcdip04> create or replace view sys.cdb$commonrolegrants&pdbid sharing=object as
22:43:46   2  select u.name, r.name rolename from sys.user$ u, sys.sysauth$ s, sys.user$ r
22:43:46   3  where s.grantee#=u.user# and bitand(s.option$,8)=8 and s.privilege#>0 and
22:43:46   4  s.privilege#=r.user#;

View created.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- TODO: update to include fed flags
22:43:46 sys@jpcdip04> -- object-linked view for accessing objauth$
22:43:46 sys@jpcdip04> create or replace view sys.cdb$commonobjprivs&pdbid sharing=object as
22:43:46   2  select u.name, oa.privilege#, u2.name owner, o.name objname, oa.col#
22:43:46   3  from sys.user$ u, sys.objauth$ oa, sys.obj$ o, sys.user$ u2
22:43:46   4  where oa.grantee#=u.user# and bitand(oa.option$,8)=8
22:43:46   5  and oa.obj#=o.obj# and o.owner#=u2.user#;

View created.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> alter session set &scriptparam=false;

Session altered.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- switch into PDB
22:43:46 sys@jpcdip04> alter session set container="&pdbname";

Session altered.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> alter session set &scriptparam=true;

Session altered.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- do java long identifier translation in the pdb if need be
22:43:46 sys@jpcdip04> -- which also does the translation in the root internally if need be;
22:43:46 sys@jpcdip04> -- this translation has to happen before the step with the comment
22:43:46 sys@jpcdip04> -- "mark objects in our PDB as common if they exist as common in ROOT"
22:43:46 sys@jpcdip04> -- in loc_to_common2.sql
22:43:46 sys@jpcdip04> declare junk varchar2(100);
22:43:46   2  begin
22:43:46   3  junk := dbms_java_test.funcall('-lid_translate_all', ' ');
22:43:46   4  exception when others then null;
22:43:46   5  end;
22:43:46   6  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> create or replace view sys.cdb$common_root_objects&pdbid sharing=object as
22:43:46   2  select u.name owner, o.name object_name, o.type# object_type, o.namespace nsp,
22:43:46   3         o.subname object_subname, o.signature object_sig,
22:43:46   4         decode(bitand(o.flags, &sharing_bits),
22:43:46   5                &edl+&mdl, 'EDL', &dl, 'DL', 'MDL') sharing
22:43:46   6    from sys.obj$ o, sys.user$ u
22:43:46   7   where o.owner#=u.user# and bitand(o.flags, &sharing_bits) <> 0
22:43:46   8     and bitand(o.flags,&fedobjflag)=&fedobjflag;

View created.

Elapsed: 00:00:00.02
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- Bug 21774247: Handle COMMON_DATA tables.
22:43:46 sys@jpcdip04> -- create temporary object-linked view to get list of tables marked as
22:43:46 sys@jpcdip04> -- common_data in Root
22:43:46 sys@jpcdip04> create or replace view sys.cdb$cdata_root_tables&pdbid sharing=object as
22:43:46   2  select u.name owner, o.name object_name
22:43:46   3    from sys.obj$ o, sys.user$ u, sys.tab$ t
22:43:46   4   where o.owner#=u.user# and o.obj#=t.obj#
22:43:46   5     and bitand(t.property, power(2,52))=power(2,52);

View created.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- Bug 21774247: Handle COMMON_DATA views.
22:43:46 sys@jpcdip04> -- create temporary object-linked view to get list of views marked as
22:43:46 sys@jpcdip04> -- common_data in Root
22:43:46 sys@jpcdip04> create or replace view sys.cdb$cdata_root_views&pdbid sharing=object as
22:43:46   2  select u.name owner, o.name object_name
22:43:46   3    from sys.obj$ o, sys.user$ u, sys.view$ v
22:43:46   4   where o.owner#=u.user# and o.obj#=v.obj#
22:43:46   5     and bitand(v.property, power(2,52))=power(2,52);

View created.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> create or replace view sys.cdb$cmn_root_types&pdbid sharing=object as
22:43:46   2  select u.name owner, o.name object_name, o.type# object_type, o.namespace nsp,
22:43:46   3         o.subname object_subname, o.signature object_sig, t.hashcode hashcode,
22:43:46   4         decode(bitand(o.flags, &sharing_bits),
22:43:46   5                &edl+&mdl, 'EDL', &dl, 'DL', 'MDL') sharing
22:43:46   6    from sys.obj$ o, sys.user$ u, sys.type$ t where
22:43:46   7    o.type#=13 and o.oid$=t.tvoid and o.owner#=u.user# and
22:43:46   8    bitand(o.flags, &sharing_bits) <> 0 and
22:43:46   9    bitand(o.flags,&fedobjflag)=&fedobjflag;

View created.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- object-linked view for list of common users
22:43:46 sys@jpcdip04> create or replace view sys.cdb$common_users&pdbid sharing=object as
22:43:46   2  select name, type# from sys.user$
22:43:46   3  where bitand(spare1,4224) = &cmnusrflag;

View created.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- object-linked view for accessing dependency$
22:43:46 sys@jpcdip04> create or replace view sys.cdb$rootdeps&pdbid sharing=object as select du.name as owner, do.name as name, do.type# as d_type#, do.namespace as d_namespace,pu.name as referenced_owner, po.name as referenced_name, po.type# as p_type#, po.namespace as p_namespace,d.order#,d.property,d.d_attrs,d.d_reason from sys.obj$ do, sys.obj$ po, sys.user$ du, sys.user$ pu, sys.dependency$ d where du.user#=do.owner# and pu.user#=po.owner# and do.obj#=d_obj# and po.obj#=p_obj#;

View created.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- TODO: update to include fed flags
22:43:46 sys@jpcdip04> -- object-linked view for accessing sysauth$: common system privileges
22:43:46 sys@jpcdip04> create or replace view sys.cdb$commonsysprivs&pdbid sharing=object as
22:43:46   2  select u.name, s.privilege# from sys.user$ u, sys.sysauth$ s
22:43:46   3  where s.grantee#=u.user# and bitand(s.option$,8)=8 and s.privilege#<0;

View created.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- TODO: update to include fed flags
22:43:46 sys@jpcdip04> -- object-linked view for accessing sysauth$: common role grants
22:43:46 sys@jpcdip04> create or replace view sys.cdb$commonrolegrants&pdbid sharing=object as
22:43:46   2  select u.name, r.name rolename from sys.user$ u, sys.sysauth$ s, sys.user$ r
22:43:46   3  where s.grantee#=u.user# and bitand(s.option$,8)=8 and s.privilege#>0 and
22:43:46   4  s.privilege#=r.user#;

View created.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- TODO: update to include fed flags
22:43:46 sys@jpcdip04> -- object-linked view for accessing objauth$
22:43:46 sys@jpcdip04> create or replace view sys.cdb$commonobjprivs&pdbid sharing=object as
22:43:46   2  select u.name, oa.privilege#, u2.name owner, o.name objname, oa.col#
22:43:46   3  from sys.user$ u, sys.objauth$ oa, sys.obj$ o, sys.user$ u2
22:43:46   4  where oa.grantee#=u.user# and bitand(oa.option$,8)=8
22:43:46   5  and oa.obj#=o.obj# and o.owner#=u2.user#;

View created.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> create or replace view sys.cdb$objects&pdbid sharing=none as
22:43:46   2  select u.name owner, o.name object_name, o.signature object_sig,
22:43:46   3         o.namespace nsp, o.subname object_subname, o.obj# object_id,
22:43:46   4         o.type# object_type, o.flags flags
22:43:46   5    from sys.obj$ o, sys.user$ u
22:43:46   6    where o.owner#=u.user#;

View created.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> create or replace view sys.cdb$types&pdbid sharing=none as
22:43:46   2  select u.name owner, o.name object_name, o.signature object_sig,
22:43:46   3         o.namespace nsp, o.subname object_subname, o.obj# object_id,
22:43:46   4         o.type# object_type, o.flags flags, t.hashcode hashcode
22:43:46   5    from sys.obj$ o, sys.user$ u, sys.type$ t
22:43:46   6    where o.owner#=u.user# and o.type#=13 and o.oid$=t.tvoid;

View created.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> create or replace view sys.cdb$tables&pdbid sharing=none as
22:43:46   2  select * from sys.cdb$objects&pdbid where object_type=2;

View created.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> alter session set &scriptparam=false;

Session altered.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- 18478064:
22:43:46 sys@jpcdip04> -- In the case that this is run post-upgrade, we should reenable indexes that
22:43:46 sys@jpcdip04> -- were disabled during upgrade. That way, ENABLED$INDEXES created below will
22:43:46 sys@jpcdip04> -- accurately reflect . This is necessary because indexes can be dropped
22:43:46 sys@jpcdip04> -- and recreated during upgrade, and enabled$indexes.objnum would be outdated.
22:43:46 sys@jpcdip04> -- In the non-upgrade case, this will be a no-op, because enabled$indexes
22:43:46 sys@jpcdip04> -- wouldn't exist
22:43:46 sys@jpcdip04> @@?/rdbms/admin/reenable_indexes.sql
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem $Header: rdbms/admin/reenable_indexes.sql /main/6 2018/07/25 13:49:55 surman Exp $
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem reenable_indexes.sql
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem Copyright (c) 2014, 2018, Oracle and/or its affiliates.
22:43:46 sys@jpcdip04> Rem All rights reserved.
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    NAME
22:43:46 sys@jpcdip04> Rem      reenable_indexes.sql - <one-line expansion of the name>
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    DESCRIPTION
22:43:46 sys@jpcdip04> Rem      <short description of component this file declares/defines>
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    NOTES
22:43:46 sys@jpcdip04> Rem      <other useful comments, qualifications, etc.>
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:43:46 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/reenable_indexes.sql
22:43:46 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/reenable_indexes.sql
22:43:46 sys@jpcdip04> Rem    SQL_PHASE: REENABLE_INDEXES
22:43:46 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:43:46 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:43:46 sys@jpcdip04> Rem    SQL_CALLING_FILE: rdbms/admin/noncdb_to_pdb.sql
22:43:46 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:43:46 sys@jpcdip04> Rem    sanagara    04/04/18 - Back out fix for bug 27464252
22:43:46 sys@jpcdip04> Rem    sylin       01/30/15 - bug20422151 - longer identifier
22:43:46 sys@jpcdip04> Rem    surman      01/08/15 - 19475031: Update SQL metadata
22:43:46 sys@jpcdip04> Rem    pyam        04/03/14 - Reenable indexes based on sys.enabled$indexes
22:43:46 sys@jpcdip04> Rem                           (formerly in utlprp.sql)
22:43:46 sys@jpcdip04> Rem    pyam        04/03/14 - Created
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem Declare function local_enquote_name to pass FALSE
22:43:46 sys@jpcdip04> Rem into underlying dbms_assert.enquote_name function
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> CREATE OR REPLACE FUNCTION local_enquote_name (str varchar2)
22:43:46   2   return varchar2 is
22:43:46   3     begin
22:43:46   4          return dbms_assert.enquote_name(str, FALSE);
22:43:46   5     end local_enquote_name;
22:43:46   6  /

Function created.

Elapsed: 00:00:00.03
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem If sys.enabled$index table exists, then re-enable
22:43:46 sys@jpcdip04> Rem list of functional indexes that were enabled prior to upgrade
22:43:46 sys@jpcdip04> Rem The table sys.enabled$index table is created in catupstr.sql
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> SET serveroutput on
22:43:46 sys@jpcdip04> DECLARE
22:43:46   2     TYPE tab_char IS TABLE OF VARCHAR2(32767) INDEX BY BINARY_INTEGER;
22:43:46   3     commands tab_char;
22:43:46   4     p_null   CHAR(1);
22:43:46   5     p_schemaname  dbms_id;
22:43:46   6     p_indexname   dbms_id;
22:43:46   7     rebuild_idx_msg BOOLEAN := FALSE;
22:43:46   8     non_existent_index exception;
22:43:46   9     recycle_bin_objs exception;
22:43:46  10     cannot_change_obj exception;
22:43:46  11     no_such_table  exception;
22:43:46  12     pragma exception_init(non_existent_index, -1418);
22:43:46  13     pragma exception_init(recycle_bin_objs, -38301);
22:43:46  14     pragma exception_init(cannot_change_obj, -30552);
22:43:46  15     pragma exception_init(no_such_table, -942);
22:43:46  16     type cursor_t IS REF CURSOR;
22:43:46  17     reg_cursor   cursor_t;
22:43:46  18  
22:43:46  19  BEGIN
22:43:46  20     -- Check for existence of the table marking disabled functional indices
22:43:46  21  
22:43:46  22     SELECT NULL INTO p_null FROM DBA_OBJECTS
22:43:46  23     WHERE owner = 'SYS' and object_name = 'ENABLED$INDEXES' and
22:43:46  24              object_type = 'TABLE' and rownum <=1;
22:43:46  25  
22:43:46  26        -- Select indices to be re-enabled
22:43:46  27        EXECUTE IMMEDIATE q'+
22:43:46  28           SELECT 'ALTER INDEX ' ||
22:43:46  29                   local_enquote_name(e.schemaname) || '.' ||
22:43:46  30                   local_enquote_name(e.indexname) || ' ENABLE'
22:43:46  31              FROM   enabled$indexes e, ind$ i
22:43:46  32              WHERE  e.objnum = i.obj# AND bitand(i.flags, 1024) != 0 AND
22:43:46  33                     bitand(i.property, 16) != 0+'
22:43:46  34        BULK COLLECT INTO commands;
22:43:46  35  
22:43:46  36        IF (commands.count() > 0) THEN
22:43:46  37           FOR i IN 1 .. commands.count() LOOP
22:43:46  38              BEGIN
22:43:46  39              EXECUTE IMMEDIATE commands(i);
22:43:46  40              EXCEPTION
22:43:46  41                 WHEN NON_EXISTENT_INDEX THEN NULL;
22:43:46  42                 WHEN RECYCLE_BIN_OBJS THEN NULL;
22:43:46  43                 WHEN CANNOT_CHANGE_OBJ THEN rebuild_idx_msg := TRUE;
22:43:46  44              END;
22:43:46  45           END LOOP;
22:43:46  46        END IF;
22:43:46  47  
22:43:46  48        -- Output any indexes in the table that could not be re-enabled
22:43:46  49        -- due to ORA-30552 during ALTER INDEX...ENBLE command
22:43:46  50  
22:43:46  51        IF  rebuild_idx_msg THEN
22:43:46  52         BEGIN
22:43:46  53           DBMS_OUTPUT.PUT_LINE
22:43:46  54  ('The following indexes could not be re-enabled and may need to be rebuilt:');
22:43:46  55  
22:43:46  56           OPEN reg_cursor FOR
22:43:46  57               'SELECT e.schemaname, e.indexname
22:43:46  58                FROM   enabled$indexes e, ind$ i
22:43:46  59                WHERE  e.objnum = i.obj# AND bitand(i.flags, 1024) != 0';
22:43:46  60  
22:43:46  61           LOOP
22:43:46  62             FETCH reg_cursor INTO p_schemaname, p_indexname;
22:43:46  63             EXIT WHEN reg_cursor%NOTFOUND;
22:43:46  64             DBMS_OUTPUT.PUT_LINE
22:43:46  65                ('.... INDEX ' || p_schemaname || '.' || p_indexname);
22:43:46  66           END LOOP;
22:43:46  67           CLOSE reg_cursor;
22:43:46  68  
22:43:46  69         EXCEPTION
22:43:46  70              WHEN NO_DATA_FOUND THEN CLOSE reg_cursor;
22:43:46  71              WHEN NO_SUCH_TABLE THEN CLOSE reg_cursor;
22:43:46  72              WHEN OTHERS THEN CLOSE reg_cursor; raise;
22:43:46  73         END;
22:43:46  74  
22:43:46  75        END IF;
22:43:46  76  
22:43:46  77        EXECUTE IMMEDIATE 'DROP TABLE sys.enabled$indexes';
22:43:46  78  
22:43:46  79     EXCEPTION
22:43:46  80        WHEN NO_DATA_FOUND THEN NULL;
22:43:46  81  
22:43:46  82  END;
22:43:46  83  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> DROP function local_enquote_name;

Function dropped.

Elapsed: 00:00:00.03
22:43:46 sys@jpcdip04> SET serveroutput off
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- record enabled indexes, so that if this script disables them implicitly
22:43:46 sys@jpcdip04> -- we can reenable them in the end
22:43:46 sys@jpcdip04> set serveroutput off
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> CREATE TABLE sys.enabled$indexes sharing=none ( schemaname, indexname, objnum )
22:43:46   2  AS select u.name, o1.name, i.obj# from user$ u, obj$ o1, obj$ o2, ind$ i
22:43:46   3      where
22:43:46   4          u.user# = o1.owner# and o1.type# = 1 and o1.obj# = i.obj#
22:43:46   5         and bitand(i.property, 16)= 16 and bitand(i.flags, 1024)=0
22:43:46   6         and i.bo# = o2.obj# and bitand(o2.flags, 2)=0;

Table created.

Elapsed: 00:00:00.05
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- generate signatures for the common tables which don't have them
22:43:46 sys@jpcdip04> DECLARE
22:43:46   2    cursor c is
22:43:46   3      select r.owner, r.object_name
22:43:46   4        from sys.cdb$common_root_objects&pdbid r, sys.cdb$tables&pdbid p
22:43:46   5      where r.owner=p.owner and r.object_name=p.object_name
22:43:46   6        and r.object_type=2 and p.object_sig is null
22:43:46   7        and p.object_name not in ('OBJ$', 'USER$');
22:43:46   8  BEGIN
22:43:46   9    FOR tab in c
22:43:46  10    LOOP
22:43:46  11      BEGIN
22:43:46  12        execute immediate 'ALTER TABLE ' || tab.owner || '."' ||
22:43:46  13                          tab.object_name || '" UPGRADE';
22:43:46  14      EXCEPTION
22:43:46  15        WHEN OTHERS THEN
22:43:46  16        BEGIN
22:43:46  17          IF (sqlcode = -600 or sqlcode = -602 or sqlcode = -603) THEN
22:43:46  18            raise;
22:43:46  19          END IF;
22:43:46  20        END;
22:43:46  21      END;
22:43:46  22    END LOOP;
22:43:46  23    commit;
22:43:46  24  END;
22:43:46  25  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- for each table whose signature doesn't match ROOT's, mark its PL/SQL
22:43:46 sys@jpcdip04> -- dependents for local MCode
22:43:46 sys@jpcdip04> DECLARE
22:43:46   2    cursor c is
22:43:46   3      select obj#
22:43:46   4        from sys.obj$ o, sys.user$ u, sys.cdb$common_root_objects&pdbid ro
22:43:46   5      where o.type# <> 4 and u.name=ro.owner and u.user#=o.owner#
22:43:46   6        and o.name=ro.object_name and o.type#=ro.object_type and obj# in
22:43:46   7        (select d_obj# from sys.dependency$ where p_obj# in
22:43:46   8          (select p.object_id from sys.CDB$common_root_objects&pdbid r,
22:43:46   9                                   sys.cdb$tables&pdbid p
22:43:46  10           where r.owner=p.owner and r.object_name=p.object_name
22:43:46  11             and r.object_type=2 and r.object_sig <> p.object_sig));
22:43:46  12  BEGIN
22:43:46  13    FOR obj in c
22:43:46  14    LOOP
22:43:46  15      update sys.obj$ set flags=flags+33554432-bitand(flags, 33554432)
22:43:46  16                    where obj#=obj.obj#;
22:43:46  17    END LOOP;
22:43:46  18  END;
22:43:46  19  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.05
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> @@?/rdbms/admin/loc_to_common2.sql 0
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem $Header: rdbms/admin/loc_to_common2.sql /st_rdbms_19/1 2018/12/22 16:12:35 sumkumar Exp $
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem loc_to_common2.sql
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem Copyright (c) 2014, 2018, Oracle and/or its affiliates.
22:43:46 sys@jpcdip04> Rem All rights reserved.
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    NAME
22:43:46 sys@jpcdip04> Rem      loc_to_common2.sql - helper script for converting local to common
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    DESCRIPTION
22:43:46 sys@jpcdip04> Rem      Does the second set of operations needed to convert local to common.
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:43:46 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/loc_to_common2.sql
22:43:46 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/loc_to_common2.sql
22:43:46 sys@jpcdip04> Rem    SQL_PHASE: PDB
22:43:46 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:43:46 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:43:46 sys@jpcdip04> Rem    SQL_CALLING_FILE: rdbms/admin/noncdb_to_pdb.sql
22:43:46 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    NOTES
22:43:46 sys@jpcdip04> Rem      Called by noncdb_to_pdb.sql, apex_to_common.sql, pdb_to_apppdb.sql
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:43:46 sys@jpcdip04> Rem    sumkumar    12/20/18 - Bug 28964907: option$ column is null for non-cdb
22:43:46 sys@jpcdip04> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
22:43:46 sys@jpcdip04> Rem    sanagara    04/04/18 - Back out fix for bug 27464252
22:43:46 sys@jpcdip04> Rem    kquinn      02/12/18 - Bug 25979661: handle bogus common users
22:43:46 sys@jpcdip04> Rem    surman      03/13/18 - 27464252: Generic phase
22:43:46 sys@jpcdip04> Rem    thbaby      04/21/17 - Bug 25940936: set _enable_view_pdb
22:43:46 sys@jpcdip04> Rem    thbaby      03/13/17 - Bug 25212689: exception handler for truncate
22:43:46 sys@jpcdip04> Rem    pyam        06/29/16 - 23184418: truncate data link tables in app pdb
22:43:46 sys@jpcdip04> Rem    tojhuan     03/22/16 - 22465938: keep common views in status INVALID
22:43:46 sys@jpcdip04> Rem    akruglik    01/15/16 - (22132084) replace COMMON_DATA with EXTENDED DATA
22:43:46 sys@jpcdip04> Rem    pyam        12/22/15 - 21927236: rename pdb_to_fedpdb to pdb_to_apppdb
22:43:46 sys@jpcdip04> Rem    pyam        12/13/15 - LRG 18533922: dont invalidate
22:43:46 sys@jpcdip04> Rem                           STANDARD/DBMS_STANDARD
22:43:46 sys@jpcdip04> Rem    akruglik    11/24/15 - (21193922) App Common users are marked with both
22:43:46 sys@jpcdip04> Rem                           common and App-common bits
22:43:46 sys@jpcdip04> Rem    thbaby      09/02/15 - Bug 21774247: handle COMMON_DATA
22:43:46 sys@jpcdip04> Rem    pyam        06/24/15 - 21199445: mark converted objects as invalid
22:43:46 sys@jpcdip04> Rem    kquinn      05/18/15 - 21095719: improve performance
22:43:46 sys@jpcdip04> Rem    pyam        04/30/15 - 20989123: fix fed flags for user$
22:43:46 sys@jpcdip04> Rem    surman      01/08/15 - 19475031: Update SQL metadata
22:43:46 sys@jpcdip04> Rem    pyam        09/16/14 - Helper script #2 for converting local objects to
22:43:46 sys@jpcdip04> Rem                           common in a CDB environment.
22:43:46 sys@jpcdip04> Rem    pyam        09/16/14 - Created
22:43:46 sys@jpcdip04> Rem
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> Rem fed == &&1;
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- CDB Common Users/Roles have 128 (Common) set in user$.spare1 while App
22:43:46 sys@jpcdip04> -- Common Users/Roles have both 128 (Common) and 4096 (App Common) set.
22:43:46 sys@jpcdip04> COLUMN cmnusrflag NEW_VALUE cmnusrflag
22:43:46 sys@jpcdip04> select decode(&&1, 1, '4224', '128') cmnusrflag from dual;

CMN
---
128

1 row selected.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> COLUMN fedobjflag NEW_VALUE fedobjflag
22:43:46 sys@jpcdip04> select decode(&&1, 1, '134217728', '0') fedobjflag from dual;

F
-
0

1 row selected.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- 25979661: We might have some users already defined as a common user (e.g.
22:43:46 sys@jpcdip04> -- where we have built a traditional database from a shiphome but the shiphome
22:43:46 sys@jpcdip04> -- was originally built from a CB$ROOT). These users are currently APEX-related
22:43:46 sys@jpcdip04> -- so we need to clear the common user flag for this set of users at this
22:43:46 sys@jpcdip04> -- point.
22:43:46 sys@jpcdip04> update sys.user$ set spare1 = spare1 - &cmnusrflag
22:43:46   2  where bitand(spare1, &cmnusrflag) = &cmnusrflag
22:43:46   3  and bitand(spare1, 256) = 256                     -- KTSUCS1_ORCL = 0x100 = 256
22:43:46   4  and name like 'APEX%';

0 rows updated.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- 25979661: We also need to patch up the privilegess.
22:43:46 sys@jpcdip04> update sys.objauth$ set option$ = option$ +
22:43:46   2         -- convert KZDOOCMNWGO (0x10) to KZDOOWGO (0x1)
22:43:46   3         decode(bitand(option$, 16), 16,
22:43:46   4            -16+decode(bitand(option$, 1), 1, 0, 1), 0) +
22:43:46   5         -- convert KZDOOCMNWHO (0x20) to KZDOOWHO (0x2)
22:43:46   6         decode(bitand(option$, 32), 32,
22:43:46   7            -32 + decode(bitand(option$, 2), 2, 0, 2), 0) +
22:43:46   8         -- clear KZDOOCMN (0x8) and KZDOO_NO_LOCAL (0x4)
22:43:46   9         decode(bitand(option$, 8), 8, -8, 0) - 4
22:43:46  10  where bitand(option$, 4) = 4 and
22:43:46  11         (grantee# in (select user# from sys.user$ where name like 'APEX%') or
22:43:46  12          grantor# in (select user# from sys.user$ where name like 'APEX%'));

0 rows updated.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> update sys.objauth$ set option$ = option$ +
22:43:46   2         -- clear KZDOOCMN (0x08), KZDOOCMNWGO (0x10) and KZDOOCMNWHO (0x20)
22:43:46   3         decode(bitand(option$,  8),  8,  -8, 0) +
22:43:46   4         decode(bitand(option$, 16), 16, -16, 0) +
22:43:46   5         decode(bitand(option$, 32), 32, -32, 0)
22:43:46   6  where bitand(option$, 4) != 4 and
22:43:46   7         (grantee# in (select user# from sys.user$ where name like 'APEX%') or
22:43:46   8          grantor# in (select user# from sys.user$ where name like 'APEX%'));

0 rows updated.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> update sys.sysauth$ set option$ = option$ +
22:43:46   2         -- convert KZDSYSCMNWAO (0x10) to KZDSYSWAO (0x1)
22:43:46   3         decode(bitand(option$, 16), 16,
22:43:46   4            -16+decode(bitand(option$, 1), 1, 0, 1), 0) +
22:43:46   5         -- convert KZDSYSCMNWDO (0x20) to KZDSYSWDO (0x2)
22:43:46   6         decode(bitand(option$, 32), 32,
22:43:46   7            -32 + decode(bitand(option$, 2), 2, 0, 2), 0) +
22:43:46   8         -- clear KZDSYSCMN (0x8) and KZDSYS_NO_LOCAL (0x4)
22:43:46   9         decode(bitand(option$, 8), 8, -8, 0) - 4
22:43:46  10  where bitand(option$, 4) = 4 and
22:43:46  11         grantee# in (select user# from sys.user$ where name like 'APEX%');

0 rows updated.

Elapsed: 00:00:00.00
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> update sys.sysauth$ set option$ = option$ +
22:43:46   2         -- clear KZDSYSCMN (0x08), KZDSYSCMNWAO (0x10) and KZDSYSCMNWDO (0x20)
22:43:46   3         decode(bitand(option$,  8),  8,  -8, 0) +
22:43:46   4         decode(bitand(option$, 16), 16, -16, 0) +
22:43:46   5         decode(bitand(option$, 32), 32, -32, 0)
22:43:46   6  where bitand(option$, 4) != 4 and
22:43:46   7         grantee# in (select user# from sys.user$ where name like 'APEX%');

0 rows updated.

Elapsed: 00:00:00.02
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- mark users and roles in our PDB as common if they exist as common in ROOT
22:43:46 sys@jpcdip04> -- also compare the type# to ensure that we match users in PDB with users in
22:43:46 sys@jpcdip04> -- ROOT (and same for roles)
22:43:46 sys@jpcdip04> update sys.user$ a set a.spare1=a.spare1+&cmnusrflag where a.user# in (
22:43:46   2    select p.user# from sys.cdb$common_users&pdbid r, sys.user$ p
22:43:46   3    where r.name=p.name and r.type#=p.type# and bitand(p.spare1, 4224)=0);

0 rows updated.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- TODO: fed
22:43:46 sys@jpcdip04> -- mark privileges in our PDB as common if they exist as common in ROOT
22:43:46 sys@jpcdip04> DECLARE
22:43:46   2    cursor c is
22:43:46   3      select s.grantee#, s.privilege#
22:43:46   4        from sys.sysauth$ s, sys.user$ u, sys.cdb$commonsysprivs&pdbid r
22:43:46   5       where u.user#=s.grantee# and u.name=r.name and s.privilege#=r.privilege#
22:43:46   6             and bitand(nvl(s.option$,0),8)=0;
22:43:46   7  BEGIN
22:43:46   8    FOR obj in c
22:43:46   9    LOOP
22:43:46  10      BEGIN
22:43:46  11        update sys.sysauth$ set option$=nvl(option$,0)+12+bitand(nvl(option$,0),3)*15
22:43:46  12          where grantee#=obj.grantee# and privilege#=obj.privilege#;
22:43:46  13      END;
22:43:46  14    END LOOP;
22:43:46  15    commit;
22:43:46  16  END;
22:43:46  17  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- TODO: fed
22:43:46 sys@jpcdip04> DECLARE
22:43:46   2    cursor c is
22:43:46   3      select s.grantee#, s.privilege#
22:43:46   4        from sys.sysauth$ s, sys.user$ u, sys.cdb$commonrolegrants&pdbid r,
22:43:46   5             sys.user$ ru
22:43:46   6       where u.user#=s.grantee# and u.name=r.name and r.rolename=ru.name and
22:43:46   7             s.privilege#=ru.user# and bitand(nvl(s.option$,0),8)=0;
22:43:46   8  BEGIN
22:43:46   9    FOR obj in c
22:43:46  10    LOOP
22:43:46  11      BEGIN
22:43:46  12        update sys.sysauth$ set option$=nvl(option$,0)+12+bitand(nvl(option$,0),3)*15
22:43:46  13          where grantee#=obj.grantee# and privilege#=obj.privilege#;
22:43:46  14      END;
22:43:46  15    END LOOP;
22:43:46  16    commit;
22:43:46  17  END;
22:43:46  18  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.01
22:43:46 sys@jpcdip04> 
22:43:46 sys@jpcdip04> -- TODO: fed
22:43:46 sys@jpcdip04> DECLARE
22:43:46   2    cursor c is
22:43:46   3      select oa.privilege#, oa.grantee#, oa.obj#, oa.col#
22:43:46   4        from sys.objauth$ oa, sys.user$ u, sys.cdb$commonobjprivs&pdbid r,
22:43:46   5             sys.obj$ o, sys.user$ ou
22:43:46   6       where oa.privilege#=r.privilege# and oa.grantee#=u.user# and
22:43:46   7             u.name=r.name and o.name=r.objname and oa.obj#=o.obj# and
22:43:46   8             ou.name=r.owner and o.owner#=ou.user# and bitand(nvl(oa.option$,0),8)=0 and
22:43:46   9             ((oa.col# is null and r.col# is null) or oa.col#=r.col#);
22:43:46  10  
22:43:46  11  BEGIN
22:43:46  12    FOR obj in c
22:43:46  13    LOOP
22:43:46  14      BEGIN
22:43:46  15        IF (obj.col# is null) THEN
22:43:46  16          update sys.objauth$ set option$=nvl(option$,0)+12+bitand(nvl(option$,0),3)*15
22:43:46  17            where grantee#=obj.grantee# and privilege#=obj.privilege# and
22:43:46  18                  obj#=obj.obj# and col# is null;
22:43:46  19        ELSE
22:43:46  20          update sys.objauth$ set option$=nvl(option$,0)+12+bitand(nvl(option$,0),3)*15
22:43:46  21            where grantee#=obj.grantee# and privilege#=obj.privilege# and
22:43:46  22                  obj#=obj.obj# and col# = obj.col#;
22:43:46  23        END IF;
22:43:46  24  
22:43:46  25      END;
22:43:46  26    END LOOP;
22:43:46  27    commit;
22:43:46  28  END;
22:43:46  29  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:19.02
22:44:05 sys@jpcdip04> 
22:44:05 sys@jpcdip04> -- mark objects in our PDB as common if they exist as common in ROOT
22:44:05 sys@jpcdip04> -- mark them as invalid if they're of a type that can be invalid
22:44:05 sys@jpcdip04> -- LRG 18533922: refrain from invalidating STANDARD and DBMS_STANDARD
22:44:05 sys@jpcdip04> -- BUG 22465938: there is no guarantee that views are all validated
22:44:05 sys@jpcdip04> --     before noncdb_to_pdb/apex_to_common/pdb_to_apppdb, leading to
22:44:05 sys@jpcdip04> --     failure of follow-up loc_to_common steps. It is more robust to
22:44:05 sys@jpcdip04> --     keep their status INVALID (6) as we do on the other source objects.
22:44:05 sys@jpcdip04> --
22:44:05 sys@jpcdip04> -- NOTE: SHARING bits in OBJ$.FLAGS are:
22:44:05 sys@jpcdip04> -- - 65536  = MDL (Metadata Link)
22:44:05 sys@jpcdip04> -- - 131072 = DL (Data Link, formerly OBL)
22:44:05 sys@jpcdip04> -- - 4294967296 = EDL (Extended Data Link)
22:44:05 sys@jpcdip04> define mdl=65536
22:44:05 sys@jpcdip04> define dl=131072
22:44:05 sys@jpcdip04> define edl=4294967296
22:44:05 sys@jpcdip04> define sharing_bits=(&mdl+&dl+&edl)
22:44:05 sys@jpcdip04> 
22:44:05 sys@jpcdip04> DECLARE
22:44:05   2    cursor c is
22:44:05   3      select p.object_id,
22:44:05   4             p.flags-bitand(p.flags, &sharing_bits+&fedobjflag) flags,
22:44:05   5             decode(r.sharing, 'MDL', &mdl, 'DL', &dl, &edl+&mdl) sharing_flag,
22:44:05   6             case when p.object_type in (4, 7, 8, 9, 11, 12, 14, 22, 32, 33, 87)
22:44:05   7                   and p.object_subname is null
22:44:05   8                  then 6
22:44:05   9                  else 1
22:44:05  10             end new_status
22:44:05  11        from sys.cdb$common_root_objects&pdbid r, sys.cdb$objects&pdbid p
22:44:05  12      where r.owner=p.owner and r.object_name=p.object_name
22:44:05  13        and r.object_type=p.object_type and r.object_type != 13 and r.nsp=p.nsp
22:44:05  14        and (p.object_subname is null and r.object_subname is null
22:44:05  15             or r.object_subname=p.object_subname)
22:44:05  16        and decode(bitand(p.flags, &sharing_bits),
22:44:05  17                   &edl+&mdl, 'EDL', &dl, 'DL', &mdl, 'MDL', 'NONE')
22:44:05  18            <> r.sharing
22:44:05  19        and not (r.owner='SYS' and
22:44:05  20                 (r.object_name='STANDARD' or r.object_name='DBMS_STANDARD') and
22:44:05  21                 (r.object_type in (9, 11)));
22:44:05  22    cursor ctyp is
22:44:05  23      select p.object_id,
22:44:05  24             p.flags-bitand(p.flags, &sharing_bits+&fedobjflag) flags,
22:44:05  25             decode(r.sharing, 'MDL', &mdl, 'DL', &dl, &edl+&mdl) sharing_flag
22:44:05  26        from sys.cdb$cmn_root_types&pdbid r, sys.cdb$types&pdbid p
22:44:05  27      where r.owner=p.owner and r.object_name=p.object_name
22:44:05  28        and (p.object_subname is null and r.object_subname is null
22:44:05  29             or r.object_subname=p.object_subname)
22:44:05  30        and decode(bitand(p.flags, &sharing_bits),
22:44:05  31                   &edl+&mdl, 'EDL', &dl, 'DL', &mdl, 'MDL', 'NONE')<>r.sharing
22:44:05  32        and p.object_sig=r.object_sig and p.hashcode=r.hashcode;
22:44:05  33  BEGIN
22:44:05  34    FOR obj in c
22:44:05  35    LOOP
22:44:05  36      BEGIN
22:44:05  37        update sys.obj$ set flags=(obj.flags + obj.sharing_flag + &fedobjflag),
22:44:05  38                            status=obj.new_status
22:44:05  39                      where obj#=obj.object_id;
22:44:05  40      END;
22:44:05  41    END LOOP;
22:44:05  42    FOR obj in ctyp
22:44:05  43    LOOP
22:44:05  44      BEGIN
22:44:05  45        update sys.obj$ set flags=(obj.flags + obj.sharing_flag + &fedobjflag),
22:44:05  46                            status=6
22:44:05  47                      where obj#=obj.object_id;
22:44:05  48      END;
22:44:05  49    END LOOP;
22:44:05  50    commit;
22:44:05  51  END;
22:44:05  52  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.19
22:44:06 sys@jpcdip04> 
22:44:06 sys@jpcdip04> -- BUG 23184418: truncate and drop index for datalink table.
22:44:06 sys@jpcdip04> alter session set &scriptparam=true;

Session altered.

Elapsed: 00:00:00.00
22:44:06 sys@jpcdip04> 
22:44:06 sys@jpcdip04> -- make sure link flags are reloaded properly
22:44:06 sys@jpcdip04> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.01
22:44:06 sys@jpcdip04> 
22:44:06 sys@jpcdip04> DECLARE
22:44:06   2    cursor c is
22:44:06   3      select p.object_id, p.object_type,
22:44:06   4              '"' || p.owner || '"."' || p.object_name || '"' as name
22:44:06   5      from sys.cdb$objects&pdbid p
22:44:06   6      where p.object_type = 2 and bitand(p.flags, &dl) = &dl
22:44:06   7       and  bitand(p.flags, 134217728)=&fedobjflag;
22:44:06   8  BEGIN
22:44:06   9    FOR obj in c
22:44:06  10    LOOP
22:44:06  11      BEGIN
22:44:06  12        execute immediate 'TRUNCATE TABLE '|| obj.name;
22:44:06  13      EXCEPTION WHEN OTHERS THEN NULL;
22:44:06  14      END;
22:44:06  15  
22:44:06  16      FOR ind IN
22:44:06  17        (select '"'||u.name||'"."'||o.name||'"' as name
22:44:06  18         from obj$ o, user$ u, (select unique i.obj# as idx_obj
22:44:06  19                                from ind$ i
22:44:06  20                                where bo# = obj.object_id and i.type# = 1 and
22:44:06  21                                i.obj# not in (select nvl(enabled,0) from cdef$))
22:44:06  22         where o.obj# = idx_obj and user# = owner#)
22:44:06  23      LOOP
22:44:06  24        BEGIN
22:44:06  25          execute immediate 'DROP INDEX '|| ind.name;
22:44:06  26        EXCEPTION WHEN OTHERS THEN NULL;
22:44:06  27        END;
22:44:06  28      END LOOP;
22:44:06  29    END LOOP;
22:44:06  30  END;
22:44:06  31  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.90
22:44:07 sys@jpcdip04> alter session set &scriptparam=false;

Session altered.

Elapsed: 00:00:00.00
22:44:07 sys@jpcdip04> 
22:44:07 sys@jpcdip04> -- Bug 21774247: Handle COMMON_DATA tables (this includes tables for which
22:44:07 sys@jpcdip04> -- COMMON_DATA was specified explicitly as well as EXTENDED DATA tables
22:44:07 sys@jpcdip04> -- (for which COMMON_DATA bit will be getting set for the time being.))
22:44:07 sys@jpcdip04> -- Retrieve all tables marked as COMMON_DATA in Root and mark them as
22:44:07 sys@jpcdip04> -- COMMON_DATA in PDB (if not already marked as COMMON_DATA).
22:44:07 sys@jpcdip04> DECLARE
22:44:07   2    cursor c is
22:44:07   3      select p.object_id
22:44:07   4        from sys.cdb$cdata_root_tables&pdbid r, sys.cdb$objects&pdbid p
22:44:07   5       where r.owner=p.owner and r.object_name=p.object_name;
22:44:07   6  BEGIN
22:44:07   7    FOR obj in c
22:44:07   8      LOOP
22:44:07   9        BEGIN
22:44:07  10          update sys.tab$ t set t.property=(t.property + power(2,52))
22:44:07  11                          where bitand(t.property, power(2,52)) = 0
22:44:07  12                            and t.obj#=obj.object_id;
22:44:07  13        END;
22:44:07  14      END LOOP;
22:44:07  15      commit;
22:44:07  16  END;
22:44:07  17  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.02
22:44:07 sys@jpcdip04> 
22:44:07 sys@jpcdip04> -- Bug 21774247: Handle COMMON_DATA views (this includes views for which
22:44:07 sys@jpcdip04> -- COMMON_DATA was specified explicitly as well as EXTENDED DATA views
22:44:07 sys@jpcdip04> -- (for which COMMON_DATA bit will be getting set for the time being.))
22:44:07 sys@jpcdip04> -- Retrieve all views marked as COMMON_DATA in Root and mark them as
22:44:07 sys@jpcdip04> -- COMMON_DATA in PDB (if not already marked as COMMON_DATA).
22:44:07 sys@jpcdip04> DECLARE
22:44:07   2    cursor c is
22:44:07   3      select p.object_id
22:44:07   4        from sys.cdb$cdata_root_views&pdbid r, sys.cdb$objects&pdbid p
22:44:07   5       where r.owner=p.owner and r.object_name=p.object_name;
22:44:07   6  BEGIN
22:44:07   7    FOR obj in c
22:44:07   8      LOOP
22:44:07   9        BEGIN
22:44:07  10          update sys.view$ v set v.property=(v.property + power(2,52))
22:44:07  11                           where bitand(v.property, power(2,52)) = 0
22:44:07  12                             and v.obj#=obj.object_id;
22:44:07  13        END;
22:44:07  14      END LOOP;
22:44:07  15      commit;
22:44:07  16  END;
22:44:07  17  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.11
22:44:07 sys@jpcdip04> 
22:44:07 sys@jpcdip04> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.00
22:44:07 sys@jpcdip04> 
22:44:07 sys@jpcdip04> 
22:44:07 sys@jpcdip04> -- Mark types created via xml schema registration as local. Only need to do
22:44:07 sys@jpcdip04> -- this for common types with system generated name.
22:44:07 sys@jpcdip04> DECLARE
22:44:07   2    cursor c is
22:44:07   3      select p.obj#, p.flags oldflags
22:44:07   4      from sys.obj$ p, sys.dependency$ d, sys.obj$ o
22:44:07   5      where p.type#=13 and d.p_obj#=p.obj# and d.d_obj#=o.obj# and o.type#=55
22:44:07   6            and bitand(p.flags, &sharing_bits) != 0
22:44:07   7            and ((regexp_instr(p.name, '[0-9]_T',1,1) != 0 and
22:44:07   8                  regexp_instr(p.name, '[0-9]_T',1,1) = length(p.name)-2) or
22:44:07   9                 (regexp_instr(p.name, '[0-9]_COLL',1,1) != 0 and
22:44:07  10                  regexp_instr(p.name, '[0-9]_COLL',1,1) = length(p.name)-4));
22:44:07  11  BEGIN
22:44:07  12    FOR obj in c
22:44:07  13    LOOP
22:44:07  14      update sys.obj$ set flags=(obj.oldflags - bitand(obj.oldflags, &sharing_bits))
22:44:07  15                    where obj#=obj.obj#;
22:44:07  16    END LOOP;
22:44:07  17  END;
22:44:07  18  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
22:44:07 sys@jpcdip04> 
22:44:07 sys@jpcdip04> -- As types with system generated name created via xml schema registration
22:44:07 sys@jpcdip04> -- are marked as local, mark default tables depending on those types as
22:44:07 sys@jpcdip04> -- local too, plus default tables with system generated table name.
22:44:07 sys@jpcdip04> -- Only need to do this for common tables.
22:44:07 sys@jpcdip04> DECLARE
22:44:07   2    cursor c is
22:44:07   3    with v as (select p.obj#, p.flags pflags
22:44:07   4               from sys.obj$ p, sys.dependency$ d, sys.obj$ o
22:44:07   5               where p.type#=13 and p.obj#=d.p_obj# and d.d_obj#=o.obj#
22:44:07   6                     and o.type#=55)
22:44:07   7    select distinct o1.obj#, o1.flags oldflags
22:44:07   8    from v, sys.dependency$ d1, sys.obj$ o1
22:44:07   9    where v.obj#=d1.p_obj# and d1.d_obj#=o1.obj# and o1.type#=2
22:44:07  10          and bitand(o1.flags, &sharing_bits) != 0
22:44:07  11          and ((bitand(pflags, &sharing_bits) = 0) or
22:44:07  12               (regexp_instr(o1.name, '[0-9]_TAB',1,1) != 0 and
22:44:07  13                regexp_instr(o1.name, '[0-9]_TAB',1,1) = length(o1.name)-3));
22:44:07  14  BEGIN
22:44:07  15    FOR obj in c
22:44:07  16    LOOP
22:44:07  17      BEGIN
22:44:07  18        update sys.obj$ set flags=(obj.oldflags - bitand(obj.oldflags, &sharing_bits))
22:44:07  19                      where obj#=obj.obj#;
22:44:07  20      END;
22:44:07  21    END LOOP;
22:44:07  22  END;
22:44:07  23  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
22:44:08 sys@jpcdip04> 
22:44:08 sys@jpcdip04> -- As default tables created via xml schema registration are marked as local,
22:44:08 sys@jpcdip04> -- mark all nested tables as local too if its parent table is local.
22:44:08 sys@jpcdip04> -- Only need to do this for common nested tables.
22:44:08 sys@jpcdip04> declare
22:44:08   2    -- get local O-R xmltype parent table owned by common users
22:44:08   3    cursor ortabq is
22:44:08   4      select n.owner, n.parent_table_name
22:44:08   5      from sys.obj$ o, dba_users u, dba_nested_tables n,
22:44:08   6      ( select owner, table_name from dba_xml_tables
22:44:08   7        where storage_type='OBJECT-RELATIONAL'
22:44:08   8        union
22:44:08   9        select owner, table_name from dba_xml_tab_cols
22:44:08  10        where storage_type='OBJECT-RELATIONAL'
22:44:08  11       ) t
22:44:08  12      where n.owner = t.owner
22:44:08  13            and n.parent_table_name = t.table_name
22:44:08  14            and t.owner = u.username
22:44:08  15            and u.common='YES'
22:44:08  16            and u.user_id = o.owner#
22:44:08  17            and o.name = t.table_name
22:44:08  18            and bitand(o.flags, &sharing_bits) = 0
22:44:08  19      order by n.owner, n.parent_table_name;
22:44:08  20  
22:44:08  21    -- get the hierarchy of nested tables, given a parent table name and owner
22:44:08  22    cursor ntq(oname varchar2, pname varchar2) is
22:44:08  23      select n.owner, n.parent_table_name, n.table_name
22:44:08  24      from dba_nested_tables n
22:44:08  25      where n.owner=oname
22:44:08  26      start with parent_table_name=pname
22:44:08  27      connect by prior table_name=parent_table_name
22:44:08  28      order by n.owner, n.parent_table_name, n.table_name;
22:44:08  29  
22:44:08  30    -- get obj$ entries for the common nested tables, given its owner and name
22:44:08  31    cursor c (owner_name varchar2, obj_name varchar2) is
22:44:08  32      select o.obj#, o.flags oldflags
22:44:08  33      from sys.obj$ o, dba_users u
22:44:08  34      where o.owner#=u.user_id and u.username=owner_name and o.name=obj_name
22:44:08  35            and bitand(o.flags, &sharing_bits) != 0;
22:44:08  36  begin
22:44:08  37    for rec in ortabq loop
22:44:08  38      for ntrec in ntq(rec.owner, rec.parent_table_name) loop
22:44:08  39        for obj in c(ntrec.owner, ntrec.table_name) loop
22:44:08  40          begin
22:44:08  41            update sys.obj$
22:44:08  42               set flags=(obj.oldflags - bitand(obj.oldflags, &sharing_bits))
22:44:08  43             where obj#=obj.obj#;
22:44:08  44          end;
22:44:08  45        end loop;
22:44:08  46      end loop;
22:44:08  47    end loop;
22:44:08  48  end;
22:44:08  49  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:01.30
22:44:09 sys@jpcdip04> 
22:44:09 sys@jpcdip04> select to_char(sysdate, 'Dy DD-Mon-YYYY HH24:MI:SS') from dual;

TO_CHAR(SYSDATE,'DYDD-MON-YYYYHH24:MI:SS')
------------------------------------------
Wed 06-Mar-2024 22:44:09

1 row selected.

Elapsed: 00:00:00.00
22:44:09 sys@jpcdip04> 
22:44:09 sys@jpcdip04> -- get rid of idl_ub1$ rows for MDL java objects
22:44:09 sys@jpcdip04> delete from sys.idl_ub1$ where obj# in (select obj# from sys.obj$ where bitand(flags, 65536)=65536 and type# in (28,29,30,56));

40576 rows deleted.

Elapsed: 00:00:37.69
22:44:46 sys@jpcdip04> commit;

Commit complete.

Elapsed: 00:00:00.00
22:44:46 sys@jpcdip04> 
22:44:46 sys@jpcdip04> -- normalize dependencies for MDL java objects (includes classes.bin objects)
22:44:46 sys@jpcdip04> delete from sys.dependency$ where d_obj# in (select obj# from sys.obj$ where bitand(flags,65536)=65536 and type# in (29,56));

74994 rows deleted.

Elapsed: 00:00:01.36
22:44:48 sys@jpcdip04> 
22:44:48 sys@jpcdip04> insert into sys.dependency$ (select do.obj#,do.stime,order#,po.obj#,po.stime,do.owner#,property,d_attrs,d_reason from sys.obj$ do,sys.user$ du,sys.obj$ po,sys.user$ pu,sys.cdb$rootdeps&pdbid rd where du.user#=do.owner# and pu.user#=po.owner# and do.name=rd.name and du.name=owner and do.type#=d_type# and po.name=referenced_name and pu.name=referenced_owner and po.type#=p_type# and bitand(do.flags,65536)=65536 and do.type# in (29,56));

74994 rows created.

Elapsed: 00:00:01.23
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> commit;

Commit complete.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.01
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> select owner#, name from sys.obj$ where bitand(flags, 33554432)=33554432
22:44:49   2    order by 1, 2;

no rows selected

Elapsed: 00:00:00.02
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> -- pass in 1 to indicate that we need to invalidate STANDARD and DBMS_STANDARD
22:44:49 sys@jpcdip04> @@?/rdbms/admin/loc_to_common3.sql 1
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem $Header: rdbms/admin/loc_to_common3.sql /main/11 2018/07/25 13:49:55 surman Exp $
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem loc_to_common3.sql
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem Copyright (c) 2014, 2018, Oracle and/or its affiliates.
22:44:49 sys@jpcdip04> Rem All rights reserved.
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem    NAME
22:44:49 sys@jpcdip04> Rem      loc_to_common3.sql - helper script for converting local to common
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem    DESCRIPTION
22:44:49 sys@jpcdip04> Rem      Does the third set of operations needed to convert local to common.
22:44:49 sys@jpcdip04> Rem      Does utlip + utlrp + related tasks.
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem    NOTES
22:44:49 sys@jpcdip04> Rem      Called by noncdb_to_pdb.sql, apex_to_common.sql, pdb_to_apppdb.sql
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:44:49 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/loc_to_common3.sql
22:44:49 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/loc_to_common3.sql
22:44:49 sys@jpcdip04> Rem    SQL_PHASE: PDB
22:44:49 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:44:49 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:44:49 sys@jpcdip04> Rem    SQL_CALLING_FILE: rdbms/admin/noncdb_to_pdb.sql
22:44:49 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:44:49 sys@jpcdip04> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
22:44:49 sys@jpcdip04> Rem    sanagara    04/04/18 - Back out fix for bug 27464252
22:44:49 sys@jpcdip04> Rem    surman      03/13/18 - 27464252: Generic phase
22:44:49 sys@jpcdip04> Rem    pyam        07/20/17 - Bug 26434999: turn off concurrent stats gathering
22:44:49 sys@jpcdip04> Rem    thbaby      04/22/17 - Bug 25940936: set _enable_view_pdb
22:44:49 sys@jpcdip04> Rem    pyam        12/22/15 - 21927236: rename pdb_to_fedpdb to pdb_to_apppdb
22:44:49 sys@jpcdip04> Rem    pyam        12/13/15 - LRG 18533922: convert STANDARD/DBMS_STANDARD if
22:44:49 sys@jpcdip04> Rem                           necessary
22:44:49 sys@jpcdip04> Rem    pyam        10/21/15 - 12172090: move up marking valid of old type
22:44:49 sys@jpcdip04> Rem                           versions
22:44:49 sys@jpcdip04> Rem    vperiwal    03/26/15 - 20172151: add immediate instances = all for close
22:44:49 sys@jpcdip04> Rem    surman      01/08/15 - 19475031: Update SQL metadata
22:44:49 sys@jpcdip04> Rem    pyam        09/16/14 - Helper script #3 for converting local objects to
22:44:49 sys@jpcdip04> Rem                           common in a CDB environment.
22:44:49 sys@jpcdip04> Rem    pyam        09/16/14 - Created
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> Rem invalidate_standard == &&1;
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> -- if requested, invalidate STANDARD and DBMS_STANDARD and mark them common
22:44:49 sys@jpcdip04> update obj$ set status=6, flags=flags-bitand(flags,196608)+65536
22:44:49   2   where &&1=1 and name in ('STANDARD', 'DBMS_STANDARD');

4 rows updated.

Elapsed: 00:00:00.02
22:44:49 sys@jpcdip04> commit;

Commit complete.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> @@?/rdbms/admin/utlip
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem $Header: rdbms/admin/utlip.sql
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem utlip.sql
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem Copyright (c) 1998, 2017, Oracle and/or its affiliates.
22:44:49 sys@jpcdip04> Rem All rights reserved.
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem   NAME
22:44:49 sys@jpcdip04> Rem     utlip.sql - UTiLity script to Invalidate Pl/sql
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem   DESCRIPTION
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem     *WARNING*   *WARNING*  *WARNING*  *WARNING*  *WARNING*  *WARNING*
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem     Do not run this script directly.
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem     utlip.sql is automatically executed when required for database
22:44:49 sys@jpcdip04> Rem     upgrades.
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem     Use utlirp.sql if you are looking to invalidate and recompile
22:44:49 sys@jpcdip04> Rem     PL/SQL for a 32-bit to 64-bit conversion. Use dbmsupgnv.sql
22:44:49 sys@jpcdip04> Rem     to convert all PL/SQL to NATIVE or dbmsupgin.sql to convert all
22:44:49 sys@jpcdip04> Rem     PL/SQL to INTERPRETED.
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem     set serveroutput must be set to off before
22:44:49 sys@jpcdip04> Rem     invoking this script otherwise deadlocks
22:44:49 sys@jpcdip04> Rem     and internal errors may result.
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem     *WARNING*   *WARNING*  *WARNING*  *WARNING*  *WARNING*  *WARNING*
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:44:49 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/utlip.sql
22:44:49 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/utlip.sql
22:44:49 sys@jpcdip04> Rem    SQL_PHASE: UPGRADE
22:44:49 sys@jpcdip04> Rem    SQL_STARTUP_MODE: UPGRADE
22:44:49 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:44:49 sys@jpcdip04> Rem    SQL_CALLING_FILE: rdbms/admin/catupstr.sql
22:44:49 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:44:49 sys@jpcdip04> Rem
22:44:49 sys@jpcdip04> Rem   MODIFIED   (MM/DD/YY)
22:44:49 sys@jpcdip04> Rem    pyam        09/08/17 - 25837415: delete diana with negative version num
22:44:49 sys@jpcdip04> Rem    raeburns    03/09/17 - Bug 25616909: Use UPGRADE for SQL_PHASE
22:44:49 sys@jpcdip04> Rem    pyam        02/10/17 - Fwd merge 25125745: remove deletes
22:44:49 sys@jpcdip04> Rem    pyam        09/30/16 - 24711897: delete potential duplicate idl_* rows
22:44:49 sys@jpcdip04> Rem    jaeblee     06/13/16 - 23239870: force compilation of standard
22:44:49 sys@jpcdip04> Rem    pyam        12/22/15 - 21927236: update props$ checks to pdb_to_apppdb
22:44:49 sys@jpcdip04> Rem    pyam        06/11/14 - LRG 11949012: fix invalidation clause for
22:44:49 sys@jpcdip04> Rem                           noncdb_to_pdb.sql
22:44:49 sys@jpcdip04> Rem    pyam        05/22/14 - for ncdb-to-pdb conversion, invalidate not only
22:44:49 sys@jpcdip04> Rem                           plsql
22:44:49 sys@jpcdip04> Rem    pyam        04/17/14 - 18063022: now called from noncdb_to_pdb.sql.
22:44:49 sys@jpcdip04> Rem                           Invalidate only common objs if unconverted
22:44:49 sys@jpcdip04> Rem                           non-CDB
22:44:49 sys@jpcdip04> Rem    jerrede     11/08/12 - Document set serveroutput on deadlock issue
22:44:49 sys@jpcdip04> Rem                           Lrg 8473773
22:44:49 sys@jpcdip04> Rem    gviswana    05/02/07 - Add warning messages; revert view Diana delete
22:44:49 sys@jpcdip04> Rem    gviswana    06/10/06 - Delete Diana performance optimization
22:44:49 sys@jpcdip04> Rem    gviswana    06/06/06 - Delete 11.x Diana for fine-grain deps
22:44:49 sys@jpcdip04> Rem    ssubrama    12/30/05 - bug 4882839 invalidate dbms_standard dependents
22:44:49 sys@jpcdip04> Rem    gviswana    06/17/05 - Delete sequence Diana
22:44:49 sys@jpcdip04> Rem    weiwang     05/06/05 - invalidate rules engine objects
22:44:49 sys@jpcdip04> Rem    ciyer       07/24/04 - selectively invalidate views and synonyms
22:44:49 sys@jpcdip04> Rem    jmuller     02/12/04 - Fix bug 3432304: commit even if no rows deleted
22:44:49 sys@jpcdip04> Rem    gviswana    08/28/03 - 3103287: Remove Diana deletions for PL/SQL
22:44:49 sys@jpcdip04> Rem    jmallory    08/18/03 - Hardcode dbms_dbupgrade_subname
22:44:49 sys@jpcdip04> Rem    gviswana    06/23/03 - 2985184: Invalidate dependent views
22:44:49 sys@jpcdip04> Rem    kquinn      07/22/03 - 3009599: Handle remote dbms_standard case
22:44:49 sys@jpcdip04> Rem    jmallory    06/09/03 - Fix null checking
22:44:49 sys@jpcdip04> Rem    jmallory    03/31/03 - Exclude dbupgrade objects
22:44:49 sys@jpcdip04> Rem    gviswana    04/16/03 - Move system parameter handling to utlirp.sql
22:44:49 sys@jpcdip04> Rem    kmuthukk    02/03/03 - fix update performance
22:44:49 sys@jpcdip04> Rem    nfolkert    12/23/02 - invalidate summary objects
22:44:49 sys@jpcdip04> Rem    kmuthukk    10/22/02 - ncomp dlls in db
22:44:49 sys@jpcdip04> Rem    gviswana    10/28/02 - Deferred synonym translation
22:44:49 sys@jpcdip04> Rem    rdecker     11/09/01 - remove CREATE library code FOR bug 1952368
22:44:49 sys@jpcdip04> Rem    gviswana    08/17/01 - Break up IDL_ deletes to avoid blowing rollback
22:44:49 sys@jpcdip04> Rem    rburns      08/23/01 - bug 1950073 - add exit on error
22:44:49 sys@jpcdip04> Rem    rburns      08/24/01 - add plitblm
22:44:49 sys@jpcdip04> Rem    rburns      07/26/01 - invalidate index types and operators
22:44:49 sys@jpcdip04> Rem    rxgovind    04/30/01 - interim fix for bug-1747462
22:44:49 sys@jpcdip04> Rem    gviswana    10/19/00 - Disable system triggers for Standard recompile
22:44:49 sys@jpcdip04> Rem    sbalaram    06/01/00 - Add prvthssq.sql after resolving Bug 1292760
22:44:49 sys@jpcdip04> Rem    thoang      05/26/00 - Do not invalidate earlier type versions
22:44:49 sys@jpcdip04> Rem    jdavison    04/11/00 - Modify usage notes for 8.2 changes.
22:44:49 sys@jpcdip04> Rem    rshaikh     09/22/99 - quote library names
22:44:49 sys@jpcdip04> Rem    mjungerm    06/15/99 - add java shared data object type
22:44:49 sys@jpcdip04> Rem    rshaikh     02/12/99 - dont delete java idl objects
22:44:49 sys@jpcdip04> Rem    rshaikh     11/17/98 - remove obsolete comments
22:44:49 sys@jpcdip04> Rem    rshaikh     10/30/98 - add slash after last truncate stmt
22:44:49 sys@jpcdip04> Rem    abrik       10/01/98 - just truncate idl_*$ tables
22:44:49 sys@jpcdip04> Rem    rshaikh     10/14/98 - bug 491101: recreate libraries
22:44:49 sys@jpcdip04> Rem    ncramesh    08/04/98 - change for sqlplus
22:44:49 sys@jpcdip04> Rem    rshaikh     07/20/98 - add commits
22:44:49 sys@jpcdip04> Rem    usundara    06/03/98 - merge from 8.0.5
22:44:49 sys@jpcdip04> Rem    usundara    04/29/98 - creation (split from utlirp)
22:44:49 sys@jpcdip04> Rem                           Kannan Muthukkaruppan (kmuthukk) was the original
22:44:49 sys@jpcdip04> Rem                           author of this script.
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> Rem ===========================================================================
22:44:49 sys@jpcdip04> Rem BEGIN utlip.sql
22:44:49 sys@jpcdip04> Rem ===========================================================================
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> Rem Exit immediately if Any failure in this script
22:44:49 sys@jpcdip04> WHENEVER SQLERROR EXIT;
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> -- If we are in the middle of converting a PDB, the initial objects we
22:44:49 sys@jpcdip04> -- invalidate should be limited to common objects
22:44:49 sys@jpcdip04> COLUMN andcommon NEW_VALUE andcommon
22:44:49 sys@jpcdip04> select decode(cnt, 0, '', 'and bitand(flags,196608)<>0') andcommon
22:44:49   2    from (select count(*) cnt from props$
22:44:49   3          where name in ('NONCDB_TO_PDB.SQL', 'PDB_TO_APPPDB.SQL')
22:44:49   4            and value$='CONVERTING');

ANDCOMMON
---------------------------
and bitand(flags,196608)<>0

1 row selected.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> -- if invalidate should be limited to Oracle-supplied objects
22:44:49 sys@jpcdip04> COLUMN andorclsupp NEW_VALUE andorclsupp
22:44:49 sys@jpcdip04> select decode(cnt, 0, '', 'and bitand(flags,4194304)<>0') andorclsupp
22:44:49   2    from (select count(*) cnt from props$
22:44:49   3          where name='NONCDB_TO_PDB.SQL' and value$='CONVERTING');

ANDORCLSUPP
----------------------------
and bitand(flags,4194304)<>0

1 row selected.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> -- if invalidate should be limited to Application Container objects
22:44:49 sys@jpcdip04> COLUMN andapp NEW_VALUE andapp
22:44:49 sys@jpcdip04> select decode(cnt, 0, '', 'and bitand(flags,134217728)<>0') andapp
22:44:49   2    from (select count(*) cnt from props$
22:44:49   3          where name='PDB_TO_APPPDB.SQL' and value$='CONVERTING');

ANDAPP
------------------------------


1 row selected.

Elapsed: 00:00:00.01
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> -- specify types to invalidate. If we're converting, invalidate beyond plsql
22:44:49 sys@jpcdip04> COLUMN typestoinv NEW_VALUE typestoinv
22:44:49 sys@jpcdip04> select decode(cnt, 0,
22:44:49   2     '((type# in (7, 8, 9, 11, 12, 14, 22, 32, 33, 87)) or (type# = 13 and subname is null))',
22:44:49   3     '((type# in (4,5,6,7,8,9,11,12,14,22,23,32,33)) or (type# = 13 and subname is null))')
22:44:49   4         typestoinv
22:44:49   5    from (select count(*) cnt from props$
22:44:49   6          where name in ('NONCDB_TO_PDB.SQL', 'PDB_TO_APPPDB.SQL')
22:44:49   7            and value$='CONVERTING');

TYPESTOINV
--------------------------------------------------------------------------------
((type# in (4,5,6,7,8,9,11,12,14,22,23,32,33)) or (type# = 13 and subname is nul
l))


1 row selected.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> -- call standard and dbmsstdx if this is not for app container conversion
22:44:49 sys@jpcdip04> COLUMN standard NEW_VALUE standard
22:44:49 sys@jpcdip04> select decode(cnt, 0, 'standard', 'nothing') standard
22:44:49   2    from (select count(*) cnt from props$
22:44:49   3          where name='PDB_TO_APPPDB.SQL' and value$='CONVERTING');

STANDARD
--------
standard

1 row selected.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> COLUMN dbmsstdx NEW_VALUE dbmsstdx
22:44:49 sys@jpcdip04> select decode(cnt, 0, 'dbmsstdx', 'nothing') dbmsstdx
22:44:49   2    from (select count(*) cnt from props$
22:44:49   3          where name='PDB_TO_APPPDB.SQL' and value$='CONVERTING');

DBMSSTDX
--------
dbmsstdx

1 row selected.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> -- Step (I)
22:44:49 sys@jpcdip04> --
22:44:49 sys@jpcdip04> -- First we invalidate all stored PL/SQL units (procs, fns, pkgs,
22:44:49 sys@jpcdip04> -- types, triggers.)
22:44:49 sys@jpcdip04> --
22:44:49 sys@jpcdip04> --   The type# in the update statement below indicates the KGL
22:44:49 sys@jpcdip04> --   type of the object. They have the following interpretation:
22:44:49 sys@jpcdip04> --       7 - pl/sql stored procedure
22:44:49 sys@jpcdip04> --       8 - pl/sql stored function
22:44:49 sys@jpcdip04> --       9 - pl/sql pkg spec
22:44:49 sys@jpcdip04> --      11 - pl/sql pkg body
22:44:49 sys@jpcdip04> --      12 - trigger
22:44:49 sys@jpcdip04> --      13 - type spec
22:44:49 sys@jpcdip04> --      14 - type body
22:44:49 sys@jpcdip04> --      22 - library
22:44:49 sys@jpcdip04> --      32 - indextype
22:44:49 sys@jpcdip04> --      33 - operator
22:44:49 sys@jpcdip04> --
22:44:49 sys@jpcdip04> -- Earlier type versions do not need to be invalidated since all pgm
22:44:49 sys@jpcdip04> -- units reference latest type versions. There is no mechanisms to
22:44:49 sys@jpcdip04> -- recompile earlier type versions anyway. They must be kept valid so
22:44:49 sys@jpcdip04> -- we can get access to its TDO to handle image conversion from one type
22:44:49 sys@jpcdip04> -- version to another.
22:44:49 sys@jpcdip04> -- All earlier type versions has the version name stored in obj$.subname
22:44:49 sys@jpcdip04> -- and the latest type version always has a null subname. We use this
22:44:49 sys@jpcdip04> -- fact to invalidate only the latest type version.
22:44:49 sys@jpcdip04> update obj$ set status = 6
22:44:49   2          where &typestoinv
22:44:49   3          and ((subname is null) or (subname <> 'DBMS_DBUPGRADE_BABY'))
22:44:49   4          and status not in (5,6)
22:44:49   5          and linkname is null
22:44:49   6          and not exists (select 1
22:44:49   7                          from type$
22:44:49   8                          where (bitand(properties, 16) = 16)
22:44:49   9                          and toid = obj$.oid$) &andorclsupp &andapp
22:44:49  10  /

11934 rows updated.

Elapsed: 00:00:00.26
22:44:49 sys@jpcdip04> commit
22:44:49   2  /

Commit complete.

Elapsed: 00:00:00.01
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> Rem Always invalidate MVs during upgrades/ downgrades
22:44:49 sys@jpcdip04> update obj$ set status = 5 where type# = 42;

0 rows updated.

Elapsed: 00:00:00.01
22:44:49 sys@jpcdip04> commit;

Commit complete.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> UPDATE sys.obj$ SET status = 5
22:44:49   2  where obj# in
22:44:49   3    ((select obj# from obj$ where type# = 62 or type# = 46 or type# = 59)
22:44:49   4     union all
22:44:49   5     (select /*+ index (dependency$ i_dependency2) */
22:44:49   6        d_obj# from dependency$
22:44:49   7        connect by prior d_obj# = p_obj#
22:44:49   8        start with p_obj# in
22:44:49   9          (select obj# from obj$ where type# = 62 or type# = 46 or type# = 59)))
22:44:49  10    &andcommon
22:44:49  11  /

0 rows updated.

Elapsed: 00:00:00.02
22:44:49 sys@jpcdip04> commit
22:44:49   2  /

Commit complete.

Elapsed: 00:00:00.01
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> -- Invalidate all synonym dependents of dbms_standard. If not we will end up
22:44:49 sys@jpcdip04> -- with a timestamp mismatch between dependency  and obj
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> update obj$ set status=6 where obj# in
22:44:49   2  (select d_obj# from dependency$
22:44:49   3   where p_obj# in (select obj# from obj$ where name='DBMS_STANDARD' and
22:44:49   4                    type# in ( 9, 11) and owner#=0)
22:44:49   5  ) and type#=5
22:44:49   6  /

1 row updated.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> commit
22:44:49   2  /

Commit complete.

Elapsed: 00:00:00.01
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> alter system flush shared_pool
22:44:49   2  /

System altered.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> --
22:44:49 sys@jpcdip04> -- Step (II)
22:44:49 sys@jpcdip04> --
22:44:49 sys@jpcdip04> -- Delete Diana to force full recompile (rather than fast validation).
22:44:49 sys@jpcdip04> -- Diana deletion is accomplished by changing the version number to make
22:44:49 sys@jpcdip04> -- rows invisible.
22:44:49 sys@jpcdip04> -- bug 25837415: delete any existing DIANA with negative version. We can have
22:44:49 sys@jpcdip04> -- pre-existing DIANA with negative version when noncdb_to_pdb.sql has
22:44:49 sys@jpcdip04> -- previously been run.
22:44:49 sys@jpcdip04> --
22:44:49 sys@jpcdip04> delete from idl_ub1$ where part = 0 and version<=-184549376;

0 rows deleted.

Elapsed: 00:00:00.02
22:44:49 sys@jpcdip04> delete from idl_ub2$ where part = 0 and version<=-184549376;

0 rows deleted.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> delete from idl_sb4$ where part = 0 and version<=-184549376;

0 rows deleted.

Elapsed: 00:00:00.01
22:44:49 sys@jpcdip04> delete from idl_char$ where part = 0 and version<=-184549376;

0 rows deleted.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> commit;

Commit complete.

Elapsed: 00:00:00.00
22:44:49 sys@jpcdip04> 
22:44:49 sys@jpcdip04> update idl_ub1$ set version = -version
22:44:49   2   where part = 0 and version >= 184549376
22:44:49   3     and obj# IN
22:44:49   4         (select obj# from obj$ o where status in (5, 6) and
22:44:49   5                 type# in (7, 8, 9, 11, 12, 13, 14, 22, 32, 33, 87));

5972 rows updated.

Elapsed: 00:00:00.32
22:44:50 sys@jpcdip04> update idl_ub2$ SET version = -version
22:44:50   2   where part = 0 and version >= 184549376
22:44:50   3     and obj# IN
22:44:50   4         (select obj# from obj$ o where status in (5, 6) and
22:44:50   5                 type# in (7, 8, 9, 11, 12, 13, 14, 22, 32, 33, 87));

12828 rows updated.

Elapsed: 00:00:00.26
22:44:50 sys@jpcdip04> update idl_sb4$ SET version = -version
22:44:50   2   where part = 0 and version >= 184549376
22:44:50   3     and obj# IN
22:44:50   4         (select obj# from obj$ o where status in (5, 6) and
22:44:50   5                 type# in (7, 8, 9, 11, 12, 13, 14, 22, 32, 33, 87));

11959 rows updated.

Elapsed: 00:00:00.22
22:44:50 sys@jpcdip04> update idl_char$ SET version = -version
22:44:50   2   where part = 0 and version >= 184549376
22:44:50   3     and obj# IN
22:44:50   4         (select obj# from obj$ o where status in (5, 6) and
22:44:50   5                 type# in (7, 8, 9, 11, 12, 13, 14, 22, 32, 33, 87));

6084 rows updated.

Elapsed: 00:00:00.08
22:44:50 sys@jpcdip04> 
22:44:50 sys@jpcdip04> commit;

Commit complete.

Elapsed: 00:00:00.00
22:44:50 sys@jpcdip04> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.01
22:44:50 sys@jpcdip04> 
22:44:50 sys@jpcdip04> -- Step (II)
22:44:50 sys@jpcdip04> --
22:44:50 sys@jpcdip04> -- Recreate package standard and dbms_standard. This is needed to execute
22:44:50 sys@jpcdip04> -- subsequent anonymous blocks
22:44:50 sys@jpcdip04> alter session set "_force_standard_compile"=TRUE;

Session altered.

Elapsed: 00:00:00.00
22:44:50 sys@jpcdip04> @@&standard
22:44:50 sys@jpcdip04> @@?/rdbms/admin/sqlsessstart.sql
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem $Header: rdbms/admin/sqlsessstart.sql /main/3 2018/07/25 13:50:02 surman Exp $
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem sqlsessstart.sql
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
22:44:50 sys@jpcdip04> Rem All rights reserved.
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem    NAME
22:44:50 sys@jpcdip04> Rem      sqlsessstart.sql - SQL session start
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem    DESCRIPTION
22:44:50 sys@jpcdip04> Rem      Any commands which should be run at the start of all oracle
22:44:50 sys@jpcdip04> Rem      supplied scripts.
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem    NOTES
22:44:50 sys@jpcdip04> Rem      See sqlsessend.sql for the corresponding end script.
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:44:50 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessstart.sql
22:44:50 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessstart.sql
22:44:50 sys@jpcdip04> Rem    SQL_PHASE: MISC
22:44:50 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:44:50 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:44:50 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:44:50 sys@jpcdip04> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
22:44:50 sys@jpcdip04> Rem    surman      03/08/13 - 16462837: Common start and end scripts
22:44:50 sys@jpcdip04> Rem    surman      03/08/13 - Created
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> 
22:44:50 sys@jpcdip04> alter session set "_ORACLE_SCRIPT" = true;

Session altered.

Elapsed: 00:00:00.00
22:44:50 sys@jpcdip04> @@stdspec.sql
22:44:50 sys@jpcdip04> @@?/rdbms/admin/sqlsessstart.sql
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem $Header: rdbms/admin/sqlsessstart.sql /main/3 2018/07/25 13:50:02 surman Exp $
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem sqlsessstart.sql
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
22:44:50 sys@jpcdip04> Rem All rights reserved.
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem    NAME
22:44:50 sys@jpcdip04> Rem      sqlsessstart.sql - SQL session start
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem    DESCRIPTION
22:44:50 sys@jpcdip04> Rem      Any commands which should be run at the start of all oracle
22:44:50 sys@jpcdip04> Rem      supplied scripts.
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem    NOTES
22:44:50 sys@jpcdip04> Rem      See sqlsessend.sql for the corresponding end script.
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:44:50 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessstart.sql
22:44:50 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessstart.sql
22:44:50 sys@jpcdip04> Rem    SQL_PHASE: MISC
22:44:50 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:44:50 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:44:50 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:44:50 sys@jpcdip04> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
22:44:50 sys@jpcdip04> Rem    surman      03/08/13 - 16462837: Common start and end scripts
22:44:50 sys@jpcdip04> Rem    surman      03/08/13 - Created
22:44:50 sys@jpcdip04> Rem
22:44:50 sys@jpcdip04> 
22:44:50 sys@jpcdip04> alter session set "_ORACLE_SCRIPT" = true;

Session altered.

Elapsed: 00:00:00.00
22:44:50 sys@jpcdip04> create or replace
22:44:50   2  package STANDARD AUTHID CURRENT_USER is              -- careful on this line; SED edit occurs!
22:44:50   3  
22:44:50   4    /********** Types and subtypes, do not reorder **********/
22:44:50   5    type BOOLEAN is (FALSE, TRUE);
22:44:50   6  
22:44:50   7    type DATE is DATE_BASE;
22:44:50   8  
22:44:50   9    type NUMBER is NUMBER_BASE;
22:44:50  10    subtype FLOAT is NUMBER; -- NUMBER(126)
22:44:50  11    subtype REAL is FLOAT; -- FLOAT(63)
22:44:50  12    subtype "DOUBLE PRECISION" is FLOAT;
22:44:50  13    subtype INTEGER is NUMBER(38,0);
22:44:50  14    subtype INT is INTEGER;
22:44:50  15    subtype SMALLINT is NUMBER(38,0);
22:44:50  16    subtype DECIMAL is NUMBER(38,0);
22:44:50  17    subtype NUMERIC is DECIMAL;
22:44:50  18    subtype DEC is DECIMAL;
22:44:50  19  
22:44:50  20  
22:44:50  21    subtype BINARY_INTEGER is INTEGER range '-2147483647'..2147483647;
22:44:50  22    subtype NATURAL is BINARY_INTEGER range 0..2147483647;
22:44:50  23    subtype NATURALN is NATURAL not null;
22:44:50  24    subtype POSITIVE is BINARY_INTEGER range 1..2147483647;
22:44:50  25    subtype POSITIVEN is POSITIVE not null;
22:44:50  26    subtype SIGNTYPE is BINARY_INTEGER range '-1'..1;  -- for SIGN functions
22:44:50  27  
22:44:50  28    type VARCHAR2 is NEW CHAR_BASE;
22:44:50  29  
22:44:50  30    subtype VARCHAR is VARCHAR2;
22:44:50  31    subtype STRING is VARCHAR2;
22:44:50  32  
22:44:50  33    subtype LONG is VARCHAR2(32760);
22:44:50  34  
22:44:50  35    subtype RAW is VARCHAR2;
22:44:50  36    subtype "LONG RAW" is RAW(32760);
22:44:50  37  
22:44:50  38    subtype ROWID is VARCHAR2(256);
22:44:50  39  
22:44:50  40    -- Ansi fixed-length char
22:44:50  41    -- Define synonyms for CHAR and CHARN.
22:44:50  42    subtype CHAR is VARCHAR2;
22:44:50  43    subtype CHARACTER is CHAR;
22:44:50  44  
22:44:50  45    type MLSLABEL is new CHAR_BASE;
22:44:50  46  
22:44:50  47    -- Large object data types.
22:44:50  48    --  binary, character, binary file.
22:44:50  49    type  BLOB is BLOB_BASE;
22:44:50  50    type  CLOB is CLOB_BASE;
22:44:50  51    type  BFILE is BFILE_BASE;
22:44:50  52  
22:44:50  53    -- Verbose and NCHAR type names
22:44:50  54    subtype "CHARACTER VARYING" is VARCHAR;
22:44:50  55    subtype "CHAR VARYING" is VARCHAR;
22:44:50  56    subtype "NATIONAL CHARACTER" is CHAR CHARACTER SET NCHAR_CS;
22:44:50  57    subtype "NATIONAL CHAR" is CHAR CHARACTER SET NCHAR_CS;
22:44:50  58    subtype "NCHAR" is CHAR CHARACTER SET NCHAR_CS;
22:44:50  59    subtype "NATIONAL CHARACTER VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
22:44:50  60    subtype "NATIONAL CHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
22:44:50  61    subtype "NCHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
22:44:50  62    subtype "NVARCHAR2" is VARCHAR2 CHARACTER SET NCHAR_CS;
22:44:50  63    subtype "CHARACTER LARGE OBJECT" is CLOB;
22:44:50  64    subtype "CHAR LARGE OBJECT" is CLOB;
22:44:50  65    subtype "NATIONAL CHARACTER LARGE OBJEC" is CLOB CHARACTER SET NCHAR_CS;
22:44:50  66    subtype "NCHAR LARGE OBJECT" is CLOB CHARACTER SET NCHAR_CS;
22:44:50  67    subtype "NCLOB" is CLOB CHARACTER SET NCHAR_CS;
22:44:50  68    subtype "BINARY LARGE OBJECT" is BLOB;
22:44:50  69  
22:44:50  70    subtype pls_integer is binary_integer;
22:44:50  71  
22:44:50  72    type TIME is new DATE_BASE;
22:44:50  73    type TIMESTAMP is new DATE_BASE;
22:44:50  74    type "TIME WITH TIME ZONE" is new DATE_BASE;
22:44:50  75    type "TIMESTAMP WITH TIME ZONE" is new DATE_BASE;
22:44:50  76    type "INTERVAL YEAR TO MONTH" is new DATE_BASE;
22:44:50  77    type "INTERVAL DAY TO SECOND" is new DATE_BASE;
22:44:50  78  
22:44:50  79    SUBTYPE TIME_UNCONSTRAINED IS TIME(9);
22:44:50  80    SUBTYPE TIME_TZ_UNCONSTRAINED IS TIME(9) WITH TIME ZONE;
22:44:50  81    SUBTYPE TIMESTAMP_UNCONSTRAINED IS TIMESTAMP(9);
22:44:50  82    SUBTYPE TIMESTAMP_TZ_UNCONSTRAINED IS TIMESTAMP(9) WITH TIME ZONE;
22:44:50  83    SUBTYPE YMINTERVAL_UNCONSTRAINED IS INTERVAL YEAR(9) TO MONTH;
22:44:50  84    SUBTYPE DSINTERVAL_UNCONSTRAINED IS INTERVAL DAY(9) TO SECOND (9);
22:44:50  85  
22:44:50  86    TYPE UROWID IS NEW CHAR_BASE;
22:44:50  87  
22:44:50  88    type "TIMESTAMP WITH LOCAL TIME ZONE" is new DATE_BASE;
22:44:50  89    subtype timestamp_ltz_unconstrained is timestamp(9) with local time zone;
22:44:50  90  
22:44:50  91    subtype BINARY_FLOAT is NUMBER;
22:44:50  92    subtype BINARY_DOUBLE is NUMBER;
22:44:50  93  
22:44:50  94    -- The following data types are generics, used specially within package
22:44:50  95    -- STANDARD and some other Oracle packages.  They are protected against
22:44:50  96    -- other use; sorry.  True generic types are not yet part of the language.
22:44:50  97  
22:44:50  98    type "<ADT_1>" as object (dummy char(1));
22:44:50  99    type "<RECORD_1>" is record (dummy char(1));
22:44:50 100    type "<TUPLE_1>" as object (dummy char(1));
22:44:50 101    type "<VARRAY_1>" is varray (1) of char(1);
22:44:50 102    type "<V2_TABLE_1>" is table of char(1) index by binary_integer;
22:44:50 103    type "<TABLE_1>" is table of char(1);
22:44:50 104    type "<COLLECTION_1>" is table of char(1);
22:44:50 105    type "<REF_CURSOR_1>" is ref cursor;
22:44:50 106  
22:44:50 107    -- This will actually match against a Q_TABLE
22:44:50 108    type "<TYPED_TABLE>" is table of  "<ADT_1>";
22:44:50 109    subtype "<ADT_WITH_OID>" is "<TYPED_TABLE>";
22:44:50 110  
22:44:50 111    -- The following generic index table data types are used by the PL/SQL
22:44:50 112    -- compiler to materialize an array attribute at the runtime (for more
22:44:50 113    -- details about the array attributes, please see Bulk Binds document).
22:44:50 114    type " SYS$INT_V2TABLE" is table of integer index by binary_integer;
22:44:50 115  
22:44:50 116    -- The following record type and the corresponding generic index table
22:44:50 117    -- data types are used by the PL/SQL compiler to materialize a table
22:44:50 118    -- at the runtime in order to record the exceptions raised during the
22:44:50 119    -- execution of FORALL bulk bind statement (for more details, please
22:44:50 120    -- see bulk binds extensions document in 8.2).
22:44:50 121    type " SYS$BULK_ERROR_RECORD" is
22:44:50 122            record (error_index pls_integer, error_code pls_integer);
22:44:50 123    type " SYS$REC_V2TABLE" is table of " SYS$BULK_ERROR_RECORD"
22:44:50 124                                 index by binary_integer;
22:44:50 125  
22:44:50 126    /* Adding a generic weak ref cursor type */
22:44:50 127    type sys_refcursor is ref cursor;
22:44:50 128  
22:44:50 129    /* the following data type is a generic for all opaque types */
22:44:50 130    type "<OPAQUE_1>" as opaque FIXED(1) USING LIBRARY dummy_lib
22:44:50 131      (static function dummy return number);
22:44:50 132  
22:44:50 133    type "<ASSOC_ARRAY_1>" is table of char(1) index by varchar2(1);
22:44:50 134  
22:44:50 135    /********** Add new types or subtypes here **********/
22:44:50 136  
22:44:50 137    -- Simple scalar types
22:44:50 138  
22:44:50 139    subtype SIMPLE_INTEGER is BINARY_INTEGER NOT NULL;
22:44:50 140    subtype SIMPLE_FLOAT   is BINARY_FLOAT   NOT NULL;
22:44:50 141    subtype SIMPLE_DOUBLE  is BINARY_DOUBLE  NOT NULL;
22:44:50 142  
22:44:50 143    /********** Predefined constants **********/
22:44:50 144  
22:44:50 145    BINARY_FLOAT_NAN constant BINARY_FLOAT;
22:44:50 146    BINARY_FLOAT_INFINITY constant BINARY_FLOAT;
22:44:50 147    BINARY_FLOAT_MAX_NORMAL constant BINARY_FLOAT;
22:44:50 148    BINARY_FLOAT_MIN_NORMAL constant BINARY_FLOAT;
22:44:50 149    BINARY_FLOAT_MAX_SUBNORMAL constant BINARY_FLOAT;
22:44:50 150    BINARY_FLOAT_MIN_SUBNORMAL constant BINARY_FLOAT;
22:44:50 151    BINARY_DOUBLE_NAN constant BINARY_DOUBLE;
22:44:50 152    BINARY_DOUBLE_INFINITY constant BINARY_DOUBLE;
22:44:50 153    BINARY_DOUBLE_MAX_NORMAL constant BINARY_DOUBLE;
22:44:50 154    BINARY_DOUBLE_MIN_NORMAL constant BINARY_DOUBLE;
22:44:50 155    BINARY_DOUBLE_MAX_SUBNORMAL constant BINARY_DOUBLE;
22:44:50 156    BINARY_DOUBLE_MIN_SUBNORMAL constant BINARY_DOUBLE;
22:44:50 157  
22:44:50 158    /********** Add new constants here **********/
22:44:50 159  
22:44:50 160    /********** Predefined exceptions **********/
22:44:50 161  
22:44:50 162    CURSOR_ALREADY_OPEN exception;
22:44:50 163      pragma EXCEPTION_INIT(CURSOR_ALREADY_OPEN, '-6511');
22:44:50 164  
22:44:50 165    DUP_VAL_ON_INDEX exception;
22:44:50 166      pragma EXCEPTION_INIT(DUP_VAL_ON_INDEX, '-0001');
22:44:50 167  
22:44:50 168    TIMEOUT_ON_RESOURCE exception;
22:44:50 169      pragma EXCEPTION_INIT(TIMEOUT_ON_RESOURCE, '-0051');
22:44:50 170  
22:44:50 171    INVALID_CURSOR exception;
22:44:50 172      pragma EXCEPTION_INIT(INVALID_CURSOR, '-1001');
22:44:50 173  
22:44:50 174    NOT_LOGGED_ON exception;
22:44:50 175      pragma EXCEPTION_INIT(NOT_LOGGED_ON, '-1012');
22:44:50 176  
22:44:50 177    LOGIN_DENIED exception;
22:44:50 178      pragma EXCEPTION_INIT(LOGIN_DENIED, '-1017');
22:44:50 179  
22:44:50 180    NO_DATA_FOUND exception;
22:44:50 181      pragma EXCEPTION_INIT(NO_DATA_FOUND, 100);
22:44:50 182  
22:44:50 183    ZERO_DIVIDE exception;
22:44:50 184      pragma EXCEPTION_INIT(ZERO_DIVIDE, '-1476');
22:44:50 185  
22:44:50 186    INVALID_NUMBER exception;
22:44:50 187      pragma EXCEPTION_INIT(INVALID_NUMBER, '-1722');
22:44:50 188  
22:44:50 189    TOO_MANY_ROWS exception;
22:44:50 190      pragma EXCEPTION_INIT(TOO_MANY_ROWS, '-1422');
22:44:50 191  
22:44:50 192    STORAGE_ERROR exception;
22:44:50 193      pragma EXCEPTION_INIT(STORAGE_ERROR, '-6500');
22:44:50 194  
22:44:50 195    PROGRAM_ERROR exception;
22:44:50 196      pragma EXCEPTION_INIT(PROGRAM_ERROR, '-6501');
22:44:50 197  
22:44:50 198    VALUE_ERROR exception;
22:44:50 199      pragma EXCEPTION_INIT(VALUE_ERROR, '-6502');
22:44:50 200  
22:44:50 201    ACCESS_INTO_NULL exception;
22:44:50 202      pragma EXCEPTION_INIT(ACCESS_INTO_NULL, '-6530');
22:44:50 203  
22:44:50 204    COLLECTION_IS_NULL exception;
22:44:50 205      pragma EXCEPTION_INIT(COLLECTION_IS_NULL , '-6531');
22:44:50 206  
22:44:50 207    SUBSCRIPT_OUTSIDE_LIMIT exception;
22:44:50 208      pragma EXCEPTION_INIT(SUBSCRIPT_OUTSIDE_LIMIT,'-6532');
22:44:50 209  
22:44:50 210    SUBSCRIPT_BEYOND_COUNT exception;
22:44:50 211      pragma EXCEPTION_INIT(SUBSCRIPT_BEYOND_COUNT ,'-6533');
22:44:50 212  
22:44:50 213    -- exception for ref cursors
22:44:50 214    ROWTYPE_MISMATCH exception;
22:44:50 215    pragma EXCEPTION_INIT(ROWTYPE_MISMATCH, '-6504');
22:44:50 216  
22:44:50 217    SYS_INVALID_ROWID  EXCEPTION;
22:44:50 218    PRAGMA EXCEPTION_INIT(SYS_INVALID_ROWID, '-1410');
22:44:50 219  
22:44:50 220    -- The object instance i.e. SELF is null
22:44:50 221    SELF_IS_NULL exception;
22:44:50 222      pragma EXCEPTION_INIT(SELF_IS_NULL, '-30625');
22:44:50 223  
22:44:50 224    CASE_NOT_FOUND exception;
22:44:50 225      pragma EXCEPTION_INIT(CASE_NOT_FOUND, '-6592');
22:44:50 226  
22:44:50 227    -- Added for USERENV enhancement, bug 1622213.
22:44:50 228    USERENV_COMMITSCN_ERROR exception;
22:44:50 229      pragma EXCEPTION_INIT(USERENV_COMMITSCN_ERROR, '-1725');
22:44:50 230  
22:44:50 231    -- Parallel and pipelined support
22:44:50 232    NO_DATA_NEEDED exception;
22:44:50 233      pragma EXCEPTION_INIT(NO_DATA_NEEDED, '-6548');
22:44:50 234    -- End of 8.2 parallel and pipelined support
22:44:50 235  
22:44:50 236    /********** Add new exceptions here **********/
22:44:50 237  
22:44:50 238    /********** Function, operators and procedures **********/
22:44:50 239  
22:44:50 240    function "EXISTS" return BOOLEAN;
22:44:50 241      pragma BUILTIN('EXISTS',10,240,240); -- This is special cased in PH2 -- Pj
22:44:50 242  
22:44:50 243    function GREATEST (pattern NUMBER) return NUMBER;
22:44:50 244      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 245    function GREATEST (pattern VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 246          return VARCHAR2 CHARACTER SET pattern%CHARSET;
22:44:50 247      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 248    function GREATEST (pattern DATE) return DATE;
22:44:50 249      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 250  
22:44:50 251    function LEAST (pattern NUMBER) return NUMBER;
22:44:50 252      pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
22:44:50 253    function LEAST (pattern VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 254          return VARCHAR2 CHARACTER SET pattern%CHARSET;
22:44:50 255      pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
22:44:50 256    function LEAST (pattern DATE) return DATE;
22:44:50 257      pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
22:44:50 258  
22:44:50 259    function DECODE (expr NUMBER, pat NUMBER, res NUMBER) return NUMBER;
22:44:50 260      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
22:44:50 261    function DECODE (expr NUMBER,
22:44:50 262                     pat NUMBER,
22:44:50 263                     res VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 264          return VARCHAR2 CHARACTER SET res%CHARSET;
22:44:50 265      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
22:44:50 266    function DECODE (expr NUMBER, pat NUMBER, res DATE) return DATE;
22:44:50 267      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
22:44:50 268  
22:44:50 269    function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 270                     pat VARCHAR2 CHARACTER SET expr%CHARSET,
22:44:50 271                     res NUMBER) return NUMBER;
22:44:50 272      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
22:44:50 273    function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 274                     pat VARCHAR2 CHARACTER SET expr%CHARSET,
22:44:50 275                     res VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 276          return VARCHAR2 CHARACTER SET res%CHARSET;
22:44:50 277      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
22:44:50 278    function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 279                     pat VARCHAR2 CHARACTER SET expr%CHARSET,
22:44:50 280                     res DATE) return DATE;
22:44:50 281      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
22:44:50 282  
22:44:50 283    function DECODE (expr DATE, pat DATE, res NUMBER) return NUMBER;
22:44:50 284      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
22:44:50 285    function DECODE (expr DATE,
22:44:50 286                     pat DATE,
22:44:50 287                     res VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 288          return VARCHAR2 CHARACTER SET res%CHARSET;
22:44:50 289      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
22:44:50 290    function DECODE (expr DATE, pat DATE, res DATE) return DATE;
22:44:50 291      pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
22:44:50 292  
22:44:50 293    function SQLCODE return PLS_INTEGER;
22:44:50 294      pragma BUILTIN('SQLCODE',45, 10, 0); -- PEMS_DB, DB_SQLCODE
22:44:50 295  
22:44:50 296    function SQLERRM return varchar2;
22:44:50 297      pragma FIPSFLAG('SQLERRM', 1452);
22:44:50 298  
22:44:50 299    function SQLERRM (code PLS_INTEGER) return varchar2;
22:44:50 300      pragma BUILTIN('SQLERRM',46, 10, 1); -- PEMS_DB, DB_SQLERRM
22:44:50 301      pragma FIPSFLAG('SQLERRM', 1452);
22:44:50 302  
22:44:50 303    function LEVEL return NUMBER;
22:44:50 304  
22:44:50 305    function ROWNUM return NUMBER;
22:44:50 306  
22:44:50 307    function '='  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
22:44:50 308      pragma BUILTIN('=',2, 3, 1); -- PEMS_INTEGER, PEMDCMEQ
22:44:50 309      pragma FIPSFLAG('=', 1450);
22:44:50 310    function '!=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN; -- also <> and ~=
22:44:50 311      pragma BUILTIN('!=',5, 3, 2); -- PEMS_INTEGER, PEMDCMNE
22:44:50 312      pragma FIPSFLAG('!=', 1450);
22:44:50 313    function '<'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
22:44:50 314      pragma BUILTIN('<',4, 3, 3);  -- PEMS_INTEGER, PEMDCMLT
22:44:50 315      pragma FIPSFLAG('<', 1450);
22:44:50 316    function '<=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
22:44:50 317      pragma BUILTIN('<=',6, 3, 4); -- PEMS_INTEGER, PEMDCMLE
22:44:50 318      pragma FIPSFLAG('<=', 1450);
22:44:50 319    function '>'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
22:44:50 320      pragma BUILTIN('>',1, 3, 5); -- PEMS_INTEGER, PEMDCMGT
22:44:50 321      pragma FIPSFLAG('>', 1450);
22:44:50 322    function '>=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
22:44:50 323      pragma BUILTIN('>=',3, 3, 6); -- PEMS_INTEGER, PEMDMGE
22:44:50 324      pragma FIPSFLAG('>=', 1450);
22:44:50 325  
22:44:50 326    --  Since SQL permits short-circuit evaluation, the 'and' and 'or'
22:44:50 327    --  operations will always be interpreted as 'and then' and 'or else'
22:44:50 328    --  when they occur in conditional statements.
22:44:50 329  
22:44:50 330    function XOR (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
22:44:50 331      pragma BUILTIN('XOR',8, 3, 9); -- PEMS_INTEGER, INT_XOR
22:44:50 332      pragma FIPSFLAG('XOR', 1450);
22:44:50 333  
22:44:50 334    function 'NOT' (RIGHT BOOLEAN) return BOOLEAN;
22:44:50 335      pragma BUILTIN('NOT',9, 3, 10); -- PEMS_INTEGER, INT_NOT
22:44:50 336  
22:44:50 337    function 'IS NULL' (B BOOLEAN) return BOOLEAN;
22:44:50 338      pragma BUILTIN('IS NULL', 0, 3, 0);  -- PEMS_INTEGER, PEMDNUL
22:44:50 339      pragma FIPSFLAG('IS NULL', 1450);
22:44:50 340  
22:44:50 341    function 'IS NOT NULL' (B BOOLEAN) return BOOLEAN;
22:44:50 342      pragma BUILTIN('IS NOT NULL', 0, 3, 50); -- PEMS_INTEGER, PEMDNUL
22:44:50 343      pragma FIPSFLAG('IS NOT NULL', 1450);
22:44:50 344  
22:44:50 345    function NVL (B1 BOOLEAN, B2 BOOLEAN) return BOOLEAN;
22:44:50 346      pragma FIPSFLAG('NVL', 1450);
22:44:50 347  
22:44:50 348    function '='  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 349                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 350      pragma BUILTIN('=',2, 1, 14); -- PEMS_CHAR, PEMDCMEQ (VARCHAR2 SEMANTICS)
22:44:50 351      pragma FIPSFLAG('=', 1454);
22:44:50 352    function '!=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 353                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 354      pragma BUILTIN('!=',5, 1, 15);  -- PEMS_CHAR, PEMDCMNE (VARCHAR2 SEMANTICS)
22:44:50 355      pragma FIPSFLAG('!=', 1454);
22:44:50 356    function '<'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 357                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 358      pragma BUILTIN('<',4, 1, 16); -- PEMS_CHAR, PEMDCMLT (VARCHAR2 SEMANTICS)
22:44:50 359      pragma FIPSFLAG('<', 1454);
22:44:50 360    function '<=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 361                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 362      pragma BUILTIN('<=',6, 1, 17); -- PEMS_CHAR, PEMDCMLE (VARCHAR2 SEMANTICS)
22:44:50 363      pragma FIPSFLAG('<=', 1454);
22:44:50 364    function '>'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 365                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 366      pragma BUILTIN('>',1, 1, 18); -- PEMS_CHAR, PEMDCMGT (VARCHAR2 SEMANTICS)
22:44:50 367      pragma FIPSFLAG('>', 1454);
22:44:50 368    function '>=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 369                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 370      pragma BUILTIN('>=',3, 1, 19); -- PEMS_CHAR, PEMDCMGE (VARCHAR2 SEMANTICS)
22:44:50 371      pragma FIPSFLAG('>=', 1454);
22:44:50 372  
22:44:50 373    function '||' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 374                   RIGHT VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 375          return VARCHAR2 CHARACTER SET LEFT%CHARSET;
22:44:50 376      pragma BUILTIN('||',25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
22:44:50 377      pragma FIPSFLAG('||', 1454);
22:44:50 378  
22:44:50 379    function CONCAT(LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 380                    RIGHT VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 381          return VARCHAR2 CHARACTER SET LEFT%CHARSET;
22:44:50 382      pragma BUILTIN(CONCAT,25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
22:44:50 383      pragma FIPSFLAG(CONCAT, 1454);
22:44:50 384  
22:44:50 385    function LENGTH(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
22:44:50 386      pragma FIPSFLAG('LENGTH', 1452);
22:44:50 387    -- In SUBSTR, LEN defaults to remainder of string
22:44:50 388    -- In substr and instr, a negative value of parameter POS means to
22:44:50 389    -- count from the right end of the string.
22:44:50 390    function SUBSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 391                    POS PLS_INTEGER,
22:44:50 392                    LEN PLS_INTEGER := 2147483647)
22:44:50 393          return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 394      pragma FIPSFLAG('SUBSTR', 1452);
22:44:50 395  
22:44:50 396    -- Find nth occurrence of str1 in str2 starting at pos
22:44:50 397    function INSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 398                   STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
22:44:50 399                   POS PLS_INTEGER := 1,
22:44:50 400                   NTH POSITIVE := 1) return PLS_INTEGER;
22:44:50 401      pragma FIPSFLAG('INSTR', 1452);
22:44:50 402  
22:44:50 403    function UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 404          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:50 405      pragma FIPSFLAG('UPPER', 1452);
22:44:50 406    function LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 407          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:50 408      pragma FIPSFLAG('LOWER', 1452);
22:44:50 409    function ASCII(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 410          return INTEGER; -- should be ASCII.CHRANGE
22:44:50 411      pragma FIPSFLAG('ASCII', 1452);
22:44:50 412    function ASCIISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 413          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:50 414      pragma FIPSFLAG('ASCIISTR', 1452);
22:44:50 415    function UNISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 416          return NVARCHAR2;
22:44:50 417      pragma FIPSFLAG('UNISTR', 1452);
22:44:50 418    function CHR(n INTEGER) return varchar2;  -- N should be ASCII.CHRANGE
22:44:50 419      pragma FIPSFLAG('CHR', 1452);
22:44:50 420    function " SYS$STANDARD_CHR"(n INTEGER,csn VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 421          return VARCHAR2 CHARACTER SET csn%CHARSET;
22:44:50 422      pragma FIPSFLAG(' SYS$STANDARD_CHR', 1452);
22:44:50 423    function INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 424          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:50 425      pragma FIPSFLAG('INITCAP', 1452);
22:44:50 426    function SOUNDEX(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 427          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:50 428      pragma FIPSFLAG('SOUNDEX', 1452);
22:44:50 429  
22:44:50 430    function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 431                  LEN pls_integer,
22:44:50 432                  PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
22:44:50 433          return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 434      pragma FIPSFLAG('LPAD', 1452);
22:44:50 435    function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 436                  LEN pls_integer)
22:44:50 437          return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 438    pragma FIPSFLAG('LPAD', 1452);
22:44:50 439  
22:44:50 440    function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 441                  LEN pls_integer,
22:44:50 442                  PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
22:44:50 443          return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 444      pragma FIPSFLAG('RPAD', 1452);
22:44:50 445    function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 446                  LEN pls_integer)
22:44:50 447          return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 448      pragma FIPSFLAG('RPAD', 1452);
22:44:50 449  
22:44:50 450    function TRANSLATE(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 451                       SRC VARCHAR2 CHARACTER SET STR1%CHARSET,
22:44:50 452                       DEST VARCHAR2 CHARACTER SET STR1%CHARSET)
22:44:50 453          return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 454      pragma FIPSFLAG('TRANSLATE', 1452);
22:44:50 455  
22:44:50 456    function REPLACE(SRCSTR VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 457                     OLDSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET,
22:44:50 458                     NEWSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET := NULL)
22:44:50 459          return VARCHAR2 CHARACTER SET SRCSTR%CHARSET;
22:44:50 460      pragma FIPSFLAG('REPLACE', 1452);
22:44:50 461  
22:44:50 462    function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
22:44:50 463                   TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
22:44:50 464          return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 465      pragma FIPSFLAG('LTRIM', 1452);
22:44:50 466    function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
22:44:50 467          return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 468      pragma FIPSFLAG('LTRIM', 1452);
22:44:50 469  
22:44:50 470    function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
22:44:50 471                   TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
22:44:50 472          return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 473      pragma FIPSFLAG('RTRIM', 1452);
22:44:50 474    function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
22:44:50 475          return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 476      pragma FIPSFLAG('RTRIM', 1452);
22:44:50 477  
22:44:50 478    function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 479                     pat VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 480          return BOOLEAN;
22:44:50 481    function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 482                         pat VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 483          return BOOLEAN;
22:44:50 484    function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 485                     pat VARCHAR2 CHARACTER SET str%CHARSET,
22:44:50 486                     esc VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 487          return BOOLEAN;
22:44:50 488    function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 489                         pat VARCHAR2 CHARACTER SET str%CHARSET,
22:44:50 490                         esc VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 491          return BOOLEAN;
22:44:50 492    function 'IS NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 493      pragma BUILTIN('IS NULL', 0, 1, 20);  -- PEMS_CHAR, PEMDNUL
22:44:50 494    function 'IS NOT NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 495      pragma BUILTIN('IS NOT NULL', 0, 1, 50); -- PEMS_CHAR, PEMDNUL
22:44:50 496  
22:44:50 497    function NVL(s1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 498                 s2 VARCHAR2 CHARACTER SET s1%CHARSET)
22:44:50 499          return VARCHAR2 CHARACTER SET s1%CHARSET;
22:44:50 500      pragma FIPSFLAG('NVL', 1452);
22:44:50 501  
22:44:50 502  
22:44:50 503    function '='  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 504      pragma BUILTIN('=',2, 2, 1); -- PEMS_NUMBER, PEMDCMEQ
22:44:50 505    function '!=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;  -- also <> and ~=
22:44:50 506      pragma BUILTIN('!=',5, 2, 2); -- PEMS_NUMBER, PEMDCMNE
22:44:50 507      pragma FIPSFLAG('!=', 1452);
22:44:50 508    function '<'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 509      pragma BUILTIN('<',4, 2, 3); -- PEMS_NUMBER, PEMDCMLT
22:44:50 510    function '<=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 511      pragma BUILTIN('<=',6, 2, 4); -- PEMS_NUMBER, PEMDCMLE
22:44:50 512    function '>'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 513      pragma BUILTIN('>',1, 2, 5); -- PEMS_NUMBER, PEMDCMGT
22:44:50 514    function '>=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 515      pragma BUILTIN('>=',3, 2, 6); -- PEMS_NUMBER, PEMDCMGE
22:44:50 516  
22:44:50 517    function 'IS NULL' (n NUMBER) return BOOLEAN;
22:44:50 518      pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
22:44:50 519    function 'IS NOT NULL' (n NUMBER) return BOOLEAN;
22:44:50 520      pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_NUMBER, PEMDNUL
22:44:50 521  
22:44:50 522    function NVL(n1 NUMBER, n2 NUMBER) return NUMBER;
22:44:50 523      pragma FIPSFLAG('NVL', 1452);
22:44:50 524  
22:44:50 525    function '+' (RIGHT NUMBER) return NUMBER;
22:44:50 526      pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
22:44:50 527    function '-' (RIGHT NUMBER) return NUMBER;
22:44:50 528      pragma BUILTIN('-',15, 2, 7); -- PEMS_NUMBER, NUM_NEG
22:44:50 529    function ABS(n NUMBER) return NUMBER;
22:44:50 530      pragma FIPSFLAG('ABS', 1452);
22:44:50 531  
22:44:50 532    function '+' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
22:44:50 533      pragma BUILTIN('+',14, 2, 8); -- PEMS_NUMBER, NUM_ADD
22:44:50 534    function '-' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
22:44:50 535      pragma BUILTIN('-',15, 2, 9); -- PEMS_NUMBER, NUM_SUB
22:44:50 536    function '*' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
22:44:50 537      pragma BUILTIN('*',17, 2, 10); -- PEMS_NUMBER, NUM_MUL
22:44:50 538    function '/' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
22:44:50 539      pragma BUILTIN('/',18, 2, 11); -- PEMS_NUMBER, NUM_DIV
22:44:50 540  
22:44:50 541    function 'REM' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
22:44:50 542      pragma FIPSFLAG('REM', 1452);
22:44:50 543    function 'MOD'(n1 NUMBER, n2 NUMBER) return NUMBER;
22:44:50 544      pragma FIPSFLAG('MOD', 1452);
22:44:50 545  
22:44:50 546    function '**' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
22:44:50 547      pragma FIPSFLAG('**', 1452);
22:44:50 548  
22:44:50 549    function FLOOR(n NUMBER) return NUMBER;
22:44:50 550      pragma FIPSFLAG('FLOOR', 1452);
22:44:50 551    function CEIL(n NUMBER) return NUMBER;
22:44:50 552      pragma FIPSFLAG('CEIL', 1452);
22:44:50 553    function SQRT(n NUMBER) return NUMBER;
22:44:50 554      pragma FIPSFLAG('SQRT', 1452);
22:44:50 555    function SIGN(n NUMBER) return SIGNTYPE;
22:44:50 556    pragma FIPSFLAG('SIGN', 1452);
22:44:50 557  
22:44:50 558    function COS(N NUMBER) return NUMBER;
22:44:50 559      pragma FIPSFLAG('COS', 1452);
22:44:50 560    function SIN(N NUMBER) return NUMBER;
22:44:50 561      pragma FIPSFLAG('SIN', 1452);
22:44:50 562    function TAN(N NUMBER) return NUMBER;
22:44:50 563      pragma FIPSFLAG('TAN', 1452);
22:44:50 564    function COSH(N NUMBER) return NUMBER;
22:44:50 565      pragma FIPSFLAG('COSH', 1452);
22:44:50 566    function SINH(N NUMBER) return NUMBER;
22:44:50 567      pragma FIPSFLAG('SINH', 1452);
22:44:50 568    function TANH(N NUMBER) return NUMBER;
22:44:50 569      pragma FIPSFLAG('TANH', 1452);
22:44:50 570  
22:44:50 571    function EXP(N NUMBER) return NUMBER;
22:44:50 572    function LN(N NUMBER) return NUMBER;
22:44:50 573  
22:44:50 574    function BITAND (LEFT pls_integer, RIGHT pls_integer)
22:44:50 575          return pls_integer;
22:44:50 576    function BITAND (LEFT number, RIGHT number)
22:44:50 577          return number;
22:44:50 578    function LOG (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
22:44:50 579  
22:44:50 580    function TRUNC (n NUMBER, places pls_integer := 0) return NUMBER;
22:44:50 581      pragma FIPSFLAG('TRUNC', 1452);
22:44:50 582  
22:44:50 583    function ROUND (LEFT NUMBER, RIGHT pls_integer := 0) return NUMBER;
22:44:50 584      pragma FIPSFLAG('ROUND', 1452);
22:44:50 585  
22:44:50 586    function ROUND_TIES_TO_EVEN (N NUMBER, PLACES PLS_INTEGER := 0)
22:44:50 587          return NUMBER;
22:44:50 588  
22:44:50 589    function POWER (n NUMBER, e NUMBER) return NUMBER;
22:44:50 590      pragma FIPSFLAG('POWER', 1452);
22:44:50 591  
22:44:50 592    function '='  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 593      pragma BUILTIN('=',2, 12, 1); -- PEMS_DATE, PEMDCMEQ
22:44:50 594      pragma FIPSFLAG('=', 1450);
22:44:50 595    function '!=' (LEFT DATE, RIGHT DATE) return BOOLEAN;  -- also <> and ~=
22:44:50 596      pragma BUILTIN('!=',5, 12, 2); -- PEMS_DATE, PEMDCMNE
22:44:50 597      pragma FIPSFLAG('!=', 1450);
22:44:50 598    function '<'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 599      pragma BUILTIN('<',4, 12, 3); -- PEMS_DATE, PEMDCMLT
22:44:50 600      pragma FIPSFLAG('<', 1450);
22:44:50 601    function '<=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 602      pragma BUILTIN('<=',6, 12, 4); -- PEMS_DATE, PEMDCMLE
22:44:50 603      pragma FIPSFLAG('<=', 1450);
22:44:50 604    function '>'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 605      pragma BUILTIN('>',1, 12, 5);  -- PEMS_DATE, PEMDCMGT
22:44:50 606      pragma FIPSFLAG('>', 1450);
22:44:50 607    function '>=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 608      pragma BUILTIN('>=',3, 12, 6);  -- PEMS_DATE, PEMDCMGE
22:44:50 609      pragma FIPSFLAG('>=', 1450);
22:44:50 610  
22:44:50 611    function '+' (LEFT DATE, RIGHT NUMBER) return DATE;
22:44:50 612      pragma BUILTIN('+',14, 12, 7); -- PEMS_DATE, DATE_ADD1
22:44:50 613      pragma FIPSFLAG('+', 1450);
22:44:50 614    function '+' (LEFT NUMBER, RIGHT DATE) return DATE;
22:44:50 615      pragma BUILTIN('+',14, 12, 8); -- PEMS_DATE, DATE_ADD2
22:44:50 616      pragma FIPSFLAG('+', 1450);
22:44:50 617    function '-' (LEFT DATE, RIGHT NUMBER) return DATE;
22:44:50 618      pragma BUILTIN('-',15, 12, 9); -- PEMS_DATE, DATE_SUB1
22:44:50 619      pragma FIPSFLAG('-', 1450);
22:44:50 620    function '-' (LEFT NUMBER, RIGHT DATE) return DATE;
22:44:50 621      pragma BUILTIN('-',15, 12, 10); -- PEMS_DATE, DATE_SUB2
22:44:50 622      pragma FIPSFLAG('-', 1450);
22:44:50 623    function '-' (LEFT DATE, RIGHT DATE) return NUMBER;
22:44:50 624      pragma BUILTIN('-',15, 12, 11); -- PEMS_DATE, DATE_SUB3
22:44:50 625      pragma FIPSFLAG('-', 1450);
22:44:50 626  
22:44:50 627    function LAST_DAY(RIGHT DATE) return DATE;
22:44:50 628      pragma BUILTIN('LAST_DAY',38, 12, 12); -- PEMS_DATE, DATE_LAST_DAY
22:44:50 629      pragma FIPSFLAG('LAST_DAY', 1450);
22:44:50 630    function ADD_MONTHS(LEFT DATE, RIGHT NUMBER) return DATE;
22:44:50 631      pragma BUILTIN('ADD_MONTHS',39, 12, 13); -- PEMS_DATE, DATE_ADD_MONTHS1
22:44:50 632      pragma FIPSFLAG('ADD_MONTHS', 1450);
22:44:50 633    function ADD_MONTHS(LEFT NUMBER, RIGHT DATE) return DATE;
22:44:50 634      pragma BUILTIN('ADD_MONTHS',39, 12, 14); -- PEMS_DATE, DATE_ADD_MONTHS2
22:44:50 635      pragma FIPSFLAG('ADD_MONTHS', 1450);
22:44:50 636  
22:44:50 637    function MONTHS_BETWEEN(LEFT DATE, RIGHT DATE) return NUMBER;
22:44:50 638      pragma BUILTIN('MONTHS_BETWEEN',42, 12, 15); -- PEMS_DATE, DATE_MONTHS_BET
22:44:50 639      pragma FIPSFLAG('MONTHS_BETWEEN', 1450);
22:44:50 640    function NEXT_DAY(LEFT DATE, RIGHT VARCHAR2) return DATE;
22:44:50 641      pragma BUILTIN('NEXT_DAY',43, 12, 16); -- PEMS_DATE, DATE_NEXT_DAY
22:44:50 642      pragma FIPSFLAG('NEXT_DAY', 1450);
22:44:50 643    function ROUND(RIGHT DATE) return DATE;
22:44:50 644      pragma BUILTIN('ROUND',24, 12, 17); -- PEMS_DATE, DATE_ROUND
22:44:50 645      pragma FIPSFLAG('ROUND', 1450);
22:44:50 646    function NEW_TIME(RIGHT DATE, MIDDLE VARCHAR2, LEFT VARCHAR2) return DATE;
22:44:50 647      pragma FIPSFLAG('NEW_TIME', 1450);
22:44:50 648  
22:44:50 649    function 'IS NULL' (d DATE) return BOOLEAN;
22:44:50 650      pragma BUILTIN('IS NULL', 0, 12, 0);  -- PEMS_DATE, PEMDNUL
22:44:50 651      pragma FIPSFLAG('IS NULL', 1450);
22:44:50 652    function 'IS NOT NULL' (d DATE) return BOOLEAN;
22:44:50 653      pragma BUILTIN('IS NOT NULL', 0, 12, 50);  -- PEMS_DATE, PEMDNUL
22:44:50 654      pragma FIPSFLAG('IS NOT NULL', 1450);
22:44:50 655    function NVL (d1 DATE, d2 DATE) return DATE;
22:44:50 656      pragma FIPSFLAG('NVL', 1450);
22:44:50 657  
22:44:50 658    function TRUNC(LEFT DATE) return DATE;
22:44:50 659      pragma BUILTIN('TRUNC',51, 12, 20); -- PEMS_DATE, DATE_TRUNC1
22:44:50 660      pragma FIPSFLAG('TRUNC', 1450);
22:44:50 661    function TRUNC(LEFT DATE, RIGHT VARCHAR2) return DATE;
22:44:50 662      pragma BUILTIN('TRUNC',51, 12, 21); -- PEMS_DATE, DATE_TRUNC2
22:44:50 663      pragma FIPSFLAG('TRUNC', 1450);
22:44:50 664    function ROUND(LEFT DATE, RIGHT VARCHAR2) return DATE;
22:44:50 665      pragma BUILTIN('ROUND',24, 12, 22); -- PEMS_DATE, DATE_ROUND2
22:44:50 666      pragma FIPSFLAG('ROUND', 1450);
22:44:50 667  
22:44:50 668    function TO_DATE    (RIGHT VARCHAR2 character set any_cs)  return DATE;
22:44:50 669      pragma BUILTIN('TO_DATE',40, 1, 10); -- PEMS_CHAR, CHR_CNV_DAT
22:44:50 670      pragma FIPSFLAG('TO_DATE', 1450);
22:44:50 671  
22:44:50 672    function TO_DATE (LEFT VARCHAR2 character set any_cs,
22:44:50 673         RIGHT VARCHAR2 character set LEFT%charset) return DATE;
22:44:50 674      pragma BUILTIN('TO_DATE',40, 1, 8); -- PEMS_CHAR, CHR_CNV_DATE
22:44:50 675      pragma FIPSFLAG('TO_DATE', 1450);
22:44:50 676  
22:44:50 677    function TO_DATE (LEFT NUMBER, RIGHT VARCHAR2) return DATE;
22:44:50 678      pragma FIPSFLAG('TO_DATE', 1450);
22:44:50 679  
22:44:50 680    function TO_DATE(left varchar2 character set any_cs,
22:44:50 681                     format varchar2 character set LEFT%charset,
22:44:50 682                     parms varchar2 character set LEFT%charset) return date;
22:44:50 683  
22:44:50 684    function TO_CHAR (RIGHT VARCHAR2) return VARCHAR2;
22:44:50 685      pragma BUILTIN('TO_CHAR',14, 0, 2);
22:44:50 686  
22:44:50 687    function TO_CHAR (LEFT DATE, RIGHT VARCHAR2) return VARCHAR2;
22:44:50 688      pragma BUILTIN('TO_CHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
22:44:50 689      pragma FIPSFLAG('TO_CHAR', 1450);
22:44:50 690  
22:44:50 691    function TO_CHAR (LEFT NUMBER, RIGHT VARCHAR2) return VARCHAR2;
22:44:50 692      pragma BUILTIN('TO_CHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR
22:44:50 693  
22:44:50 694    function TO_NUMBER (RIGHT NUMBER) RETURN NUMBER;
22:44:50 695      pragma BUILTIN('TO_NUMBER',14, 0, 1); -- PEMS_QUICK
22:44:50 696  
22:44:50 697    function TO_NUMBER (RIGHT VARCHAR2 character set any_cs)    return NUMBER;
22:44:50 698      pragma BUILTIN('TO_NUMBER',48, 1, 9); -- PEMS_CHAR, CHR_CNV_NUM
22:44:50 699  
22:44:50 700    function TO_NUMBER(left varchar2 character set any_cs,
22:44:50 701          format varchar2 character set LEFT%charset)
22:44:50 702      return number;
22:44:50 703    function TO_NUMBER(left varchar2 character set any_cs,
22:44:50 704                       format varchar2 character set LEFT%charset,
22:44:50 705                       parms varchar2 character set LEFT%charset)
22:44:50 706      return number;
22:44:50 707  
22:44:50 708    -- Define SQL predicates.  These don't gen code, so no body is needed.
22:44:50 709  
22:44:50 710    -- PRIOR is WEIRD - For now, it will be treated as a function call.
22:44:50 711    -- Does the function only take a column name?  how about its use in
22:44:50 712    -- a predicate?
22:44:50 713    function 'PRIOR'(colname VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 714            return VARCHAR2 CHARACTER SET colname%CHARSET;
22:44:50 715        pragma FIPSFLAG('PRIOR', 1452);
22:44:50 716    function 'PRIOR'(colname NUMBER) return NUMBER;
22:44:50 717        pragma FIPSFLAG('PRIOR', 1452);
22:44:50 718    function 'PRIOR'(colname DATE) return DATE;
22:44:50 719        pragma FIPSFLAG('PRIOR', 1450);
22:44:50 720  
22:44:50 721    -- Outer Join has same problem as PRIOR
22:44:50 722    function '(+)'(colname VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 723            return VARCHAR2 CHARACTER SET colname%CHARSET;
22:44:50 724    function '(+)'(colname NUMBER) return NUMBER;
22:44:50 725    function '(+)'(colname DATE) return DATE;
22:44:50 726        pragma FIPSFLAG('(+)', 1450);
22:44:50 727  
22:44:50 728    function '=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 729                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 730            return BOOLEAN;
22:44:50 731    function '=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 732        pragma FIPSFLAG('=ANY', 1450);
22:44:50 733    function '=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 734  
22:44:50 735    function '!=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 736                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 737            return BOOLEAN;
22:44:50 738    function '!=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 739        pragma FIPSFLAG('!=ANY', 1450);
22:44:50 740    function '!=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 741  
22:44:50 742    function '<ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 743                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 744            return BOOLEAN;
22:44:50 745    function '<ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 746        pragma FIPSFLAG('<ANY', 1450);
22:44:50 747    function '<ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 748  
22:44:50 749    function '<=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 750                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 751            return BOOLEAN;
22:44:50 752    function '<=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 753        pragma FIPSFLAG('<=ANY', 1450);
22:44:50 754    function '<=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 755  
22:44:50 756    function '>ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 757                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 758            return BOOLEAN;
22:44:50 759    function '>ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 760        pragma FIPSFLAG('>ANY', 1450);
22:44:50 761    function '>ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 762  
22:44:50 763    function '>=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 764                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 765            return BOOLEAN;
22:44:50 766    function '>=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 767        pragma FIPSFLAG('>=ANY', 1450);
22:44:50 768    function '>=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 769  
22:44:50 770    function '=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 771                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 772            return BOOLEAN;
22:44:50 773    function '=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 774        pragma FIPSFLAG('=ALL', 1450);
22:44:50 775    function '=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 776  
22:44:50 777    function '!=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 778                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 779            return BOOLEAN;
22:44:50 780    function '!=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 781        pragma FIPSFLAG('!=ALL', 1450);
22:44:50 782    function '!=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 783  
22:44:50 784    function '<ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 785                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 786            return BOOLEAN;
22:44:50 787    function '<ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 788        pragma FIPSFLAG('<ALL', 1450);
22:44:50 789    function '<ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 790  
22:44:50 791    function '<=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 792                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 793            return BOOLEAN;
22:44:50 794    function '<=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 795        pragma FIPSFLAG('<=ALL', 1450);
22:44:50 796    function '<=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 797  
22:44:50 798    function '>ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 799                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 800            return BOOLEAN;
22:44:50 801    function '>ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 802        pragma FIPSFLAG('>ALL', 1450);
22:44:50 803    function '>ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 804  
22:44:50 805    function '>=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 806                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 807            return BOOLEAN;
22:44:50 808    function '>=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 809        pragma FIPSFLAG('>=ALL', 1450);
22:44:50 810    function '>=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 811  
22:44:50 812    function '=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 813                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 814            return BOOLEAN;
22:44:50 815    function '=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 816        pragma FIPSFLAG('=SOME', 1450);
22:44:50 817    function '=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 818  
22:44:50 819    function '!=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 820                        RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 821            return BOOLEAN;
22:44:50 822    function '!=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 823        pragma FIPSFLAG('!=SOME', 1450);
22:44:50 824    function '!=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 825  
22:44:50 826    function '<SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 827                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 828            return BOOLEAN;
22:44:50 829    function '<SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 830        pragma FIPSFLAG('<SOME', 1450);
22:44:50 831    function '<SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 832  
22:44:50 833    function '<=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 834                        RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 835            return BOOLEAN;
22:44:50 836    function '<=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 837        pragma FIPSFLAG('<=SOME', 1450);
22:44:50 838    function '<=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 839  
22:44:50 840    function '>SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 841                       RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 842            return BOOLEAN;
22:44:50 843    function '>SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 844        pragma FIPSFLAG('>SOME', 1450);
22:44:50 845    function '>SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 846  
22:44:50 847    function '>=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 848                        RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 849            return BOOLEAN;
22:44:50 850    function '>=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
22:44:50 851        pragma FIPSFLAG('>=SOME', 1450);
22:44:50 852    function '>=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
22:44:50 853  
22:44:50 854    -- SQL Transaction routines
22:44:50 855    procedure SET_TRANSACTION_USE(vc VARCHAR2);
22:44:50 856    procedure COMMIT;
22:44:50 857    procedure COMMIT_CM(vc VARCHAR2);
22:44:50 858    procedure ROLLBACK_NR;
22:44:50 859    procedure ROLLBACK_SV(Save_Point CHAR);
22:44:50 860    procedure SAVEPOINT(Save_Point CHAR);
22:44:50 861  
22:44:50 862    function SYSDATE return DATE;
22:44:50 863      pragma FIPSFLAG('SYSDATE', 1452);
22:44:50 864  
22:44:50 865    function UID return PLS_INTEGER;
22:44:50 866      pragma FIPSFLAG('UID', 1452);
22:44:50 867  
22:44:50 868    function USER return VARCHAR2;
22:44:50 869  
22:44:50 870    function USERENV (envstr VARCHAR2) return VARCHAR2;
22:44:50 871      pragma FIPSFLAG('USERENV', 1452);
22:44:50 872  
22:44:50 873    -- ROWID: this dreadful identifier is supposed to represent a datatype
22:44:50 874    -- outside of SQL and and a pseudo-column (function, to us) when inside
22:44:50 875    -- a sql statement.  ADA data model doesn't allow for any
22:44:50 876    -- function X return X;
22:44:50 877    -- so we must special case this.  Yuk.  There's special-case code in ph2nre
22:44:50 878    -- which maps "rowid" to "rowid " if we're inside a SQL stmt.
22:44:50 879    function "ROWID " return ROWID;
22:44:50 880      pragma builtin('ROWID ', 1, 209, 240);  -- this had better never be called.
22:44:50 881  
22:44:50 882    function NULLFN (str VARCHAR2) return RAW;
22:44:50 883      pragma builtin('NULLFN', 1, 0, 1);
22:44:50 884  
22:44:50 885    function HEXTORAW (c VARCHAR2) return RAW;
22:44:50 886       pragma builtin('HEXTORAW', 1, 23, 1);
22:44:50 887  
22:44:50 888    function RAWTOHEX (r RAW) return VARCHAR2;
22:44:50 889       pragma builtin('RAWTOHEX', 1, 23, 2);
22:44:50 890  
22:44:50 891    function CHARTOROWID (str VARCHAR2) return ROWID;
22:44:50 892      pragma builtin('CHARTOROWID', 1, 0, 1);
22:44:50 893  
22:44:50 894    function ROWIDTOCHAR (str ROWID) return VARCHAR2;
22:44:50 895      pragma builtin('ROWIDTOCHAR', 1, 0, 1);
22:44:50 896  
22:44:50 897  
22:44:50 898    -- Trusted*Oracle additions
22:44:50 899    Function ROWLABEL return MLSLABEL;                     -- pseudo column
22:44:50 900  
22:44:50 901    Function TO_CHAR(label MLSLABEL, format VARCHAR2) return VARCHAR2;
22:44:50 902      pragma BUILTIN('TO_CHAR',90, 4, 19); -- PEMS_DATE, MLS_CNV_CHR1
22:44:50 903      pragma FIPSFLAG('TO_CHAR', 1450);
22:44:50 904  
22:44:50 905    Function TO_LABEL(label VARCHAR2, format VARCHAR2 ) return  MLSLABEL;
22:44:50 906      pragma BUILTIN('TO_LABEL',90, 4, 8); -- PEMS_CHAR, CHR_CNV_MLS
22:44:50 907      pragma FIPSFLAG('TO_LABEL', 1450);
22:44:50 908  
22:44:50 909    Function TO_LABEL(label VARCHAR2 ) return  MLSLABEL;
22:44:50 910      pragma BUILTIN('TO_LABEL',90, 4, 2); -- PEMS_CHAR, CHR_CNV_MLS
22:44:50 911      pragma FIPSFLAG('TO_LABEL', 1450);
22:44:50 912  
22:44:50 913    -- vararg routines - icds in stdbdy
22:44:50 914    Function LEAST_UB    (pattern MLSLABEL) return MLSLABEL;
22:44:50 915      pragma BUILTIN('LEAST_UB',90, 4, 3); -- PEMS_CHAR, CHR_CNV_MLS
22:44:50 916    Function GREATEST_LB (pattern MLSLABEL) return MLSLABEL;
22:44:50 917      pragma BUILTIN('GREATEST_LB',90, 4, 4); -- PEMS_CHAR, CHR_CNV_MLS
22:44:50 918  
22:44:50 919    Function '>=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
22:44:50 920    Function '>'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
22:44:50 921    Function '<=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
22:44:50 922    Function '<'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
22:44:50 923    Function '='  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
22:44:50 924    Function '!=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
22:44:50 925    function 'IS NULL' (label MLSLABEL) return BOOLEAN;
22:44:50 926      pragma BUILTIN('IS NULL', 0, 1, 20); -- same "cod" as IS NULL(varchar2)
22:44:50 927    function 'IS NOT NULL' (label MLSLABEL) return BOOLEAN;
22:44:50 928      pragma BUILTIN('IS NOT NULL', 0, 1, 50);
22:44:50 929  
22:44:50 930    function NVL(label1 MLSLABEL, label2 MLSLABEL) return MLSLABEL;
22:44:50 931      pragma FIPSFLAG('NVL', 1452);
22:44:50 932  
22:44:50 933    -- group functions
22:44:50 934    Function LUB (label MLSLABEL) return MLSLABEL;
22:44:50 935    Function GLB (label MLSLABEL) return MLSLABEL;
22:44:50 936  
22:44:50 937    -- end of Trusted*Oracle additions
22:44:50 938  
22:44:50 939  
22:44:50 940    -- beginning of NLS routines
22:44:50 941  
22:44:50 942    function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS) return RAW;
22:44:50 943      pragma FIPSFLAG('NLSSORT', 1452);
22:44:50 944    function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS, c2 VARCHAR2) return RAW;
22:44:50 945      pragma FIPSFLAG('NLSSORT', 1452);
22:44:50 946    function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 947                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
22:44:50 948          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:50 949      pragma FIPSFLAG('NLS_UPPER', 1452);
22:44:50 950    function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 951          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:50 952      pragma FIPSFLAG('NLS_UPPER', 1452);
22:44:50 953    function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 954                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
22:44:50 955          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:50 956      pragma FIPSFLAG('NLS_LOWER', 1452);
22:44:50 957    function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 958          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:50 959      pragma FIPSFLAG('NLS_LOWER', 1452);
22:44:50 960    function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 961                         parms VARCHAR2 CHARACTER SET ch%CHARSET)
22:44:50 962          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:50 963      pragma FIPSFLAG('NLS_INITCAP', 1452);
22:44:50 964    function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 965          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:50 966      pragma FIPSFLAG('NLS_INITCAP', 1452);
22:44:50 967  
22:44:50 968    function LENGTHB(ch VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
22:44:50 969      pragma FIPSFLAG('LENGTHB', 1452);
22:44:50 970    function SUBSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 971                     POS PLS_INTEGER,
22:44:50 972                     LEN PLS_INTEGER := 2147483647)
22:44:50 973          return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 974      pragma FIPSFLAG('SUBSTRB', 1452);
22:44:50 975    function INSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 976                   STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
22:44:50 977                   POS PLS_INTEGER := 1,
22:44:50 978                   NTH POSITIVE := 1) return PLS_INTEGER;
22:44:50 979      pragma FIPSFLAG('INSTRB', 1452);
22:44:50 980  
22:44:50 981    function TO_SINGLE_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 982          return VARCHAR2 CHARACTER SET c%CHARSET;
22:44:50 983      pragma FIPSFLAG('TO_SINGLE_BYTE', 1452);
22:44:50 984    function TO_MULTI_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 985          return VARCHAR2 CHARACTER SET c%CHARSET;
22:44:50 986      pragma FIPSFLAG('TO_MULTI_BYTE', 1452);
22:44:50 987  
22:44:50 988    -- Next two added for NLS 6/3/92 JEM.
22:44:50 989    function TO_CHAR(left date, format varchar2, parms varchar2) return varchar2;
22:44:50 990    function TO_CHAR(left number, format varchar2, parms varchar2)
22:44:50 991      return varchar2;
22:44:50 992    function NLS_CHARSET_NAME(csetid PLS_INTEGER) return VARCHAR2;
22:44:50 993    function NLS_CHARSET_ID(csetname VARCHAR2) return PLS_INTEGER;
22:44:50 994    function NLS_CHARSET_DECL_LEN(bytecnt NUMBER, csetid NUMBER)
22:44:50 995      return PLS_INTEGER;
22:44:50 996  
22:44:50 997    -- end of NLS routines
22:44:50 998  
22:44:50 999    function CONVERT(src VARCHAR2 character set any_cs,
22:44:50 1000                     destcset VARCHAR2)
22:44:50 1001             return VARCHAR2 character set src%charset;
22:44:50 1002    function CONVERT(src VARCHAR2 character set any_cs,
22:44:50 1003                     destcset VARCHAR2,
22:44:50 1004                     srccset VARCHAR2)
22:44:50 1005            return VARCHAR2 character set src%charset;
22:44:50 1006  
22:44:50 1007    function " SYS$STANDARD_TRANSLATE" (src VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 1008                                        csn VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 1009            return VARCHAR2 CHARACTER SET csn%CHARSET;
22:44:50 1010       pragma FIPSFLAG(' SYS$STANDARD_TRANSLATE',1452);
22:44:50 1011  
22:44:50 1012    function VSIZE (e number ) return NUMBER;
22:44:50 1013        pragma builtin('VSIZE', 1, 0, 1);
22:44:50 1014    function VSIZE (e DATE) return NUMBER;
22:44:50 1015        pragma builtin('VSIZE', 1, 0, 1);
22:44:50 1016    function VSIZE (e VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
22:44:50 1017        pragma builtin('VSIZE', 1, 0, 1);
22:44:50 1018  
22:44:50 1019  
22:44:50 1020    -- dump( expr [,display_format[,start_pos[,length]]]) return VARCHAR2
22:44:50 1021    function DUMP(e varchar2 character set any_cs,
22:44:50 1022                  df pls_integer := null,sp pls_integer := null,
22:44:50 1023                  len pls_integer := null) return VARCHAR2;
22:44:50 1024        pragma builtin('DUMP', 1, 0, 1);
22:44:50 1025  
22:44:50 1026    function DUMP(e number,df pls_integer := null,sp pls_integer := null,
22:44:50 1027                    len pls_integer := null) return VARCHAR2;
22:44:50 1028        pragma builtin('DUMP', 1, 0, 1);
22:44:50 1029  
22:44:50 1030    function DUMP(e date,df pls_integer := null,sp pls_integer := null,
22:44:50 1031                    len pls_integer := null) return VARCHAR2;
22:44:50 1032        pragma builtin('DUMP', 1, 0, 1);
22:44:50 1033  
22:44:50 1034    --
22:44:50 1035    -- ACOS, ASIN, ATAN, ATAN2
22:44:50 1036    --   Inverse Trigonometric functions
22:44:50 1037    --   These functions return NULL if any of the inputs are NULL
22:44:50 1038    --
22:44:50 1039    function ACOS(N NUMBER) return NUMBER;
22:44:50 1040      pragma FIPSFLAG('ACOS', 1452);
22:44:50 1041  
22:44:50 1042    function ASIN(N NUMBER) return NUMBER;
22:44:50 1043      pragma FIPSFLAG('ASIN', 1452);
22:44:50 1044  
22:44:50 1045    function ATAN(N NUMBER) return NUMBER;
22:44:50 1046      pragma FIPSFLAG('ATAN', 1452);
22:44:50 1047  
22:44:50 1048    function ATAN2(x NUMBER, y NUMBER) return NUMBER;
22:44:50 1049    pragma FIPSFLAG('ATAN2', 1452);
22:44:50 1050  
22:44:50 1051    --#### This is the end of 7.3 Standard
22:44:50 1052  
22:44:50 1053    -- LOB IS NULL
22:44:50 1054    function 'IS NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1055      pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
22:44:50 1056    function 'IS NOT NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1057      pragma BUILTIN('IS NOT NULL', 0, 2, 50);
22:44:50 1058  
22:44:50 1059    function 'IS NULL' (n BLOB) return BOOLEAN;
22:44:50 1060      pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
22:44:50 1061    function 'IS NOT NULL' (n BLOB) return BOOLEAN;
22:44:50 1062      pragma BUILTIN('IS NOT NULL', 0, 2, 50);
22:44:50 1063  
22:44:50 1064    function 'IS NULL' (n BFILE) return BOOLEAN;
22:44:50 1065      pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
22:44:50 1066    function 'IS NOT NULL' (n BFILE) return BOOLEAN;
22:44:50 1067      pragma BUILTIN('IS NOT NULL', 0, 2, 50);
22:44:50 1068    -- end LOB IS NULL
22:44:50 1069  
22:44:50 1070    --****************************************************************
22:44:50 1071    -- 20 mar 96 =G=> In the following, arguments "1, 1, 1" to pragma BUILTIN
22:44:50 1072    -- e.g.,                pragma builtin('whatever', 1, 1, 1)
22:44:50 1073    -- indicate that those three numeric arguments to pragma BUILTIN are unknown,
22:44:50 1074    -- because they are not yet implemented by the backend.
22:44:50 1075  
22:44:50 1076    function '='  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1077      pragma BUILTIN('=', 1, 1, 1);
22:44:50 1078      pragma FIPSFLAG('=', 1450);
22:44:50 1079    function '!=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1080      pragma BUILTIN('!=', 1, 1, 1);
22:44:50 1081      pragma FIPSFLAG('!=', 1450);
22:44:50 1082    function '<'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1083      pragma BUILTIN('<', 1, 1, 1);
22:44:50 1084      pragma FIPSFLAG('<', 1450);
22:44:50 1085    function '<=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1086      pragma BUILTIN('<=', 1, 1, 1);
22:44:50 1087      pragma FIPSFLAG('<=', 1450);
22:44:50 1088    function '>'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1089      pragma BUILTIN('>', 1, 1, 1);
22:44:50 1090      pragma FIPSFLAG('>', 1450);
22:44:50 1091    function '>=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1092      pragma BUILTIN('>=', 1, 1, 1);
22:44:50 1093      pragma FIPSFLAG('>=', 1450);
22:44:50 1094  
22:44:50 1095    function '=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1096    function '!=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1097    function '<ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1098    function '<=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1099    function '>ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1100    function '>=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1101    function '=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1102    function '!=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1103    function '<ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1104    function '<=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1105    function '>ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1106    function '>=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1107    function '=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1108    function '!=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1109    function '<SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1110    function '<=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1111    function '>SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1112    function '>=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
22:44:50 1113  
22:44:50 1114    -- Outer Join
22:44:50 1115    function '(+)'  ( colname "<ADT_1>") return "<ADT_1>";
22:44:50 1116      pragma FIPSFLAG('(+)', 1450);
22:44:50 1117  
22:44:50 1118    --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
22:44:50 1119    --  function GREATEST (pattern "<ADT_1>") return "<ADT_1>";
22:44:50 1120    --    pragma BUILTIN('GREATEST', 1, 1, 1);
22:44:50 1121  
22:44:50 1122    --  function LEAST (pattern "<ADT_1>") return "<ADT_1>";
22:44:50 1123    --    pragma BUILTIN('LEAST', 1, 1, 1);
22:44:50 1124  
22:44:50 1125    function DECODE (expr "<ADT_1>", pat "<ADT_1>", res "<ADT_1>")
22:44:50 1126          return "<ADT_1>";
22:44:50 1127      pragma BUILTIN('DECODE', 1, 1, 1);
22:44:50 1128  
22:44:50 1129    function 'IS NULL' (B "<ADT_1>") return BOOLEAN;
22:44:50 1130      pragma BUILTIN('IS NULL', 0, 3, 0);
22:44:50 1131      pragma FIPSFLAG('IS NULL', 1450);
22:44:50 1132  
22:44:50 1133    function 'IS NOT NULL' (B "<ADT_1>") return BOOLEAN;
22:44:50 1134      pragma BUILTIN('IS NOT NULL', 0, 3, 50);
22:44:50 1135      pragma FIPSFLAG('IS NOT NULL', 1450);
22:44:50 1136  
22:44:50 1137    function NVL (B1 "<ADT_1>", B2 "<ADT_1>") return "<ADT_1>";
22:44:50 1138      pragma FIPSFLAG('NVL', 1450);
22:44:50 1139  
22:44:50 1140    function VALUE (item "<ADT_WITH_OID>") return "<ADT_1>";
22:44:50 1141      pragma BUILTIN('VALUE', 1, 1, 1);
22:44:50 1142      pragma FIPSFLAG('VALUE', 1450);
22:44:50 1143  
22:44:50 1144    function REF (item "<ADT_WITH_OID>") return REF "<ADT_1>";
22:44:50 1145      pragma BUILTIN('REF', 1, 1, 1);
22:44:50 1146      pragma FIPSFLAG('REF', 1450);
22:44:50 1147  
22:44:50 1148    function DEREF (r REF "<ADT_1>") return "<ADT_1>";
22:44:50 1149      pragma BUILTIN('DEREF', 1, 1, 1);
22:44:50 1150      pragma FIPSFLAG('DEREF', 1450);
22:44:50 1151  
22:44:50 1152    -- overloadings for REF ADT
22:44:50 1153  
22:44:50 1154    function 'IS NULL' (B REF "<ADT_1>") return BOOLEAN;
22:44:50 1155      pragma BUILTIN('IS NULL', 0, 3, 0);
22:44:50 1156      pragma FIPSFLAG('IS NULL', 1450);
22:44:50 1157  
22:44:50 1158    function 'IS NOT NULL' (B REF "<ADT_1>") return BOOLEAN;
22:44:50 1159      pragma BUILTIN('IS NOT NULL', 0, 3, 50);
22:44:50 1160      pragma FIPSFLAG('IS NOT NULL', 1450);
22:44:50 1161  
22:44:50 1162    function 'IS DANGLING' (B REF "<ADT_1>") return BOOLEAN;
22:44:50 1163      pragma BUILTIN('IS DANGLING', 1, 1, 1);
22:44:50 1164      pragma FIPSFLAG('IS DANGLING', 1450);
22:44:50 1165  
22:44:50 1166    function 'IS NOT DANGLING' (B REF "<ADT_1>") return BOOLEAN;
22:44:50 1167      pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
22:44:50 1168      pragma FIPSFLAG('IS NOT DANGLING', 1450);
22:44:50 1169  
22:44:50 1170    function NVL (B1 REF "<ADT_1>", B2 REF "<ADT_1>") return REF "<ADT_1>";
22:44:50 1171      pragma FIPSFLAG('NVL', 1450);
22:44:50 1172  
22:44:50 1173    function '='  (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
22:44:50 1174      pragma BUILTIN('=', 0, 3, 1);
22:44:50 1175      pragma FIPSFLAG('=', 1450);
22:44:50 1176  
22:44:50 1177    function '!=' (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
22:44:50 1178      pragma BUILTIN('!=', 0, 3, 2);
22:44:50 1179      pragma FIPSFLAG('!=', 1450);
22:44:50 1180  
22:44:50 1181    --  function '='  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
22:44:50 1182    --      return BOOLEAN;
22:44:50 1183    --    pragma BUILTIN('=', 1, 1, 1);
22:44:50 1184    --    pragma FIPSFLAG('=', 1450);
22:44:50 1185    --
22:44:50 1186    --  function '!=' (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
22:44:50 1187    --      return BOOLEAN;
22:44:50 1188    --    pragma BUILTIN('!=', 1, 1, 1);
22:44:50 1189    --    pragma FIPSFLAG('!=', 1450);
22:44:50 1190    --
22:44:50 1191    --  function '=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
22:44:50 1192    --      return BOOLEAN;
22:44:50 1193    --  function '!=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
22:44:50 1194    --      return BOOLEAN;
22:44:50 1195    --  function '=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
22:44:50 1196    --      return BOOLEAN;
22:44:50 1197    --  function '!=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
22:44:50 1198    --      return BOOLEAN;
22:44:50 1199    --  function '=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
22:44:50 1200    --      return BOOLEAN;
22:44:50 1201    --  function '!=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
22:44:50 1202    --      return BOOLEAN;
22:44:50 1203    --
22:44:50 1204    --  function DECODE (expr "<COLLECTION_1>", pat "<COLLECTION_1>",
22:44:50 1205    --                                        res "<COLLECTION_1>")
22:44:50 1206    --      return "<COLLECTION_1>";
22:44:50 1207    --    pragma BUILTIN('DECODE', 1, 1, 1);
22:44:50 1208  
22:44:50 1209    -- Note that index-by tables are never NULL: this function will always
22:44:50 1210    -- return FALSE for them.
22:44:50 1211    function 'IS NULL' (B "<COLLECTION_1>") return BOOLEAN;
22:44:50 1212      pragma BUILTIN('IS NULL', 0, 3, 0);
22:44:50 1213      pragma FIPSFLAG('IS NULL', 1450);
22:44:50 1214  
22:44:50 1215    -- Note that index-by tables are never NULL: this function will always
22:44:50 1216    -- return TRUE for them.
22:44:50 1217    function 'IS NOT NULL' (B "<COLLECTION_1>") return BOOLEAN;
22:44:50 1218      pragma BUILTIN('IS NOT NULL', 0, 3, 50);
22:44:50 1219      pragma FIPSFLAG('IS NOT NULL', 1450);
22:44:50 1220  
22:44:50 1221    -- Note that index-by tables are never NULL: this function will always
22:44:50 1222    -- return B1 for them.
22:44:50 1223    function NVL (B1 "<COLLECTION_1>", B2 "<COLLECTION_1>")
22:44:50 1224          return "<COLLECTION_1>";
22:44:50 1225      pragma FIPSFLAG('NVL', 1450);
22:44:50 1226  
22:44:50 1227    function 'IS NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
22:44:50 1228      pragma BUILTIN('IS NULL', 0, 3, 0);
22:44:50 1229      pragma FIPSFLAG('IS NULL', 1450);
22:44:50 1230  
22:44:50 1231    function 'IS NOT NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
22:44:50 1232      pragma BUILTIN('IS NOT NULL', 0, 3, 50);
22:44:50 1233      pragma FIPSFLAG('IS NOT NULL', 1450);
22:44:50 1234  
22:44:50 1235    function NVL (B1 "<REF_CURSOR_1>", B2 "<REF_CURSOR_1>")
22:44:50 1236          return "<REF_CURSOR_1>";
22:44:50 1237      pragma FIPSFLAG('NVL', 1450);
22:44:50 1238  
22:44:50 1239    -- Note that associative arrays are never NULL: this function will always
22:44:50 1240    -- return FALSE.
22:44:50 1241    function 'IS NULL' (B "<ASSOC_ARRAY_1>") return BOOLEAN;
22:44:50 1242      pragma BUILTIN('IS NULL', 0, 3, 0);
22:44:50 1243      pragma FIPSFLAG('IS NULL', 1450);
22:44:50 1244  
22:44:50 1245    -- Note that associative arrays are never NULL: this function will always
22:44:50 1246    -- return TRUE.
22:44:50 1247    function 'IS NOT NULL' (B "<ASSOC_ARRAY_1>") return BOOLEAN;
22:44:50 1248      pragma BUILTIN('IS NOT NULL', 0, 3, 50);
22:44:50 1249      pragma FIPSFLAG('IS NOT NULL', 1450);
22:44:50 1250  
22:44:50 1251    -- Note that associative arrays are never NULL: this function will always
22:44:50 1252    -- return B1.
22:44:50 1253    function NVL (B1 "<ASSOC_ARRAY_1>", B2 "<ASSOC_ARRAY_1>")
22:44:50 1254          return "<ASSOC_ARRAY_1>";
22:44:50 1255      pragma FIPSFLAG('NVL', 1450);
22:44:50 1256  
22:44:50 1257    function EMPTY_CLOB return clob;
22:44:50 1258    function EMPTY_BLOB return blob;
22:44:50 1259  
22:44:50 1260    function BFILENAME(directory varchar2,filename varchar2) return BFILE;
22:44:50 1261  
22:44:50 1262    function "SYS$LOB_REPLICATION" (x in blob) return blob;
22:44:50 1263    function "SYS$LOB_REPLICATION" (x in clob character set any_cs)
22:44:50 1264      return clob character set x%charset;
22:44:50 1265  
22:44:50 1266    --#### This is the end of 8.0 Standard
22:44:50 1267  
22:44:50 1268    --  + overloadings
22:44:50 1269  
22:44:50 1270    function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
22:44:50 1271                 return TIMESTAMP_UNCONSTRAINED;
22:44:50 1272    function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
22:44:50 1273                 return TIMESTAMP_UNCONSTRAINED;
22:44:50 1274  
22:44:50 1275    function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
22:44:50 1276                 return TIMESTAMP_TZ_UNCONSTRAINED ;
22:44:50 1277    function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
22:44:50 1278                 return TIMESTAMP_TZ_UNCONSTRAINED ;
22:44:50 1279  
22:44:50 1280    function '+'(LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
22:44:50 1281                 return TIME_UNCONSTRAINED;
22:44:50 1282  
22:44:50 1283    function '+'(LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
22:44:50 1284                 return TIME_TZ_UNCONSTRAINED;
22:44:50 1285  
22:44:50 1286    function '+'(LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date ;
22:44:50 1287    function '+'(LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date ;
22:44:50 1288    function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
22:44:50 1289                 return TIMESTAMP_UNCONSTRAINED;
22:44:50 1290    function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
22:44:50 1291                 return TIMESTAMP_TZ_UNCONSTRAINED ;
22:44:50 1292    function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT date) return date ;
22:44:50 1293  
22:44:50 1294    function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
22:44:50 1295                 return TIMESTAMP_UNCONSTRAINED;
22:44:50 1296    function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
22:44:50 1297                  return TIMESTAMP_TZ_UNCONSTRAINED ;
22:44:50 1298    function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
22:44:50 1299                  return TIME_UNCONSTRAINED ;
22:44:50 1300    function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
22:44:50 1301                  return TIME_TZ_UNCONSTRAINED ;
22:44:50 1302    function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT date) return date ;
22:44:50 1303  
22:44:50 1304    function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
22:44:50 1305                 return DSINTERVAL_UNCONSTRAINED ;
22:44:50 1306    function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
22:44:50 1307                 return YMINTERVAL_UNCONSTRAINED ;
22:44:50 1308  
22:44:50 1309    -- begin subtract
22:44:50 1310    function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
22:44:50 1311                                       RIGHT TIMESTAMP_UNCONSTRAINED)
22:44:50 1312             return DSINTERVAL_UNCONSTRAINED ;
22:44:50 1313    function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
22:44:50 1314                                       RIGHT TIMESTAMP_UNCONSTRAINED)
22:44:50 1315             return YMINTERVAL_UNCONSTRAINED ;
22:44:50 1316    function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
22:44:50 1317                 return TIMESTAMP_UNCONSTRAINED;
22:44:50 1318    function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
22:44:50 1319                 return TIMESTAMP_UNCONSTRAINED;
22:44:50 1320  
22:44:50 1321    function " SYS$DSINTERVALSUBTRACT"
22:44:50 1322     (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
22:44:50 1323      return DSINTERVAL_UNCONSTRAINED ;
22:44:50 1324    function " SYS$YMINTERVALSUBTRACT"
22:44:50 1325     (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
22:44:50 1326      return YMINTERVAL_UNCONSTRAINED ;
22:44:50 1327    function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
22:44:50 1328      return TIMESTAMP_TZ_UNCONSTRAINED ;
22:44:50 1329    function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
22:44:50 1330      return TIMESTAMP_TZ_UNCONSTRAINED ;
22:44:50 1331  
22:44:50 1332    function " SYS$DSINTERVALSUBTRACT" (LEFT TIME_UNCONSTRAINED,
22:44:50 1333                                        RIGHT TIME_UNCONSTRAINED)
22:44:50 1334       return DSINTERVAL_UNCONSTRAINED ;
22:44:50 1335    function '-' (LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
22:44:50 1336      return TIME_UNCONSTRAINED ;
22:44:50 1337    function " SYS$DSINTERVALSUBTRACT"
22:44:50 1338     (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
22:44:50 1339      return DSINTERVAL_UNCONSTRAINED ;
22:44:50 1340    function '-' (LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
22:44:50 1341      return TIME_TZ_UNCONSTRAINED ;
22:44:50 1342    function  " SYS$DSINTERVALSUBTRACT" (LEFT date, RIGHT date)
22:44:50 1343      return DSINTERVAL_UNCONSTRAINED ;
22:44:50 1344    function " SYS$YMINTERVALSUBTRACT" (LEFT date, RIGHT date)
22:44:50 1345      return YMINTERVAL_UNCONSTRAINED ;
22:44:50 1346    function '-' (LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date;
22:44:50 1347    function '-' (LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date;
22:44:50 1348  
22:44:50 1349    function '-' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
22:44:50 1350      return YMINTERVAL_UNCONSTRAINED ;
22:44:50 1351    function '-' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
22:44:50 1352     return DSINTERVAL_UNCONSTRAINED ;
22:44:50 1353  
22:44:50 1354    -- end subtract
22:44:50 1355  
22:44:50 1356    -- other datetime operators
22:44:50 1357  
22:44:50 1358    function '*' (LEFT number, RIGHT YMINTERVAL_UNCONSTRAINED)
22:44:50 1359      return YMINTERVAL_UNCONSTRAINED ;
22:44:50 1360    function '*' (LEFT number, RIGHT DSINTERVAL_UNCONSTRAINED)
22:44:50 1361      return DSINTERVAL_UNCONSTRAINED ;
22:44:50 1362  
22:44:50 1363    function '*' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
22:44:50 1364      return YMINTERVAL_UNCONSTRAINED ;
22:44:50 1365    function '*' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
22:44:50 1366      return DSINTERVAL_UNCONSTRAINED ;
22:44:50 1367  
22:44:50 1368    function '/' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
22:44:50 1369      return YMINTERVAL_UNCONSTRAINED ;
22:44:50 1370    function '/' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
22:44:50 1371      return DSINTERVAL_UNCONSTRAINED ;
22:44:50 1372  
22:44:50 1373  
22:44:50 1374    function current_date return date;
22:44:50 1375    function current_time return TIME_TZ_UNCONSTRAINED;
22:44:50 1376    function current_timestamp return TIMESTAMP_TZ_UNCONSTRAINED;
22:44:50 1377  
22:44:50 1378    function TO_TIME (RIGHT varchar2 character set any_cs) return
22:44:50 1379      time_unconstrained;
22:44:50 1380      pragma BUILTIN('TO_TIME', 0, 15, 1);
22:44:50 1381      function TO_TIMESTAMP (RIGHT varchar2 character set any_cs)
22:44:50 1382                             return TIMESTAMP_UNCONSTRAINED;
22:44:50 1383      pragma BUILTIN('TO_TIMESTAMP', 0, 15, 3);
22:44:50 1384    function TO_TIME_TZ (RIGHT varchar2 character set any_cs)
22:44:50 1385      return  TIME_TZ_UNCONSTRAINED;
22:44:50 1386      pragma BUILTIN('TO_TIME_TZ', 0, 15, 5);
22:44:50 1387    function TO_TIMESTAMP_TZ (RIGHT varchar2 character set any_cs)
22:44:50 1388      return  TIMESTAMP_TZ_UNCONSTRAINED;
22:44:50 1389      pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 7);
22:44:50 1390    function TO_YMINTERVAL (RIGHT varchar2 character set any_cs)
22:44:50 1391      return  YMINTERVAL_UNCONSTRAINED;
22:44:50 1392      pragma BUILTIN('TO_YMINTERVAL', 0, 15, 9);
22:44:50 1393    function TO_DSINTERVAL (RIGHT varchar2 character set any_cs)
22:44:50 1394      return  DSINTERVAL_UNCONSTRAINED;
22:44:50 1395      pragma BUILTIN('TO_DSINTERVAL', 0, 15, 11);
22:44:50 1396  
22:44:50 1397    -- with nls args
22:44:50 1398    function TO_TIME(left varchar2 character set any_cs,
22:44:50 1399                     format varchar2 character set left%charset,
22:44:50 1400                     parms varchar2 character set left%charset)
22:44:50 1401      return TIME_UNCONSTRAINED;
22:44:50 1402    function TO_TIME(left varchar2 character set any_cs,
22:44:50 1403                     format varchar2 character set left%charset)
22:44:50 1404      return TIME_UNCONSTRAINED;
22:44:50 1405    function TO_TIMESTAMP(left varchar2 character set any_cs,
22:44:50 1406                          format varchar2 character set left%charset,
22:44:50 1407                          parms varchar2 character set left%charset)
22:44:50 1408      return TIMESTAMP_UNCONSTRAINED;
22:44:50 1409    function TO_TIMESTAMP(left varchar2 character set any_cs,
22:44:50 1410                          format varchar2 character set left%charset)
22:44:50 1411      return TIMESTAMP_UNCONSTRAINED;
22:44:50 1412    function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
22:44:50 1413                             format varchar2 character set left%charset,
22:44:50 1414                             parms varchar2 character set left%charset)
22:44:50 1415      return TIMESTAMP_TZ_UNCONSTRAINED;
22:44:50 1416    function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
22:44:50 1417                             format varchar2 character set left%charset)
22:44:50 1418      return TIMESTAMP_TZ_UNCONSTRAINED;
22:44:50 1419    function TO_TIME_TZ(left varchar2 character set any_cs,
22:44:50 1420                        format varchar2 character set left%charset,
22:44:50 1421                        parms varchar2 character set left%charset)
22:44:50 1422      return TIME_TZ_UNCONSTRAINED;
22:44:50 1423    function TO_TIME_TZ(left varchar2 character set any_cs,
22:44:50 1424                        format varchar2 character set left%charset)
22:44:50 1425      return TIME_TZ_UNCONSTRAINED;
22:44:50 1426    function TO_DSINTERVAL(RIGHT varchar2 character set any_cs,
22:44:50 1427                           parms varchar2 character set RIGHT%charset)
22:44:50 1428      return DSINTERVAL_UNCONSTRAINED;
22:44:50 1429  
22:44:50 1430    function NUMTOYMINTERVAL(numerator number,
22:44:50 1431                             units varchar2 character set any_cs)
22:44:50 1432      return YMINTERVAL_UNCONSTRAINED;
22:44:50 1433    function NUMTODSINTERVAL(numerator number,
22:44:50 1434                             units varchar2 character set any_cs)
22:44:50 1435      return DSINTERVAL_UNCONSTRAINED;
22:44:50 1436  
22:44:50 1437    function '='  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
22:44:50 1438      pragma BUILTIN('=',0, 11, 1);
22:44:50 1439      pragma FIPSFLAG('=', 1450);
22:44:50 1440    function '!=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;  -- also <> and ~=
22:44:50 1441      pragma BUILTIN('!=',0, 11, 2);
22:44:50 1442      pragma FIPSFLAG('!=', 1450);
22:44:50 1443    function '<'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
22:44:50 1444      pragma BUILTIN('<',0, 11, 3);
22:44:50 1445      pragma FIPSFLAG('<', 1450);
22:44:50 1446    function '<=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
22:44:50 1447      pragma BUILTIN('<=',0, 11, 4);
22:44:50 1448      pragma FIPSFLAG('<=', 1450);
22:44:50 1449    function '>'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
22:44:50 1450      pragma BUILTIN('>',0, 11, 5);
22:44:50 1451      pragma FIPSFLAG('>', 1450);
22:44:50 1452    function '>=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
22:44:50 1453      pragma BUILTIN('>=',0, 11, 6);
22:44:50 1454      pragma FIPSFLAG('>=', 1450);
22:44:50 1455  
22:44:50 1456    function 'IS NULL' (u UROWID) return BOOLEAN;
22:44:50 1457      pragma BUILTIN('IS NULL', 0, 14, 0); -- PEMS_UROWID, PEMDNUL
22:44:50 1458      pragma FIPSFLAG('IS NULL', 1450);
22:44:50 1459    function 'IS NOT NULL' (u UROWID) return BOOLEAN;
22:44:50 1460      pragma BUILTIN('IS NOT NULL', 0, 14, 50); -- PEMS_UROWID, PEMDNUL
22:44:50 1461      pragma FIPSFLAG('IS NOT NULL', 1450);
22:44:50 1462  
22:44:50 1463    function "UROWID " return UROWID;
22:44:50 1464      pragma builtin('UROWID ', 1, 209, 240);  -- this had better never be called.
22:44:50 1465  
22:44:50 1466    -- New built-in function SYS_GUID, returns globally unique id
22:44:50 1467    function SYS_GUID return RAW;
22:44:50 1468  
22:44:50 1469    -- New built-in function SYS_CONTEXT
22:44:50 1470    function SYS_CONTEXT (namespace varchar2, attribute varchar2)
22:44:50 1471      return varchar2;
22:44:50 1472  
22:44:50 1473    function TRIM(v VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 1474      return VARCHAR2 CHARACTER SET v%CHARSET;
22:44:50 1475  
22:44:50 1476    --#### This is the end of 8.1.5 Standard
22:44:50 1477  
22:44:50 1478    -- SYS_CONTEXT now has an additional optional parameter
22:44:50 1479    function SYS_CONTEXT(namespace varchar2, attribute varchar2,
22:44:50 1480                         newoptional varchar2)
22:44:50 1481      return varchar2;
22:44:50 1482  
22:44:50 1483    -- CUBE and ROLLUP are not real functions; they are variants on the GROUP
22:44:50 1484    -- BY clause (GROUP BY CUBE (...) and GROUP BY ROLLUP (...)). They have
22:44:50 1485    -- been added here as functions to avoid name capture issues.
22:44:50 1486    --
22:44:50 1487    -- Note that both CUBE and ROLLUP look like true vararg functions with
22:44:50 1488    -- *no* repeating pattern of formals - hence they are special cased in
22:44:50 1489    -- the overloading code.
22:44:50 1490    function CUBE return NUMBER;
22:44:50 1491    function ROLLUP return NUMBER;
22:44:50 1492  
22:44:50 1493    -- The GROUPING function must be used in conjunction with CUBE and ROLLUP
22:44:50 1494    -- in the GROUP BY clause. The type of the parameter to GROUPING can be
22:44:50 1495    -- any type that can appear in a GROUP BY list.
22:44:50 1496    function GROUPING(v VARCHAR2) return NUMBER;
22:44:50 1497    function GROUPING(a "<ADT_1>") return NUMBER;
22:44:50 1498  
22:44:50 1499    -- This is for TRIM(x). No trim set.
22:44:50 1500    function " SYS$STANDARD_TRIM" (v VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 1501      return VARCHAR2 CHARACTER SET v%CHARSET;
22:44:50 1502  
22:44:50 1503    -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
22:44:50 1504    function " SYS$STANDARD_TRIM" (STR1 VARCHAR2 CHARACTER SET ANY_CS ,
22:44:50 1505                                   TRFLAG PLS_INTEGER)
22:44:50 1506      return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 1507  
22:44:50 1508    -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
22:44:50 1509    -- This one takes a trim set.
22:44:50 1510    function " SYS$STANDARD_TRIM" (STR1   VARCHAR2 CHARACTER SET ANY_CS ,
22:44:50 1511                                   TSET   VARCHAR2 CHARACTER SET STR1%CHARSET,
22:44:50 1512                                   TRFLAG PLS_INTEGER)
22:44:50 1513      return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 1514  
22:44:50 1515    --#### This is the end of the supported parts of 8.1.6 Standard
22:44:50 1516  
22:44:50 1517    --## Support for ANSI datetime data types is under development.
22:44:50 1518    --## The following operations, as well as the related types and
22:44:50 1519    --## operations defined above in the 8.1.5 section, are not yet
22:44:50 1520    --## available for use and are still subject to change.
22:44:50 1521  
22:44:50 1522    --- datetime equivalence
22:44:50 1523    function '='  (LEFT TIME_UNCONSTRAINED,
22:44:50 1524                   RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
22:44:50 1525    function '!=' (LEFT TIME_UNCONSTRAINED,
22:44:50 1526                   RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
22:44:50 1527    function '<'  (LEFT TIME_UNCONSTRAINED,
22:44:50 1528                   RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
22:44:50 1529    function '<=' (LEFT TIME_UNCONSTRAINED,
22:44:50 1530                   RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
22:44:50 1531    function '>'  (LEFT TIME_UNCONSTRAINED,
22:44:50 1532                   RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
22:44:50 1533    function '>=' (LEFT TIME_UNCONSTRAINED,
22:44:50 1534                   RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
22:44:50 1535  
22:44:50 1536    function '='  (LEFT TIMESTAMP_UNCONSTRAINED,
22:44:50 1537                   RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
22:44:50 1538    function '!=' (LEFT TIMESTAMP_UNCONSTRAINED,
22:44:50 1539                   RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
22:44:50 1540    function '<'  (LEFT TIMESTAMP_UNCONSTRAINED,
22:44:50 1541                   RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
22:44:50 1542    function '<=' (LEFT TIMESTAMP_UNCONSTRAINED,
22:44:50 1543                   RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
22:44:50 1544    function '>'  (LEFT TIMESTAMP_UNCONSTRAINED,
22:44:50 1545                   RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
22:44:50 1546    function '>=' (LEFT TIMESTAMP_UNCONSTRAINED,
22:44:50 1547                   RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
22:44:50 1548  
22:44:50 1549    function '='  (LEFT TIME_TZ_UNCONSTRAINED,
22:44:50 1550                   RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1551    function '!=' (LEFT TIME_TZ_UNCONSTRAINED,
22:44:50 1552                   RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1553    function '<'  (LEFT TIME_TZ_UNCONSTRAINED,
22:44:50 1554                   RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1555    function '<=' (LEFT TIME_TZ_UNCONSTRAINED,
22:44:50 1556                   RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1557    function '>'  (LEFT TIME_TZ_UNCONSTRAINED,
22:44:50 1558                   RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1559    function '>=' (LEFT TIME_TZ_UNCONSTRAINED,
22:44:50 1560                   RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1561  
22:44:50 1562    function '='  (LEFT YMINTERVAL_UNCONSTRAINED,
22:44:50 1563                   RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1564    function '!=' (LEFT YMINTERVAL_UNCONSTRAINED,
22:44:50 1565                   RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1566    function '<'  (LEFT YMINTERVAL_UNCONSTRAINED,
22:44:50 1567                   RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1568    function '<=' (LEFT YMINTERVAL_UNCONSTRAINED,
22:44:50 1569                   RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1570    function '>'  (LEFT YMINTERVAL_UNCONSTRAINED,
22:44:50 1571                   RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1572    function '>=' (LEFT YMINTERVAL_UNCONSTRAINED,
22:44:50 1573                   RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1574  
22:44:50 1575    function '='  (LEFT DSINTERVAL_UNCONSTRAINED,
22:44:50 1576                   RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1577    function '!=' (LEFT DSINTERVAL_UNCONSTRAINED,
22:44:50 1578                   RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1579    function '<'  (LEFT DSINTERVAL_UNCONSTRAINED,
22:44:50 1580                   RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1581    function '<=' (LEFT DSINTERVAL_UNCONSTRAINED,
22:44:50 1582                   RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1583    function '>'  (LEFT DSINTERVAL_UNCONSTRAINED,
22:44:50 1584                   RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1585    function '>=' (LEFT DSINTERVAL_UNCONSTRAINED,
22:44:50 1586                   RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1587  
22:44:50 1588    function TO_TIME (RIGHT TIME_TZ_UNCONSTRAINED)  return TIME_UNCONSTRAINED;
22:44:50 1589      pragma BUILTIN('TO_TIME', 0, 15, 13);
22:44:50 1590    function TO_TIME_TZ (RIGHT TIME_UNCONSTRAINED)  return TIME_TZ_UNCONSTRAINED;
22:44:50 1591      pragma BUILTIN('TO_TIME_TZ', 0, 15, 14);
22:44:50 1592    function TO_TIMESTAMP (RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
22:44:50 1593      return TIMESTAMP_UNCONSTRAINED;
22:44:50 1594      pragma BUILTIN('TO_TIMESTAMP', 0, 15, 15);
22:44:50 1595    function TO_TIMESTAMP_TZ (RIGHT TIMESTAMP_UNCONSTRAINED)
22:44:50 1596      return TIMESTAMP_TZ_UNCONSTRAINED;
22:44:50 1597      pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 16);
22:44:50 1598  
22:44:50 1599    function '-'
22:44:50 1600        (LEFT TIME_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
22:44:50 1601      return DSINTERVAL_UNCONSTRAINED;
22:44:50 1602    function '-'
22:44:50 1603        (LEFT TIMESTAMP_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
22:44:50 1604      return DSINTERVAL_UNCONSTRAINED;
22:44:50 1605    function '-'
22:44:50 1606        (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
22:44:50 1607      return DSINTERVAL_UNCONSTRAINED;
22:44:50 1608    function '-'
22:44:50 1609        (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
22:44:50 1610      return DSINTERVAL_UNCONSTRAINED;
22:44:50 1611  
22:44:50 1612    -- timezone functions
22:44:50 1613    function SYS_AT_TIME_ZONE(t time_tz_unconstrained,
22:44:50 1614                              i varchar2) RETURN time_tz_unconstrained;
22:44:50 1615    function SYS_AT_TIME_ZONE(t timestamp_tz_unconstrained,
22:44:50 1616                              i varchar2) RETURN timestamp_tz_unconstrained;
22:44:50 1617    FUNCTION systimestamp RETURN timestamp_tz_unconstrained;
22:44:50 1618    FUNCTION dbtimezone RETURN varchar2;
22:44:50 1619    FUNCTION sessiontimezone RETURN varchar2;
22:44:50 1620    FUNCTION localtimestamp RETURN timestamp_unconstrained;
22:44:50 1621    FUNCTION localtime RETURN time_unconstrained;
22:44:50 1622  
22:44:50 1623    function TO_TIMESTAMP (RIGHT DATE)  return TIMESTAMP_UNCONSTRAINED;
22:44:50 1624      pragma BUILTIN('TO_TIMESTAMP', 0, 15, 17);
22:44:50 1625  
22:44:50 1626    function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1627                 RIGHT yminterval_unconstrained)
22:44:50 1628      return TIMESTAMP_LTZ_UNCONSTRAINED;
22:44:50 1629    function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1630                 RIGHT dsinterval_unconstrained)
22:44:50 1631      return TIMESTAMP_LTZ_UNCONSTRAINED;
22:44:50 1632    function '+'(LEFT yminterval_unconstrained,
22:44:50 1633                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
22:44:50 1634      return TIMESTAMP_LTZ_UNCONSTRAINED ;
22:44:50 1635    function '+'(LEFT dsinterval_unconstrained,
22:44:50 1636                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
22:44:50 1637      return TIMESTAMP_LTZ_UNCONSTRAINED ;
22:44:50 1638  
22:44:50 1639    function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1640                 RIGHT yminterval_unconstrained)
22:44:50 1641      return TIMESTAMP_LTZ_UNCONSTRAINED ;
22:44:50 1642    function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1643                 RIGHT dsinterval_unconstrained)
22:44:50 1644      return TIMESTAMP_LTZ_UNCONSTRAINED ;
22:44:50 1645  
22:44:50 1646    function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1647                                       RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
22:44:50 1648      return dsinterval_unconstrained;
22:44:50 1649    function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1650                                       RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
22:44:50 1651      return yminterval_unconstrained;
22:44:50 1652  
22:44:50 1653    function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1654                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
22:44:50 1655      return dsinterval_unconstrained;
22:44:50 1656  
22:44:50 1657    function '='  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
22:44:50 1658                   RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1659    function '!=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
22:44:50 1660                   RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1661    function '<'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
22:44:50 1662                   RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1663    function '<=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
22:44:50 1664                   RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1665    function '>'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
22:44:50 1666                   RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1667    function '>=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
22:44:50 1668                   RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1669  
22:44:50 1670    function '='  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1671                   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1672    function '!=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1673                   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1674    function '<'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1675                   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1676    function '<=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1677                   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1678    function '>'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1679                   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1680    function '>=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1681                   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1682  
22:44:50 1683    function SYS_LITERALTOYMINTERVAL(numerator varchar2, units varchar2)
22:44:50 1684      return YMINTERVAL_UNCONSTRAINED;
22:44:50 1685    function SYS_LITERALTODSINTERVAL(numerator varchar2, units varchar2)
22:44:50 1686      return DSINTERVAL_UNCONSTRAINED;
22:44:50 1687    function SYS_LITERALTOTIME(numerator varchar2)
22:44:50 1688      return TIME_UNCONSTRAINED;
22:44:50 1689    function SYS_LITERALTOTZTIME(numerator varchar2)
22:44:50 1690      return TIME_TZ_UNCONSTRAINED;
22:44:50 1691    function SYS_LITERALTOTIMESTAMP(numerator varchar2)
22:44:50 1692      return TIMESTAMP_UNCONSTRAINED;
22:44:50 1693    function SYS_LITERALTOTZTIMESTAMP(numerator varchar2)
22:44:50 1694      return TIMESTAMP_TZ_UNCONSTRAINED;
22:44:50 1695    function SYS_LITERALTODATE(numerator varchar2) return DATE;
22:44:50 1696  
22:44:50 1697  
22:44:50 1698    -- Explicit conversions between date and datetime
22:44:50 1699    function TO_TIMESTAMP(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
22:44:50 1700      return TIMESTAMP_UNCONSTRAINED;
22:44:50 1701      pragma BUILTIN('TO_TIMESTAMP', 0, 15, 24);
22:44:50 1702  
22:44:50 1703    function TO_TIMESTAMP_TZ(ARG DATE) return TIMESTAMP_TZ_UNCONSTRAINED;
22:44:50 1704      pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 27);
22:44:50 1705  
22:44:50 1706    function TO_TIMESTAMP_TZ(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
22:44:50 1707      return TIMESTAMP_TZ_UNCONSTRAINED;
22:44:50 1708      pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 26);
22:44:50 1709  
22:44:50 1710    -- IS [NOT] NULL / NVL for datetime
22:44:50 1711    function 'IS NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
22:44:50 1712    function 'IS NOT NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
22:44:50 1713    function NVL (b1 TIME_UNCONSTRAINED,
22:44:50 1714                  b2 TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
22:44:50 1715  
22:44:50 1716    function 'IS NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1717    function 'IS NOT NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1718    function NVL (b1 TIME_TZ_UNCONSTRAINED, b2 TIME_TZ_UNCONSTRAINED)
22:44:50 1719      return TIME_TZ_UNCONSTRAINED;
22:44:50 1720  
22:44:50 1721    function 'IS NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
22:44:50 1722    function 'IS NOT NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
22:44:50 1723    function NVL (b1 TIMESTAMP_UNCONSTRAINED,
22:44:50 1724                  b2 TIMESTAMP_UNCONSTRAINED) return TIMESTAMP_UNCONSTRAINED;
22:44:50 1725  
22:44:50 1726    function 'IS NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1727    function 'IS NOT NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1728    function NVL (b1 TIMESTAMP_TZ_UNCONSTRAINED, b2 TIMESTAMP_TZ_UNCONSTRAINED)
22:44:50 1729      return TIMESTAMP_TZ_UNCONSTRAINED;
22:44:50 1730  
22:44:50 1731    function 'IS NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1732    function 'IS NOT NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
22:44:50 1733    function NVL (b1 TIMESTAMP_LTZ_UNCONSTRAINED,
22:44:50 1734                  b2 TIMESTAMP_LTZ_UNCONSTRAINED)
22:44:50 1735      return TIMESTAMP_LTZ_UNCONSTRAINED;
22:44:50 1736  
22:44:50 1737    function 'IS NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1738    function 'IS NOT NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1739    function NVL (b1 YMINTERVAL_UNCONSTRAINED, b2 YMINTERVAL_UNCONSTRAINED)
22:44:50 1740      return YMINTERVAL_UNCONSTRAINED;
22:44:50 1741  
22:44:50 1742    function 'IS NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1743    function 'IS NOT NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
22:44:50 1744    function NVL (b1 DSINTERVAL_UNCONSTRAINED, b2 DSINTERVAL_UNCONSTRAINED)
22:44:50 1745      return DSINTERVAL_UNCONSTRAINED;
22:44:50 1746  
22:44:50 1747    function " SYS$EXTRACT_FROM"
22:44:50 1748                (T TIME_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
22:44:50 1749    function " SYS$EXTRACT_FROM"
22:44:50 1750                (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
22:44:50 1751    function " SYS$EXTRACT_FROM"
22:44:50 1752                (T TIMESTAMP_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
22:44:50 1753    function " SYS$EXTRACT_FROM"
22:44:50 1754                (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
22:44:50 1755    function " SYS$EXTRACT_FROM"
22:44:50 1756                (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
22:44:50 1757    function " SYS$EXTRACT_FROM"
22:44:50 1758                (T DATE,FIELD VARCHAR2) return NUMBER;
22:44:50 1759    function " SYS$EXTRACT_FROM"
22:44:50 1760                (I YMINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
22:44:50 1761    function " SYS$EXTRACT_FROM"
22:44:50 1762                (I DSINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
22:44:50 1763  
22:44:50 1764    -- ##########      8.2 LOB Built-in Functions       ######## --
22:44:50 1765  
22:44:50 1766    -- LENGTH --
22:44:50 1767    function LENGTH(ch CLOB CHARACTER SET ANY_CS) return integer;
22:44:50 1768      pragma FIPSFLAG('LENGTH', 1452);
22:44:50 1769  
22:44:50 1770    function LENGTHB(ch CLOB CHARACTER SET ANY_CS) return integer;
22:44:50 1771      pragma FIPSFLAG('LENGTHB', 1452);
22:44:50 1772  
22:44:50 1773    function LENGTH(bl BLOB) return integer;
22:44:50 1774      pragma FIPSFLAG('LENGTH', 1452);
22:44:50 1775  
22:44:50 1776    function LENGTHB(bl BLOB) return integer;
22:44:50 1777      pragma FIPSFLAG('LENGTHB', 1452);
22:44:50 1778  
22:44:50 1779    -- SUBSTR --
22:44:50 1780    function SUBSTR(STR1 CLOB CHARACTER SET ANY_CS,
22:44:50 1781                    POS INTEGER,
22:44:50 1782                    LEN INTEGER := 18446744073709551615)
22:44:50 1783      return CLOB CHARACTER SET STR1%CHARSET;
22:44:50 1784      pragma FIPSFLAG('SUBSTR', 1452);
22:44:50 1785  
22:44:50 1786    function SUBSTRB(STR1 CLOB CHARACTER SET ANY_CS,
22:44:50 1787                    POS INTEGER,
22:44:50 1788                    LEN INTEGER := 18446744073709551615)
22:44:50 1789      return CLOB CHARACTER SET STR1%CHARSET;
22:44:50 1790      pragma FIPSFLAG('SUBSTRB', 1452);
22:44:50 1791  
22:44:50 1792    -- INSTR --
22:44:50 1793    function INSTR(STR1 CLOB CHARACTER SET ANY_CS,
22:44:50 1794                   STR2 CLOB CHARACTER SET STR1%CHARSET,
22:44:50 1795                   POS INTEGER := 1,
22:44:50 1796                   NTH INTEGER := 1) return INTEGER;
22:44:50 1797      pragma FIPSFLAG('INSTR', 1452);
22:44:50 1798  
22:44:50 1799    function INSTRB(STR1 CLOB CHARACTER SET ANY_CS,
22:44:50 1800                    STR2 CLOB CHARACTER SET STR1%CHARSET,
22:44:50 1801                    POS INTEGER := 1,
22:44:50 1802                    NTH INTEGER := 1) return INTEGER;
22:44:50 1803      pragma FIPSFLAG('INSTRB', 1452);
22:44:50 1804  
22:44:50 1805    -- CONCAT --
22:44:50 1806    function '||' (LEFT CLOB CHARACTER SET ANY_CS,
22:44:50 1807                   RIGHT CLOB CHARACTER SET ANY_CS)
22:44:50 1808      return CLOB CHARACTER SET LEFT%CHARSET;
22:44:50 1809      pragma FIPSFLAG('||', 1454);
22:44:50 1810  
22:44:50 1811    function CONCAT(LEFT CLOB CHARACTER SET ANY_CS,
22:44:50 1812                    RIGHT CLOB CHARACTER SET ANY_CS)
22:44:50 1813      return CLOB CHARACTER SET LEFT%CHARSET;
22:44:50 1814      pragma FIPSFLAG(CONCAT, 1454);
22:44:50 1815  
22:44:50 1816    -- UPPER --
22:44:50 1817    function UPPER(ch CLOB CHARACTER SET ANY_CS)
22:44:50 1818      return CLOB CHARACTER SET ch%CHARSET;
22:44:50 1819      pragma FIPSFLAG('UPPER', 1452);
22:44:50 1820  
22:44:50 1821    -- LOWER --
22:44:50 1822    function LOWER(ch CLOB CHARACTER SET ANY_CS)
22:44:50 1823      return CLOB CHARACTER SET ch%CHARSET;
22:44:50 1824      pragma FIPSFLAG('LOWER', 1452);
22:44:50 1825  
22:44:50 1826    -- LPAD --
22:44:50 1827    function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
22:44:50 1828                  LEN integer,
22:44:50 1829                  PAD CLOB CHARACTER SET STR1%CHARSET)
22:44:50 1830      return CLOB CHARACTER SET STR1%CHARSET;
22:44:50 1831      pragma FIPSFLAG('LPAD', 1452);
22:44:50 1832  
22:44:50 1833    function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
22:44:50 1834                  LEN integer)
22:44:50 1835      return CLOB CHARACTER SET STR1%CHARSET;
22:44:50 1836      pragma FIPSFLAG('LPAD', 1452);
22:44:50 1837  
22:44:50 1838    -- RPAD --
22:44:50 1839    function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
22:44:50 1840                  LEN integer,
22:44:50 1841                  PAD CLOB CHARACTER SET STR1%CHARSET)
22:44:50 1842      return CLOB CHARACTER SET STR1%CHARSET;
22:44:50 1843      pragma FIPSFLAG('RPAD', 1452);
22:44:50 1844  
22:44:50 1845    function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
22:44:50 1846                  LEN integer)
22:44:50 1847      return CLOB CHARACTER SET STR1%CHARSET;
22:44:50 1848      pragma FIPSFLAG('RPAD', 1452);
22:44:50 1849  
22:44:50 1850    -- LTRIM --
22:44:50 1851    function LTRIM(STR1 CLOB CHARACTER SET ANY_CS,
22:44:50 1852                   TSET CLOB CHARACTER SET STR1%CHARSET)
22:44:50 1853      return CLOB CHARACTER SET STR1%CHARSET;
22:44:50 1854      pragma FIPSFLAG('LTRIM', 1452);
22:44:50 1855  
22:44:50 1856    function LTRIM(STR1 CLOB CHARACTER SET ANY_CS)
22:44:50 1857      return CLOB CHARACTER SET STR1%CHARSET;
22:44:50 1858      pragma FIPSFLAG('LTRIM', 1452);
22:44:50 1859  
22:44:50 1860    -- RTRIM --
22:44:50 1861    function RTRIM(STR1 CLOB CHARACTER SET ANY_CS,
22:44:50 1862                   TSET CLOB CHARACTER SET STR1%CHARSET)
22:44:50 1863      return CLOB CHARACTER SET STR1%CHARSET;
22:44:50 1864      pragma FIPSFLAG('RTRIM', 1452);
22:44:50 1865  
22:44:50 1866    function RTRIM(STR1 CLOB CHARACTER SET ANY_CS)
22:44:50 1867      return CLOB CHARACTER SET STR1%CHARSET;
22:44:50 1868      pragma FIPSFLAG('RTRIM', 1452);
22:44:50 1869  
22:44:50 1870    -- TRIM --
22:44:50 1871    function TRIM(v CLOB CHARACTER SET ANY_CS)
22:44:50 1872      return CLOB CHARACTER SET v%CHARSET;
22:44:50 1873  
22:44:50 1874    -- This is for TRIM(x). No trim set.
22:44:50 1875    function " SYS$STANDARD_TRIM" (v CLOB CHARACTER SET ANY_CS)
22:44:50 1876      return CLOB CHARACTER SET v%CHARSET;
22:44:50 1877  
22:44:50 1878    -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
22:44:50 1879    function " SYS$STANDARD_TRIM" (STR1 CLOB CHARACTER SET ANY_CS ,
22:44:50 1880                                 TRFLAG PLS_INTEGER)
22:44:50 1881      return CLOB CHARACTER SET STR1%CHARSET;
22:44:50 1882  
22:44:50 1883    -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
22:44:50 1884    -- This one takes a trim set.
22:44:50 1885    function " SYS$STANDARD_TRIM" (STR1   CLOB CHARACTER SET ANY_CS ,
22:44:50 1886                                   TSET   CLOB CHARACTER SET STR1%CHARSET,
22:44:50 1887                                   TRFLAG PLS_INTEGER)
22:44:50 1888      return CLOB CHARACTER SET STR1%CHARSET;
22:44:50 1889  
22:44:50 1890  
22:44:50 1891    -- LIKE --
22:44:50 1892    function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
22:44:50 1893                     pat CLOB CHARACTER SET str%CHARSET)
22:44:50 1894      return BOOLEAN;
22:44:50 1895    function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
22:44:50 1896                         pat CLOB CHARACTER SET str%CHARSET)
22:44:50 1897      return BOOLEAN;
22:44:50 1898  
22:44:50 1899    function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
22:44:50 1900                     pat CLOB CHARACTER SET str%CHARSET,
22:44:50 1901                     esc VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 1902      return BOOLEAN;
22:44:50 1903    function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
22:44:50 1904                         pat CLOB CHARACTER SET str%CHARSET,
22:44:50 1905                         esc VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 1906      return BOOLEAN;
22:44:50 1907  
22:44:50 1908    -- NVL --
22:44:50 1909    function NVL(s1 CLOB CHARACTER SET ANY_CS,
22:44:50 1910                 s2 CLOB CHARACTER SET s1%CHARSET)
22:44:50 1911      return CLOB CHARACTER SET s1%CHARSET;
22:44:50 1912      pragma FIPSFLAG('NVL', 1452);
22:44:50 1913  
22:44:50 1914    -- REPLACE --
22:44:50 1915    function REPLACE(SRCSTR CLOB CHARACTER SET ANY_CS,
22:44:50 1916                     OLDSUB CLOB CHARACTER SET SRCSTR%CHARSET,
22:44:50 1917                     NEWSUB CLOB CHARACTER SET SRCSTR%CHARSET := NULL)
22:44:50 1918      return CLOB CHARACTER SET SRCSTR%CHARSET;
22:44:50 1919      pragma FIPSFLAG('REPLACE', 1452);
22:44:50 1920  
22:44:50 1921    -- LOB RELATIONAL OPERATORS --
22:44:50 1922  
22:44:50 1923    Function '='  (LEFT  CLOB CHARACTER SET ANY_CS,
22:44:50 1924                   RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1925    Function '!=' (LEFT  CLOB CHARACTER SET ANY_CS,
22:44:50 1926                   RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1927    Function '>'  (LEFT  CLOB CHARACTER SET ANY_CS,
22:44:50 1928                   RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1929    Function '<'  (LEFT  CLOB CHARACTER SET ANY_CS,
22:44:50 1930                   RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1931    Function '>=' (LEFT  CLOB CHARACTER SET ANY_CS,
22:44:50 1932                   RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1933    Function '<=' (LEFT  CLOB CHARACTER SET ANY_CS,
22:44:50 1934                   RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1935  
22:44:50 1936    Function '='  (LEFT  CLOB     CHARACTER SET ANY_CS,
22:44:50 1937                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1938    Function '!=' (LEFT  CLOB     CHARACTER SET ANY_CS,
22:44:50 1939                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1940    Function '>'  (LEFT  CLOB     CHARACTER SET ANY_CS,
22:44:50 1941                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1942    Function '<'  (LEFT  CLOB     CHARACTER SET ANY_CS,
22:44:50 1943                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1944    Function '>=' (LEFT  CLOB     CHARACTER SET ANY_CS,
22:44:50 1945                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1946    Function '<=' (LEFT  CLOB     CHARACTER SET ANY_CS,
22:44:50 1947                   RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1948  
22:44:50 1949    Function '='  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 1950                   RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1951    Function '!=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 1952                   RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1953    Function '>'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 1954                   RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1955    Function '<'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 1956                   RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1957    Function '>=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 1958                   RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1959    Function '<=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 1960                   RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
22:44:50 1961  
22:44:50 1962    /* LOB-related conversion functions */
22:44:50 1963    function TO_CLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS) return CLOB;
22:44:50 1964      pragma BUILTIN('TO_CLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
22:44:50 1965    function TO_BLOB(RIGHT RAW) return BLOB;
22:44:50 1966      pragma BUILTIN('TO_BLOB', 0, 15, 30); -- OPC_CVT_RAW2BLB
22:44:50 1967    function TO_RAW(RIGHT BLOB) return RAW;
22:44:50 1968      pragma BUILTIN('TO_RAW', 0, 15, 32); -- OPC_CVT_BLB2RAW
22:44:50 1969  
22:44:50 1970    -- ####### end of 8.2 LOB Built-in Functions  ######## --
22:44:50 1971  
22:44:50 1972    function NULLIF(v1 VARCHAR2, v2 VARCHAR2) return VARCHAR2;
22:44:50 1973    function NULLIF(v1 BOOLEAN, v2 BOOLEAN) return BOOLEAN;
22:44:50 1974    function NULLIF(a1 "<ADT_1>", a2 "<ADT_1>") return "<ADT_1>";
22:44:50 1975  
22:44:50 1976    function COALESCE return VARCHAR2;
22:44:50 1977  
22:44:50 1978    /* Daylight Saving Time Functions */
22:44:50 1979    FUNCTION tz_offset(region VARCHAR2)  RETURN VARCHAR2;
22:44:50 1980    FUNCTION from_tz(t TIMESTAMP_UNCONSTRAINED,timezone VARCHAR2)
22:44:50 1981      RETURN timestamp_tz_unconstrained;
22:44:50 1982  
22:44:50 1983    function " SYS$EXTRACT_STRING_FROM"
22:44:50 1984                (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;
22:44:50 1985    function " SYS$EXTRACT_STRING_FROM"
22:44:50 1986                (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return VARCHAR2;
22:44:50 1987    function " SYS$EXTRACT_STRING_FROM"
22:44:50 1988                (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;
22:44:50 1989  
22:44:50 1990    function INSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 1991                    STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
22:44:50 1992                    POS PLS_INTEGER := 1,
22:44:50 1993                    NTH POSITIVE := 1) return PLS_INTEGER;
22:44:50 1994      pragma FIPSFLAG('INSTR2', 1452);
22:44:50 1995  
22:44:50 1996    function INSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 1997                    STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
22:44:50 1998                    POS PLS_INTEGER := 1,
22:44:50 1999                    NTH POSITIVE := 1) return PLS_INTEGER;
22:44:50 2000      pragma FIPSFLAG('INSTR4', 1452);
22:44:50 2001  
22:44:50 2002    function INSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2003                    STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
22:44:50 2004                    POS PLS_INTEGER := 1,
22:44:50 2005                    NTH POSITIVE := 1) return PLS_INTEGER;
22:44:50 2006      pragma FIPSFLAG('INSTRC', 1452);
22:44:50 2007  
22:44:50 2008    function LENGTH2(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
22:44:50 2009      pragma FIPSFLAG('LENGTH2', 1452);
22:44:50 2010  
22:44:50 2011    function LENGTH4(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
22:44:50 2012      pragma FIPSFLAG('LENGTH4', 1452);
22:44:50 2013  
22:44:50 2014    function LENGTHC(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
22:44:50 2015      pragma FIPSFLAG('LENGTHC', 1452);
22:44:50 2016  
22:44:50 2017    function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2018                      pat VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 2019      return BOOLEAN;
22:44:50 2020    function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2021                          pat VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 2022      return BOOLEAN;
22:44:50 2023    function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2024                      pat VARCHAR2 CHARACTER SET str%CHARSET,
22:44:50 2025                      esc VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 2026      return BOOLEAN;
22:44:50 2027    function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2028                          pat VARCHAR2 CHARACTER SET str%CHARSET,
22:44:50 2029                          esc VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 2030      return BOOLEAN;
22:44:50 2031  
22:44:50 2032    function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2033                      pat VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 2034      return BOOLEAN;
22:44:50 2035    function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2036                          pat VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 2037      return BOOLEAN;
22:44:50 2038    function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2039                      pat VARCHAR2 CHARACTER SET str%CHARSET,
22:44:50 2040                      esc VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 2041      return BOOLEAN;
22:44:50 2042    function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2043                          pat VARCHAR2 CHARACTER SET str%CHARSET,
22:44:50 2044                          esc VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 2045      return BOOLEAN;
22:44:50 2046  
22:44:50 2047    function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2048                      pat VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 2049      return BOOLEAN;
22:44:50 2050    function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2051                          pat VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 2052      return BOOLEAN;
22:44:50 2053    function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2054                      pat VARCHAR2 CHARACTER SET str%CHARSET,
22:44:50 2055                      esc VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 2056      return BOOLEAN;
22:44:50 2057    function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2058                          pat VARCHAR2 CHARACTER SET str%CHARSET,
22:44:50 2059                          esc VARCHAR2 CHARACTER SET str%CHARSET)
22:44:50 2060      return BOOLEAN;
22:44:50 2061  
22:44:50 2062    function SUBSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2063                     POS PLS_INTEGER,
22:44:50 2064                     LEN PLS_INTEGER := 2147483647)
22:44:50 2065      return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 2066      pragma FIPSFLAG('SUBSTR2', 1452);
22:44:50 2067  
22:44:50 2068    function SUBSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2069                     POS PLS_INTEGER,
22:44:50 2070                     LEN PLS_INTEGER := 2147483647)
22:44:50 2071      return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 2072      pragma FIPSFLAG('SUBSTR4', 1452);
22:44:50 2073  
22:44:50 2074    function SUBSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2075                     POS PLS_INTEGER,
22:44:50 2076                     LEN PLS_INTEGER := 2147483647)
22:44:50 2077      return VARCHAR2 CHARACTER SET STR1%CHARSET;
22:44:50 2078      pragma FIPSFLAG('SUBSTRC', 1452);
22:44:50 2079  
22:44:50 2080    /**** char <--> nchar conversion functions in Unicode project ********/
22:44:50 2081  
22:44:50 2082    function TO_NCHAR(RIGHT NVARCHAR2) return NVARCHAR2;
22:44:50 2083      pragma BUILTIN('TO_NCHAR',14, 0, 2);
22:44:50 2084  
22:44:50 2085    function TO_NCLOB(cl CLOB CHARACTER SET ANY_CS) return NCLOB;
22:44:50 2086    function TO_CLOB(cl CLOB CHARACTER SET ANY_CS) return CLOB;
22:44:50 2087  
22:44:50 2088    function TO_NCLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 2089      return NCLOB;
22:44:50 2090      pragma BUILTIN('TO_NCLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
22:44:50 2091    /* convert to either CLOB or NCLOB respectively if parm is char or nchar */
22:44:50 2092    function TO_ANYLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 2093      return CLOB CHARACTER SET RIGHT%CHARSET;
22:44:50 2094      pragma BUILTIN('TO_ANYLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
22:44:50 2095  
22:44:50 2096    /* Followings are the same builtin op codes as without N prefix functions,
22:44:50 2097     * implementation relys on impilcit conversion MCODEs
22:44:50 2098     */
22:44:50 2099    function TO_NCHAR (LEFT DATE, FORMAT NVARCHAR2) return NVARCHAR2;
22:44:50 2100      pragma BUILTIN('TO_NCHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
22:44:50 2101      pragma FIPSFLAG('TO_NCHAR', 1450);
22:44:50 2102    function TO_NCHAR (LEFT NUMBER, FORMAT NVARCHAR2) return NVARCHAR2;
22:44:50 2103      pragma BUILTIN('TO_NCHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR
22:44:50 2104  
22:44:50 2105    function NHEXTORAW (c NVARCHAR2) return RAW;
22:44:50 2106      pragma builtin('NHEXTORAW', 1, 23, 1);
22:44:50 2107    function RAWTONHEX (r RAW) return NVARCHAR2;
22:44:50 2108      pragma builtin('RAWTONHEX', 1, 23, 2);
22:44:50 2109    function NCHARTOROWID (str NVARCHAR2) return ROWID;
22:44:50 2110      pragma builtin('NCHARTOROWID', 1, 0, 1);
22:44:50 2111    function ROWIDTONCHAR (str ROWID) return NVARCHAR2;
22:44:50 2112      pragma builtin('ROWIDTONCHAR', 1, 0, 1);
22:44:50 2113  
22:44:50 2114    function NCHR(n integer) return NVARCHAR2;
22:44:50 2115  
22:44:50 2116    /* implemented by icd calls as the same as TO_CHAR */
22:44:50 2117    function TO_NCHAR(left date, format nvarchar2, parms nvarchar2)
22:44:50 2118      return nvarchar2;
22:44:50 2119    function TO_NCHAR(left number, format nvarchar2, parms nvarchar2)
22:44:50 2120      return nvarchar2;
22:44:50 2121  
22:44:50 2122    /* implemented as a icd call, return TRUE if nchar, otherwise FALSE */
22:44:50 2123    function ISNCHAR(c VARCHAR2 character set any_cs) return boolean;
22:44:50 2124  
22:44:50 2125    /************ end of char <--> nchar conversion functions ************/
22:44:50 2126  
22:44:50 2127    /* Create overloads for all standard functions that work with <ADT_1> for
22:44:50 2128       <OPAQUE_1> */
22:44:50 2129    function '='  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2130      pragma BUILTIN('=', 1, 1, 1);
22:44:50 2131      pragma FIPSFLAG('=', 1450);
22:44:50 2132    function '!=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2133      pragma BUILTIN('!=', 1, 1, 1);
22:44:50 2134      pragma FIPSFLAG('!=', 1450);
22:44:50 2135    function '<'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2136      pragma BUILTIN('<', 1, 1, 1);
22:44:50 2137      pragma FIPSFLAG('<', 1450);
22:44:50 2138    function '<=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2139      pragma BUILTIN('<=', 1, 1, 1);
22:44:50 2140      pragma FIPSFLAG('<=', 1450);
22:44:50 2141    function '>'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2142      pragma BUILTIN('>', 1, 1, 1);
22:44:50 2143      pragma FIPSFLAG('>', 1450);
22:44:50 2144    function '>=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2145      pragma BUILTIN('>=', 1, 1, 1);
22:44:50 2146      pragma FIPSFLAG('>=', 1450);
22:44:50 2147  
22:44:50 2148    function '=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2149    function '!=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2150    function '<ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2151    function '<=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2152    function '>ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2153    function '>=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2154    function '=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2155    function '!=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2156    function '<ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2157    function '<=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2158    function '>ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2159    function '>=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2160    function '=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2161    function '!=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2162    function '<SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2163    function '<=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2164    function '>SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2165    function '>=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
22:44:50 2166  
22:44:50 2167    -- Outer Join
22:44:50 2168    function '(+)'  ( colname "<OPAQUE_1>") return "<OPAQUE_1>";
22:44:50 2169      pragma FIPSFLAG('(+)', 1450);
22:44:50 2170  
22:44:50 2171    --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
22:44:50 2172    --  function GREATEST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
22:44:50 2173    --    pragma BUILTIN('GREATEST', 1, 1, 1);
22:44:50 2174  
22:44:50 2175    --  function LEAST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
22:44:50 2176    --    pragma BUILTIN('LEAST', 1, 1, 1);
22:44:50 2177  
22:44:50 2178    function DECODE (expr "<OPAQUE_1>", pat "<OPAQUE_1>", res "<OPAQUE_1>")
22:44:50 2179      return "<OPAQUE_1>";
22:44:50 2180      pragma BUILTIN('DECODE', 1, 1, 1);
22:44:50 2181  
22:44:50 2182    function 'IS NULL' (B "<OPAQUE_1>") return BOOLEAN;
22:44:50 2183      pragma BUILTIN('IS NULL', 0, 3, 0);
22:44:50 2184      pragma FIPSFLAG('IS NULL', 1450);
22:44:50 2185  
22:44:50 2186    function 'IS NOT NULL' (B "<OPAQUE_1>") return BOOLEAN;
22:44:50 2187      pragma BUILTIN('IS NOT NULL', 0, 3, 50);
22:44:50 2188      pragma FIPSFLAG('IS NOT NULL', 1450);
22:44:50 2189  
22:44:50 2190    function NVL (B1 "<OPAQUE_1>", B2 "<OPAQUE_1>") return "<OPAQUE_1>";
22:44:50 2191      pragma FIPSFLAG('NVL', 1450);
22:44:50 2192  
22:44:50 2193    --  REFs to opaques are not supported yet.
22:44:50 2194    --  function VALUE (item "<ADT_WITH_OID>") return "<OPAQUE_1>";
22:44:50 2195    --    pragma BUILTIN('VALUE', 1, 1, 1);
22:44:50 2196    --    pragma FIPSFLAG('VALUE', 1450);
22:44:50 2197  
22:44:50 2198    --  function REF (item "<ADT_WITH_OID>") return REF "<OPAQUE_1>";
22:44:50 2199    --    pragma BUILTIN('REF', 1, 1, 1);
22:44:50 2200    --    pragma FIPSFLAG('REF', 1450);
22:44:50 2201  
22:44:50 2202    --  function DEREF (r REF "<OPAQUE_1>") return "<OPAQUE_1>";
22:44:50 2203    --    pragma BUILTIN('DEREF', 1, 1, 1);
22:44:50 2204    --    pragma FIPSFLAG('DEREF', 1450);
22:44:50 2205  
22:44:50 2206    -- overloadings for REF OPAQUE
22:44:50 2207  
22:44:50 2208    --  function 'IS NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
22:44:50 2209    --    pragma BUILTIN('IS NULL', 0, 3, 0);
22:44:50 2210    --    pragma FIPSFLAG('IS NULL', 1450);
22:44:50 2211  
22:44:50 2212    --  function 'IS NOT NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
22:44:50 2213    --    pragma FIPSFLAG('IS NOT NULL', 1450);
22:44:50 2214  
22:44:50 2215    --  function 'IS DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
22:44:50 2216    --    pragma BUILTIN('IS DANGLING', 1, 1, 1);
22:44:50 2217    --    pragma FIPSFLAG('IS DANGLING', 1450);
22:44:50 2218  
22:44:50 2219    --  function 'IS NOT DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
22:44:50 2220    --    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
22:44:50 2221    --    pragma FIPSFLAG('IS NOT DANGLING', 1450);
22:44:50 2222  
22:44:50 2223    --  function NVL (B1 REF "<OPAQUE_1>", B2 REF "<OPAQUE_1>")
22:44:50 2224    --    return REF "<OPAQUE_1>";
22:44:50 2225    --    pragma FIPSFLAG('NVL', 1450);
22:44:50 2226  
22:44:50 2227    --  function '='  (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
22:44:50 2228    --    return BOOLEAN;
22:44:50 2229    --    pragma BUILTIN('=', 0, 3, 1);
22:44:50 2230    --    pragma FIPSFLAG('=', 1450);
22:44:50 2231  
22:44:50 2232    --  function '!=' (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
22:44:50 2233    --    return BOOLEAN;
22:44:50 2234    --    pragma BUILTIN('!=', 0, 3, 2);
22:44:50 2235    --    pragma FIPSFLAG('!=', 1450);
22:44:50 2236  
22:44:50 2237    function GROUPING(a "<OPAQUE_1>") return NUMBER;
22:44:50 2238    function NULLIF(a1 "<OPAQUE_1>", a2 "<OPAQUE_1>") RETURN "<OPAQUE_1>";
22:44:50 2239  
22:44:50 2240    function GREATEST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
22:44:50 2241      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2242    function GREATEST (pattern TIME_TZ_UNCONSTRAINED)
22:44:50 2243      return TIME_TZ_UNCONSTRAINED;
22:44:50 2244      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2245    function GREATEST (pattern TIMESTAMP_UNCONSTRAINED)
22:44:50 2246      return TIMESTAMP_UNCONSTRAINED;
22:44:50 2247      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2248    function GREATEST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
22:44:50 2249      return TIMESTAMP_TZ_UNCONSTRAINED;
22:44:50 2250      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2251    function GREATEST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
22:44:50 2252      return TIMESTAMP_LTZ_UNCONSTRAINED;
22:44:50 2253      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2254    function GREATEST (pattern YMINTERVAL_UNCONSTRAINED)
22:44:50 2255      return YMINTERVAL_UNCONSTRAINED;
22:44:50 2256      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2257    function GREATEST (pattern DSINTERVAL_UNCONSTRAINED)
22:44:50 2258      return DSINTERVAL_UNCONSTRAINED;
22:44:50 2259      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2260  
22:44:50 2261    function LEAST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
22:44:50 2262      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2263    function LEAST (pattern TIME_TZ_UNCONSTRAINED) return TIME_TZ_UNCONSTRAINED;
22:44:50 2264      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2265    function LEAST (pattern TIMESTAMP_UNCONSTRAINED)
22:44:50 2266      return TIMESTAMP_UNCONSTRAINED;
22:44:50 2267      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2268    function LEAST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
22:44:50 2269      return TIMESTAMP_TZ_UNCONSTRAINED;
22:44:50 2270      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2271    function LEAST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
22:44:50 2272      return TIMESTAMP_LTZ_UNCONSTRAINED;
22:44:50 2273      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2274    function LEAST (pattern YMINTERVAL_UNCONSTRAINED)
22:44:50 2275      return YMINTERVAL_UNCONSTRAINED;
22:44:50 2276      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2277    function LEAST (pattern DSINTERVAL_UNCONSTRAINED)
22:44:50 2278      return DSINTERVAL_UNCONSTRAINED;
22:44:50 2279      pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
22:44:50 2280  
22:44:50 2281    function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2,
22:44:50 2282                     parms VARCHAR2) return VARCHAR2;
22:44:50 2283    function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2) return VARCHAR2;
22:44:50 2284    function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2,
22:44:50 2285                     parms VARCHAR2) return VARCHAR2;
22:44:50 2286    function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2)
22:44:50 2287      return VARCHAR2;
22:44:50 2288    function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2,
22:44:50 2289                     parms VARCHAR2) return VARCHAR2;
22:44:50 2290    function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2)
22:44:50 2291      return VARCHAR2;
22:44:50 2292    function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2,
22:44:50 2293                     parms VARCHAR2) return VARCHAR2;
22:44:50 2294    function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2)
22:44:50 2295      return VARCHAR2;
22:44:50 2296    function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2,
22:44:50 2297                     parms VARCHAR2) return VARCHAR2;
22:44:50 2298    function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2)
22:44:50 2299      return VARCHAR2;
22:44:50 2300    function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2,
22:44:50 2301                     parms VARCHAR2) return VARCHAR2;
22:44:50 2302    function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2)
22:44:50 2303      return VARCHAR2;
22:44:50 2304    function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2,
22:44:50 2305                     parms VARCHAR2) return VARCHAR2;
22:44:50 2306    function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2)
22:44:50 2307      return VARCHAR2;
22:44:50 2308  
22:44:50 2309    -- CONVERT FOR LOB --
22:44:50 2310    function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
22:44:50 2311                     DSTCSN VARCHAR2)
22:44:50 2312      return CLOB CHARACTER SET SRCSTR%CHARSET;
22:44:50 2313    function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
22:44:50 2314                     DSTCSN VARCHAR2,
22:44:50 2315                     SRCCSN VARCHAR2)
22:44:50 2316      return CLOB CHARACTER SET SRCSTR%CHARSET;
22:44:50 2317  
22:44:50 2318    -- NLS_UPPER/NLS_LOWER FOR LOB --
22:44:50 2319    function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS,
22:44:50 2320                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
22:44:50 2321      return CLOB CHARACTER SET ch%CHARSET;
22:44:50 2322      pragma FIPSFLAG('NLS_UPPER', 1452);
22:44:50 2323    function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS)
22:44:50 2324      return CLOB CHARACTER SET ch%CHARSET;
22:44:50 2325      pragma FIPSFLAG('NLS_UPPER', 1452);
22:44:50 2326    function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS,
22:44:50 2327                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
22:44:50 2328      return CLOB CHARACTER SET ch%CHARSET;
22:44:50 2329      pragma FIPSFLAG('NLS_LOWER', 1452);
22:44:50 2330    function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS)
22:44:50 2331      return CLOB CHARACTER SET ch%CHARSET;
22:44:50 2332      pragma FIPSFLAG('NLS_LOWER', 1452);
22:44:50 2333  
22:44:50 2334    function COMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:50 2335      return varchar2 character set ch%charset;
22:44:50 2336      pragma FIPSFLAG('COMPOSE', 1452);
22:44:50 2337    function DECOMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2338                       canmode in VARCHAR2 DEFAULT 'CANONICAL')
22:44:50 2339      return varchar2 character set ch%charset;
22:44:50 2340      pragma FIPSFLAG('DECOMPOSE', 1452);
22:44:50 2341    FUNCTION SYS_EXTRACT_UTC(t timestamp_tz_unconstrained)
22:44:50 2342      return TIMESTAMP_UNCONSTRAINED;
22:44:50 2343  
22:44:50 2344    -- Begin REGEXP Support (10iR1) --
22:44:50 2345  
22:44:50 2346    -- REGEXP_LIKE --
22:44:50 2347    function REGEXP_LIKE (srcstr   VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2348                          pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
22:44:50 2349                          modifier VARCHAR2 DEFAULT NULL)
22:44:50 2350      return BOOLEAN;
22:44:50 2351      pragma FIPSFLAG('REGEXP_LIKE', 1452);
22:44:50 2352  
22:44:50 2353    function REGEXP_LIKE (srcstr   CLOB CHARACTER SET ANY_CS,
22:44:50 2354                          pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
22:44:50 2355                          modifier VARCHAR2 DEFAULT NULL)
22:44:50 2356      return BOOLEAN;
22:44:50 2357      pragma FIPSFLAG('REGEXP_LIKE', 1452);
22:44:50 2358  
22:44:50 2359    -- REGEXP_INSTR --
22:44:50 2360    function REGEXP_INSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2361                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
22:44:50 2362                          position    PLS_INTEGER := 1,
22:44:50 2363                          occurrence  PLS_INTEGER := 1,
22:44:50 2364                          returnparam PLS_INTEGER := 0,
22:44:50 2365                          modifier    VARCHAR2 DEFAULT NULL,
22:44:50 2366                          subexpression PLS_INTEGER := 0)
22:44:50 2367      return PLS_INTEGER;
22:44:50 2368      pragma FIPSFLAG('REGEXP_INSTR', 1452);
22:44:50 2369  
22:44:50 2370    function REGEXP_INSTR(srcstr      CLOB CHARACTER SET ANY_CS,
22:44:50 2371                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
22:44:50 2372                          position    INTEGER := 1,
22:44:50 2373                          occurrence  INTEGER := 1,
22:44:50 2374                          returnparam PLS_INTEGER := 0,
22:44:50 2375                          modifier    VARCHAR2 DEFAULT NULL,
22:44:50 2376                          subexpression PLS_INTEGER := 0)
22:44:50 2377      return INTEGER;
22:44:50 2378      pragma FIPSFLAG('REGEXP_INSTR', 1452);
22:44:50 2379  
22:44:50 2380  
22:44:50 2381    -- REGEXP_SUBSTR --
22:44:50 2382    function REGEXP_SUBSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2383                           pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
22:44:50 2384                           position    PLS_INTEGER := 1,
22:44:50 2385                           occurrence  PLS_INTEGER := 1,
22:44:50 2386                           modifier    VARCHAR2 DEFAULT NULL,
22:44:50 2387                           subexpression PLS_INTEGER := 0)
22:44:50 2388      return VARCHAR2 CHARACTER SET srcstr%CHARSET;
22:44:50 2389      pragma FIPSFLAG('REGEXP_SUBSTR', 1452);
22:44:50 2390  
22:44:50 2391    function REGEXP_SUBSTR(srcstr      CLOB CHARACTER SET ANY_CS,
22:44:50 2392                           pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
22:44:50 2393                           position    INTEGER := 1,
22:44:50 2394                           occurrence  INTEGER := 1,
22:44:50 2395                           modifier    VARCHAR2 DEFAULT NULL,
22:44:50 2396                           subexpression PLS_INTEGER := 0)
22:44:50 2397      return CLOB CHARACTER SET srcstr%CHARSET;
22:44:50 2398      pragma FIPSFLAG('REGEXP_SUBSTR', 1452);
22:44:50 2399  
22:44:50 2400    -- REGEXP_REPLACE --
22:44:50 2401    function REGEXP_REPLACE(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2402                            pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
22:44:50 2403                            replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
22:44:50 2404                                          DEFAULT NULL,
22:44:50 2405                            position    PLS_INTEGER := 1,
22:44:50 2406                            occurrence  PLS_INTEGER := 0,
22:44:50 2407                            modifier    VARCHAR2 DEFAULT NULL)
22:44:50 2408      return VARCHAR2 CHARACTER SET srcstr%CHARSET;
22:44:50 2409      pragma FIPSFLAG('REGEXP_REPLACE', 1452);
22:44:50 2410  
22:44:50 2411    function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
22:44:50 2412                            pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
22:44:50 2413                            replacestr  CLOB CHARACTER SET srcstr%CHARSET
22:44:50 2414                                          DEFAULT NULL,
22:44:50 2415                            position    INTEGER := 1,
22:44:50 2416                            occurrence  INTEGER := 0,
22:44:50 2417                            modifier    VARCHAR2 DEFAULT NULL)
22:44:50 2418      return CLOB CHARACTER SET srcstr%CHARSET;
22:44:50 2419      pragma FIPSFLAG('REGEXP_REPLACE', 1452);
22:44:50 2420  
22:44:50 2421    function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
22:44:50 2422                            pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
22:44:50 2423                            replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
22:44:50 2424                                          DEFAULT NULL,
22:44:50 2425                            position    INTEGER := 1,
22:44:50 2426                            occurrence  INTEGER := 0,
22:44:50 2427                            modifier    VARCHAR2 DEFAULT NULL)
22:44:50 2428      return CLOB CHARACTER SET srcstr%CHARSET;
22:44:50 2429      pragma FIPSFLAG('REGEXP_REPLACE', 1452);
22:44:50 2430  
22:44:50 2431    -- End REGEXP Support --
22:44:50 2432  
22:44:50 2433    -- binary_float and binary_double functions and operators.
22:44:50 2434    function TO_BINARY_FLOAT (RIGHT BINARY_FLOAT) RETURN BINARY_FLOAT;
22:44:50 2435      pragma BUILTIN('TO_BINARY_FLOAT',14, 0, 1); -- PEMS_QUICK
22:44:50 2436    function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2437                       FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 2438      RETURN BINARY_FLOAT;
22:44:50 2439    function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2440                       FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
22:44:50 2441                       PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 2442      RETURN BINARY_FLOAT;
22:44:50 2443  
22:44:50 2444    function TO_BINARY_DOUBLE (RIGHT BINARY_DOUBLE) RETURN BINARY_DOUBLE;
22:44:50 2445      pragma BUILTIN('TO_BINARY_DOUBLE',14, 0, 1); -- PEMS_QUICK
22:44:50 2446    function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2447                       FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 2448      RETURN BINARY_DOUBLE;
22:44:50 2449    function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2450                       FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
22:44:50 2451                       PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
22:44:50 2452      RETURN BINARY_DOUBLE;
22:44:50 2453  
22:44:50 2454    function 'IS NAN' (N NUMBER) RETURN BOOLEAN;
22:44:50 2455    function 'IS NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
22:44:50 2456    function 'IS NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
22:44:50 2457    function 'IS INFINITE' (N NUMBER) RETURN BOOLEAN;
22:44:50 2458    function 'IS INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
22:44:50 2459    function 'IS INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;
22:44:50 2460    function 'IS NOT NAN' (N NUMBER) RETURN BOOLEAN;
22:44:50 2461    function 'IS NOT NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
22:44:50 2462    function 'IS NOT NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
22:44:50 2463    function 'IS NOT INFINITE' (N NUMBER) RETURN BOOLEAN;
22:44:50 2464    function 'IS NOT INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
22:44:50 2465    function 'IS NOT INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;
22:44:50 2466  
22:44:50 2467    function TO_CHAR (left binary_float, format varchar2)
22:44:50 2468      return VARCHAR2;
22:44:50 2469    function TO_CHAR (left binary_double, format varchar2)
22:44:50 2470      return VARCHAR2;
22:44:50 2471  
22:44:50 2472    function TO_CHAR(left binary_float, format varchar2, parms varchar2)
22:44:50 2473      return varchar2;
22:44:50 2474    function TO_CHAR(left binary_double, format varchar2, parms varchar2)
22:44:50 2475      return varchar2;
22:44:50 2476  
22:44:50 2477    function TO_NCHAR(left binary_float, format nvarchar2) return NVARCHAR2;
22:44:50 2478    function TO_NCHAR(left binary_double, format nvarchar2) return NVARCHAR2;
22:44:50 2479  
22:44:50 2480    function TO_NCHAR(left binary_float, format nvarchar2, parms nvarchar2)
22:44:50 2481      return nvarchar2;
22:44:50 2482    function TO_NCHAR(left binary_double, format nvarchar2, parms nvarchar2)
22:44:50 2483      return nvarchar2;
22:44:50 2484  
22:44:50 2485    function 'REMAINDER'(n1 NUMBER, n2 NUMBER) return NUMBER;
22:44:50 2486      pragma FIPSFLAG('REMAINDER', 1452);
22:44:50 2487    function REMAINDER(n1 NUMBER, n2 NUMBER) return NUMBER;
22:44:50 2488      pragma FIPSFLAG(REMAINDER, 1452);
22:44:50 2489    function 'REMAINDER'(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2490      pragma FIPSFLAG('REMAINDER', 1452);
22:44:50 2491    function REMAINDER(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2492      pragma FIPSFLAG(REMAINDER, 1452);
22:44:50 2493    function 'REMAINDER'(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2494      pragma FIPSFLAG('REMAINDER', 1452);
22:44:50 2495    function REMAINDER(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2496      pragma FIPSFLAG(REMAINDER, 1452);
22:44:50 2497  
22:44:50 2498    function '='  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
22:44:50 2499      pragma BUILTIN('=',2, 2, 15);
22:44:50 2500    function '!=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
22:44:50 2501      pragma BUILTIN('!=',5, 2, 16);
22:44:50 2502      pragma FIPSFLAG('!=', 1452);
22:44:50 2503    function '<'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
22:44:50 2504      pragma BUILTIN('<',4, 2, 17);
22:44:50 2505    function '<=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
22:44:50 2506      pragma BUILTIN('<=',6, 2, 18);
22:44:50 2507    function '>'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
22:44:50 2508      pragma BUILTIN('>',1, 2, 19);
22:44:50 2509    function '>=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
22:44:50 2510      pragma BUILTIN('>=',3, 2, 20);
22:44:50 2511  
22:44:50 2512    function 'IS NULL' (n BINARY_FLOAT) return BOOLEAN;
22:44:50 2513      pragma BUILTIN('IS NULL', 0, 2, 0);
22:44:50 2514    function 'IS NOT NULL' (n BINARY_FLOAT) return BOOLEAN;
22:44:50 2515      pragma BUILTIN('IS NOT NULL', 0, 2, 50);
22:44:50 2516  
22:44:50 2517    function NVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2518      pragma FIPSFLAG('NVL', 1452);
22:44:50 2519  
22:44:50 2520    function '+' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2521      pragma BUILTIN('+',14, 0, 1);
22:44:50 2522    function '-' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2523      pragma BUILTIN('-',15, 2, 23);
22:44:50 2524    function ABS(F BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2525      pragma FIPSFLAG('ABS', 1452);
22:44:50 2526  
22:44:50 2527    function '+' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2528      pragma BUILTIN('+',14, 2, 24);
22:44:50 2529    function '-' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2530      pragma BUILTIN('-',15, 2, 25);
22:44:50 2531    function '*' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2532      pragma BUILTIN('*',17, 2, 26);
22:44:50 2533    function '/' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2534      pragma BUILTIN('/',18, 2, 27);
22:44:50 2535  
22:44:50 2536    function 'REM' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2537      pragma FIPSFLAG('REM', 1452);
22:44:50 2538    function 'MOD'(F1 BINARY_FLOAT, F2 BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2539      pragma FIPSFLAG('MOD', 1452);
22:44:50 2540  
22:44:50 2541    function FLOOR(F BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2542      pragma FIPSFLAG('FLOOR', 1452);
22:44:50 2543    function CEIL(F BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2544      pragma FIPSFLAG('CEIL', 1452);
22:44:50 2545    function SIGN(f BINARY_FLOAT) return SIGNTYPE;
22:44:50 2546      pragma FIPSFLAG('SIGN', 1452);
22:44:50 2547    function SQRT(f BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2548      pragma FIPSFLAG('SQRT', 1452);
22:44:50 2549  
22:44:50 2550    function TRUNC (F BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2551      pragma FIPSFLAG('TRUNC', 1452);
22:44:50 2552  
22:44:50 2553    function ROUND (LEFT BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2554      pragma FIPSFLAG('ROUND', 1452);
22:44:50 2555  
22:44:50 2556    function '='  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
22:44:50 2557      pragma BUILTIN('=',2, 2, 28);
22:44:50 2558    function '!=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
22:44:50 2559      -- also <> and ~=
22:44:50 2560      pragma BUILTIN('!=',5, 2, 29);
22:44:50 2561      pragma FIPSFLAG('!=', 1452);
22:44:50 2562    function '<'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
22:44:50 2563      pragma BUILTIN('<',4, 2, 30);
22:44:50 2564    function '<=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
22:44:50 2565      pragma BUILTIN('<=',6, 2, 31);
22:44:50 2566    function '>'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
22:44:50 2567      pragma BUILTIN('>',1, 2, 32);
22:44:50 2568    function '>=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
22:44:50 2569      pragma BUILTIN('>=',3, 2, 33);
22:44:50 2570  
22:44:50 2571    function 'IS NULL' (n BINARY_DOUBLE) return BOOLEAN;
22:44:50 2572      pragma BUILTIN('IS NULL', 0, 2, 0);
22:44:50 2573    function 'IS NOT NULL' (n BINARY_DOUBLE) return BOOLEAN;
22:44:50 2574      pragma BUILTIN('IS NOT NULL', 0, 2, 50);
22:44:50 2575  
22:44:50 2576    function NVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2577      pragma FIPSFLAG('NVL', 1452);
22:44:50 2578  
22:44:50 2579    function '+' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2580      pragma BUILTIN('+',14, 0, 1);
22:44:50 2581    function '-' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2582      pragma BUILTIN('-',15, 2, 36);
22:44:50 2583    function ABS(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2584      pragma FIPSFLAG('ABS', 1452);
22:44:50 2585  
22:44:50 2586    function ACOS(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2587      pragma FIPSFLAG('ACOS', 1452);
22:44:50 2588  
22:44:50 2589    function ASIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2590      pragma FIPSFLAG('ASIN', 1452);
22:44:50 2591  
22:44:50 2592    function ATAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2593      pragma FIPSFLAG('ATAN', 1452);
22:44:50 2594  
22:44:50 2595    function ATAN2(x BINARY_DOUBLE, y BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2596      pragma FIPSFLAG('ATAN2', 1452);
22:44:50 2597  
22:44:50 2598    function '+' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2599      pragma BUILTIN('+',14, 2, 37);
22:44:50 2600    function '-' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2601      pragma BUILTIN('-',15, 2, 38);
22:44:50 2602    function '*' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2603      pragma BUILTIN('*',17, 2, 39);
22:44:50 2604    function '/' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2605      pragma BUILTIN('/',18, 2, 40);
22:44:50 2606  
22:44:50 2607    function 'REM' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
22:44:50 2608      return BINARY_DOUBLE;
22:44:50 2609      pragma FIPSFLAG('REM', 1452);
22:44:50 2610    function 'MOD'(D1 BINARY_DOUBLE, D2 BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2611      pragma FIPSFLAG('MOD', 1452);
22:44:50 2612  
22:44:50 2613    function '**' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
22:44:50 2614      return BINARY_DOUBLE;
22:44:50 2615      pragma FIPSFLAG('**', 1452);
22:44:50 2616  
22:44:50 2617    function FLOOR(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2618      pragma FIPSFLAG('FLOOR', 1452);
22:44:50 2619    function CEIL(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2620      pragma FIPSFLAG('CEIL', 1452);
22:44:50 2621    function SQRT(d BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2622      pragma FIPSFLAG('SQRT', 1452);
22:44:50 2623    function SIGN(d BINARY_DOUBLE) return SIGNTYPE;
22:44:50 2624    pragma FIPSFLAG('SIGN', 1452);
22:44:50 2625  
22:44:50 2626    function COS(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2627    function SIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2628    function TAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2629    function COSH(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2630    function SINH(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2631    function TANH(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2632    function EXP(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2633    function LN(D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2634  
22:44:50 2635    function LOG (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2636  
22:44:50 2637    function TRUNC (D BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2638      pragma FIPSFLAG('TRUNC', 1452);
22:44:50 2639  
22:44:50 2640    function ROUND (LEFT BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2641      pragma FIPSFLAG('ROUND', 1452);
22:44:50 2642  
22:44:50 2643    function POWER (d BINARY_DOUBLE, e BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2644      pragma FIPSFLAG('POWER', 1452);
22:44:50 2645  
22:44:50 2646    function NANVL(n1 NUMBER, n2 NUMBER) return NUMBER;
22:44:50 2647    function NANVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2648    function NANVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2649  
22:44:50 2650    function GREATEST (pattern BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2651      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
22:44:50 2652    function GREATEST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2653      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
22:44:50 2654    function LEAST (pattern BINARY_FLOAT) return BINARY_FLOAT;
22:44:50 2655      pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
22:44:50 2656    function LEAST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
22:44:50 2657      pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
22:44:50 2658  
22:44:50 2659  
22:44:50 2660    function '+' (RIGHT PLS_INTEGER) return PLS_INTEGER;
22:44:50 2661      pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
22:44:50 2662    function '-' (RIGHT PLS_INTEGER) return PLS_INTEGER;
22:44:50 2663      pragma BUILTIN('-',15, 2, 41);
22:44:50 2664    function ABS(I PLS_INTEGER) return PLS_INTEGER;
22:44:50 2665      pragma FIPSFLAG('ABS', 1452);
22:44:50 2666  
22:44:50 2667    function '+' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
22:44:50 2668      pragma BUILTIN('+',14, 2, 42);
22:44:50 2669    function '-' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
22:44:50 2670      pragma BUILTIN('-',14, 2, 43);
22:44:50 2671    function '*' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
22:44:50 2672      pragma BUILTIN('*',14, 2, 44);
22:44:50 2673  
22:44:50 2674    function '='  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
22:44:50 2675      pragma BUILTIN('=',2, 2, 45); -- PEMS_PLS_INTEGER, PEMDCMEQ
22:44:50 2676    function '!=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
22:44:50 2677      -- also <> and ~=
22:44:50 2678      pragma BUILTIN('!=',5, 2, 46); -- PEMS_PLS_INTEGER, PEMDCMNE
22:44:50 2679      pragma FIPSFLAG('!=', 1452);
22:44:50 2680    function '<'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
22:44:50 2681      pragma BUILTIN('<',4, 2, 47); -- PEMS_PLS_INTEGER, PEMDCMLT
22:44:50 2682    function '<=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
22:44:50 2683      pragma BUILTIN('<=',6, 2, 48); -- PEMS_PLS_INTEGER, PEMDCMLE
22:44:50 2684    function '>'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
22:44:50 2685      pragma BUILTIN('>',1, 2, 49); -- PEMS_PLS_INTEGER, PEMDCMGT
22:44:50 2686    function '>=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
22:44:50 2687      pragma BUILTIN('>=',3, 2, 51); -- PEMS_PLS_INTEGER, PEMDCMGE
22:44:50 2688  
22:44:50 2689    function 'IS NULL' (I PLS_INTEGER) return BOOLEAN;
22:44:50 2690      pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_PLS_INTEGER, PEMDNUL
22:44:50 2691    function 'IS NOT NULL' (I PLS_INTEGER) return BOOLEAN;
22:44:50 2692      pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_PLS_INTEGER, PEMDNUL
22:44:50 2693  
22:44:50 2694    function NVL(I1 PLS_INTEGER, I2 PLS_INTEGER) return PLS_INTEGER;
22:44:50 2695      pragma FIPSFLAG('NVL', 1452);
22:44:50 2696  
22:44:50 2697    function TRUNC (i pls_integer, places pls_integer := 0) return pls_integer;
22:44:50 2698      pragma FIPSFLAG('TRUNC', 1452);
22:44:50 2699  
22:44:50 2700    function ROUND (i pls_integer, places pls_integer := 0) return pls_integer;
22:44:50 2701      pragma FIPSFLAG('ROUND', 1452);
22:44:50 2702  
22:44:50 2703    function SIGN(i PLS_INTEGER) return SIGNTYPE;
22:44:50 2704      pragma FIPSFLAG('SIGN', 1452);
22:44:50 2705  
22:44:50 2706    function GREATEST (pattern PLS_INTEGER) return PLS_INTEGER;
22:44:50 2707      pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
22:44:50 2708    function LEAST (pattern PLS_INTEGER) return PLS_INTEGER;
22:44:50 2709      pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
22:44:50 2710  
22:44:50 2711    -- MultiSet Functions and Operators.
22:44:50 2712  
22:44:50 2713    -- Equality
22:44:50 2714    function '='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
22:44:50 2715      return BOOLEAN;
22:44:50 2716        pragma BUILTIN('=',2, 16, 1);
22:44:50 2717  
22:44:50 2718    function '!='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
22:44:50 2719      return BOOLEAN;
22:44:50 2720        pragma BUILTIN('!=',2, 16, 2);
22:44:50 2721  
22:44:50 2722    function CARDINALITY (collection IN "<TABLE_1>") return PLS_INTEGER;
22:44:50 2723  
22:44:50 2724    function SET (collection IN "<TABLE_1>") return "<TABLE_1>";
22:44:50 2725      pragma BUILTIN('SET',18, 5, 40);-- Dummy
22:44:50 2726  
22:44:50 2727    function 'IS A SET' (collection IN  "<TABLE_1>") return BOOLEAN;
22:44:50 2728      pragma BUILTIN('IS A SET',18, 5, 41);-- Dummy
22:44:50 2729    function 'IS NOT A SET'(collection IN  "<TABLE_1>") return BOOLEAN;
22:44:50 2730      pragma BUILTIN('IS NOT A SET',18, 5, 42);-- Dummy
22:44:50 2731  
22:44:50 2732    function 'IS EMPTY' (collection IN  "<TABLE_1>") return BOOLEAN;
22:44:50 2733    function 'IS NOT EMPTY'(collection IN  "<TABLE_1>") return BOOLEAN;
22:44:50 2734  
22:44:50 2735    -- IS A SUBMULTISET OF
22:44:50 2736    function 'SUBMULTISET' (collection IN  "<TABLE_1>",
22:44:50 2737                            collection2 IN "<TABLE_1>")
22:44:50 2738      return BOOLEAN;
22:44:50 2739        pragma BUILTIN('SUBMULTISET',18, 5, 43);
22:44:50 2740  
22:44:50 2741    function 'MULTISET_UNION_ALL' (collection IN  "<TABLE_1>",
22:44:50 2742                                   collection2 IN "<TABLE_1>")
22:44:50 2743      return "<TABLE_1>";
22:44:50 2744        pragma BUILTIN('MULTISET_UNION_ALL',18, 5, 44);
22:44:50 2745  
22:44:50 2746    function 'MULTISET_UNION_DISTINCT' (collection IN  "<TABLE_1>",
22:44:50 2747                                        collection2 IN "<TABLE_1>")
22:44:50 2748      return "<TABLE_1>";
22:44:50 2749      pragma BUILTIN('MULTISET_UNION_DISTINCT',18, 5, 45);-- Dummy
22:44:50 2750  
22:44:50 2751    function 'MULTISET_EXCEPT_ALL' (collection IN  "<TABLE_1>",
22:44:50 2752                                   collection2 IN "<TABLE_1>")
22:44:50 2753      return "<TABLE_1>";
22:44:50 2754      pragma BUILTIN('MULTISET_EXCEPT_ALL',18, 5, 46);-- Dummy
22:44:50 2755  
22:44:50 2756    function 'MULTISET_EXCEPT_DISTINCT' (collection IN  "<TABLE_1>",
22:44:50 2757                                        collection2 IN "<TABLE_1>")
22:44:50 2758      return "<TABLE_1>";
22:44:50 2759      pragma BUILTIN('MULTISET_EXCEPT_DISTINCT',18, 5, 47);-- Dummy
22:44:50 2760  
22:44:50 2761    function 'MULTISET_INTERSECT_ALL' (collection IN  "<TABLE_1>",
22:44:50 2762                                   collection2 IN "<TABLE_1>")
22:44:50 2763      return "<TABLE_1>";
22:44:50 2764      pragma BUILTIN('MULTISET_INTERSECT_ALL',18, 5, 48);-- Dummy
22:44:50 2765  
22:44:50 2766    function 'MULTISET_INTERSECT_DISTINCT' (collection IN  "<TABLE_1>",
22:44:50 2767                                        collection2 IN "<TABLE_1>")
22:44:50 2768      return "<TABLE_1>";
22:44:50 2769      pragma BUILTIN('MULTISET_INTERSECT_DISTINCT',18, 5, 49);-- Dummy
22:44:50 2770  
22:44:50 2771    -- These are dummy procedures for correct management of new control
22:44:50 2772    -- statements added to PL/SQL. They ensure local procedures which have the
22:44:50 2773    -- same names as newly introduced keywords are not masked by those keywords.
22:44:50 2774  
22:44:50 2775    procedure continue;
22:44:50 2776  
22:44:50 2777    -- REGEXP_COUNT --
22:44:50 2778    function REGEXP_COUNT(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
22:44:50 2779                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
22:44:50 2780                          position    PLS_INTEGER := 1,
22:44:50 2781                          modifier    VARCHAR2 DEFAULT NULL)
22:44:50 2782      return PLS_INTEGER;
22:44:50 2783      pragma FIPSFLAG('REGEXP_COUNT', 1452);
22:44:50 2784  
22:44:50 2785    function REGEXP_COUNT(srcstr      CLOB CHARACTER SET ANY_CS,
22:44:50 2786                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
22:44:50 2787                          position    INTEGER := 1,
22:44:50 2788                          modifier    VARCHAR2 DEFAULT NULL)
22:44:50 2789      return INTEGER;
22:44:50 2790      pragma FIPSFLAG('REGEXP_COUNT', 1452);
22:44:50 2791  
22:44:50 2792    -- 47322: JSON
22:44:50 2793    -- Support for SYS$STANDARD_JSON is still needed for old databases
22:44:50 2794    function " SYS$STANDARD_JSON" return VARCHAR2;
22:44:50 2795  
22:44:50 2796    /* Bug 22106671: LOB Extensions Project.
22:44:50 2797     * PL/SQL standard will support the following LOB conversions on
22:44:50 2798     * version 19.1. The default character set in TO_CLOB/TO_CHAR operations
22:44:50 2799     * is set to UTF-8 during runtime if necessary.
22:44:50 2800     */
22:44:50 2801    FUNCTION TO_CLOB(LEFT BLOB, CSID NUMBER DEFAULT NULL) RETURN CLOB;
22:44:50 2802    FUNCTION TO_CLOB(LEFT BFILE, CSID NUMBER DEFAULT NULL) RETURN CLOB;
22:44:50 2803    FUNCTION TO_BLOB(LEFT BFILE) RETURN BLOB;
22:44:50 2804    FUNCTION TO_CHAR(LEFT BLOB, CSID NUMBER DEFAULT NULL) RETURN VARCHAR2;
22:44:50 2805    FUNCTION TO_CHAR(LEFT BFILE, CSID NUMBER DEFAULT NULL) RETURN VARCHAR2;
22:44:50 2806  
22:44:50 2807    /* End of 19.1 LOB Builtin Functions. */
22:44:50 2808  
22:44:50 2809    function "JSON_ARRAY" return VARCHAR2;
22:44:50 2810      PRAGMA BUILTIN('JSON_ARRAY', 0, 6, 1);
22:44:50 2811    function "JSON_OBJECT" return VARCHAR2;
22:44:50 2812      PRAGMA BUILTIN('JSON_OBJECT', 0, 6, 2);
22:44:50 2813    function "JSON_VALUE" return VARCHAR2;
22:44:50 2814      PRAGMA BUILTIN('JSON_VALUE', 0, 6, 3);
22:44:50 2815    function "IS_JSON" return VARCHAR2;
22:44:50 2816      PRAGMA BUILTIN('IS_JSON', 0, 6, 4);
22:44:50 2817    function "IS_NOT_JSON" return VARCHAR2;
22:44:50 2818      PRAGMA BUILTIN('IS_NOT_JSON', 0, 6, 5);
22:44:50 2819    function "JSON_EXISTS" return VARCHAR2;
22:44:50 2820      PRAGMA BUILTIN('JSON_EXISTS', 0, 6, 6);
22:44:50 2821    function "JSON_QUERY" return VARCHAR2;
22:44:50 2822      PRAGMA BUILTIN('JSON_QUERY', 0, 6, 7);
22:44:50 2823  
22:44:50 2824    --#### All user-visible declarations should precede this point.  The
22:44:50 2825    --#### following are implementation-oriented pragmas that may need
22:44:50 2826    --#### editing in the future; we would prefer to be able to edit them
22:44:50 2827    --#### without affecting the rft numbering of user-visible items.
22:44:50 2828  
22:44:50 2829    --#### interface pragmas
22:44:50 2830  
22:44:50 2831    --#### Note that for any ICD which maps directly to a PVM
22:44:50 2832    --#### Opcode MUST be mapped to pes_dummy.
22:44:50 2833    --#### An ICD which invokes another ICD by flipping operands is
22:44:50 2834    --#### mapped to pes_flip, and an ICD whose result is the inverse of
22:44:50 2835    --#### another ICD is mapped to pes_invert
22:44:50 2836    --#### New ICDs should be placed at the end of this list, and a
22:44:50 2837    --#### corresponding entry must be made in the ICD table in pdz7
22:44:50 2838  
22:44:50 2839    PRAGMA interface(c,length,"pes_dummy",1);
22:44:50 2840    PRAGMA interface(c,substr,"pes_dummy",1);
22:44:50 2841    PRAGMA interface(c,instr,"pesist",1);
22:44:50 2842    PRAGMA interface(c,UPPER,"pesupp",1);
22:44:50 2843    PRAGMA interface(c,LOWER,"peslow",1);
22:44:50 2844    PRAGMA interface(c,ASCII,"pesasc");
22:44:50 2845    PRAGMA interface(c,ASCIISTR,"pesastr");
22:44:50 2846    PRAGMA interface(c,UNISTR,"pesustr");
22:44:50 2847    PRAGMA interface(c,CHR,"peschr");
22:44:50 2848    PRAGMA interface(c," SYS$STANDARD_CHR","peschr");
22:44:50 2849    PRAGMA interface(c,INITCAP,"pesicp");
22:44:50 2850    PRAGMA interface(c,LPAD,"peslpd",1);
22:44:50 2851    PRAGMA interface(c,LPAD,"peslpd",2);
22:44:50 2852    PRAGMA interface(c,RPAD,"pesrpd",1);
22:44:50 2853    PRAGMA interface(c,RPAD,"pesrpd",2);
22:44:50 2854    PRAGMA interface(c,REPLACE,"pesrep",1);
22:44:50 2855    PRAGMA interface(c,LTRIM,"pesltr",1);
22:44:50 2856    PRAGMA interface(c,LTRIM,"pesltr",2);
22:44:50 2857    PRAGMA interface(c,RTRIM,"pesrtr",1);
22:44:50 2858    PRAGMA interface(c,RTRIM,"pesrtr",2);
22:44:50 2859    PRAGMA interface(c,'LIKE',"peslik",1);
22:44:50 2860    PRAGMA interface(c,'LIKE',"pesli2",2);
22:44:50 2861    PRAGMA interface(c,ABS,"pes_dummy",1);
22:44:50 2862    PRAGMA interface(c,'REM',"pesmod", 1);
22:44:50 2863    PRAGMA interface(c,'MOD',"pesmod", 1);
22:44:50 2864    PRAGMA interface(c,floor,"pesflo", 1);
22:44:50 2865    PRAGMA interface(c,CEIL,"pescei", 1);
22:44:50 2866    PRAGMA interface (c, SQRT, "pessqt", 1);
22:44:50 2867    PRAGMA interface(c,SIGN,"pessgn", 1);
22:44:50 2868    PRAGMA interface(c,cos,"pescos", 1);
22:44:50 2869    PRAGMA interface(c,sin,"pessin",1);
22:44:50 2870    PRAGMA interface(c,TAN,"pestan",1);
22:44:50 2871    PRAGMA interface(c,COSH,"pescsh",1);
22:44:50 2872    PRAGMA interface(c,SINH,"pessnh",1);
22:44:50 2873    PRAGMA interface(c,TANH,"pestnh",1);
22:44:50 2874    PRAGMA interface(c,EXP,"pesexp",1);
22:44:50 2875    PRAGMA interface(c,LN,"pesln",1);
22:44:50 2876    PRAGMA interface(c,BITAND,"pesbtd",1);
22:44:50 2877    PRAGMA interface(c,BITAND,"pesbtdn",2);
22:44:50 2878    PRAGMA interface(c,LOG,"peslog",1);
22:44:50 2879    PRAGMA interface(c,TRUNC,"pestru",1);
22:44:50 2880    PRAGMA interface(c,ROUND,"pesrnd",1);
22:44:50 2881    PRAGMA interface(c,POWER,"pespow",1);
22:44:50 2882    PRAGMA interface(c,NEW_TIME,"pesnwt");
22:44:50 2883    PRAGMA interface(c,TO_DATE,"pesc2d",4);
22:44:50 2884    PRAGMA interface(c,TO_NUMBER,"pesc2n",3);
22:44:50 2885    PRAGMA interface(c,TO_NUMBER,"pesc2n",4);
22:44:50 2886    PRAGMA interface(c,'>=',"pes_flip",5);
22:44:50 2887    PRAGMA interface(c,'>',"pes_flip",5);
22:44:50 2888    PRAGMA interface(c,'<=',"peszle",5);
22:44:50 2889    PRAGMA interface(c,'<',"peszlt",5);        -- ICD #50
22:44:50 2890    PRAGMA interface(c,'=',"peszeq",5);
22:44:50 2891    PRAGMA interface(c,'!=',"pes_invert",5);
22:44:50 2892    PRAGMA interface(c,nlssort,"pesxco",2);
22:44:50 2893    PRAGMA interface(c,NLS_UPPER,"pesxup",1);
22:44:50 2894    PRAGMA interface(c,NLS_UPPER,"peslcnup",3); -- LOB NLS_UPPER
22:44:50 2895    PRAGMA interface(c,NLS_UPPER,"peslcnup",4); -- LOB NLS_UPPER
22:44:50 2896    PRAGMA interface(c,NLS_LOWER,"pesxlo",1);
22:44:50 2897    PRAGMA interface(c,NLS_LOWER,"peslcnlr",3); -- LOB NLS_LOWER
22:44:50 2898    PRAGMA interface(c,NLS_LOWER,"peslcnlr",4); -- LOB NLS_LOWER
22:44:50 2899    PRAGMA interface(c,NLS_INITCAP,"pesxcp",1);
22:44:50 2900    PRAGMA interface(c,lengthb,"pes_dummy",1);
22:44:50 2901    PRAGMA interface(c,substrb,"pes_dummy",1);
22:44:50 2902    PRAGMA interface(c,instrb,"pesxis",1);
22:44:50 2903    PRAGMA interface(c,TO_SINGLE_BYTE, "pesxsi");
22:44:50 2904    PRAGMA interface(c,TO_MULTI_BYTE,"pesxmu");
22:44:50 2905    PRAGMA interface(c,TO_CHAR,"pesd2c",5);
22:44:50 2906    PRAGMA interface(c,TO_CHAR,"pesn2c",6);
22:44:50 2907    PRAGMA interface(c,TO_NCHAR,"pesd2c",4);
22:44:50 2908    PRAGMA interface(c,TO_NCHAR,"pesn2c",5);
22:44:50 2909    PRAGMA interface(c," SYS$STANDARD_TRANSLATE","pesxcs");
22:44:50 2910    PRAGMA interface(c,ATAN,"pesatan",1);
22:44:50 2911    PRAGMA interface(c,EMPTY_CLOB,"peslcem");
22:44:50 2912    PRAGMA interface(c,EMPTY_BLOB,"peslbem");
22:44:50 2913    PRAGMA interface(c,BFILENAME,"pesfnm");
22:44:50 2914    PRAGMA interface(c,TO_TIME,"pes3tm",2);
22:44:50 2915    PRAGMA interface(c,TO_TIME,"pes3tm",3);
22:44:50 2916    PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",2);
22:44:50 2917    PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",3);
22:44:50 2918    PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",2);
22:44:50 2919    PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",3);
22:44:50 2920    PRAGMA interface(c,TO_TIME_TZ,"pes3te",2);
22:44:50 2921    PRAGMA interface(c,TO_TIME_TZ,"pes3te",3);
22:44:50 2922    PRAGMA interface(c,TO_DSINTERVAL,"pes2dsi",2);
22:44:50 2923    PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",1);
22:44:50 2924    PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",2);
22:44:50 2925    PRAGMA interface(c,SESSIONTIMEZONE,"pesstz",1);
22:44:50 2926    PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",1);
22:44:50 2927    PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",2);
22:44:50 2928    PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",3);
22:44:50 2929    PRAGMA interface(c,TRIM,"pestrim",1);
22:44:50 2930    -- Datetime addition
22:44:50 2931    PRAGMA interface(c,'+',"pesati",5);    --  +(tsp, iym) return tsp
22:44:50 2932    PRAGMA interface(c,'+',"pesati",6);    --  +(tsp, ids) return tsp
22:44:50 2933    PRAGMA interface(c,'+',"pesati",7);    --  +(tsz, iym) return tsz
22:44:50 2934    PRAGMA interface(c,'+',"pesati",8);    --  +(tsz, ids) return tsz
22:44:50 2935    PRAGMA interface(c,'+',"pesati",9);    --  +(tim, ids) return tim
22:44:50 2936    PRAGMA interface(c,'+',"pesati",10);   --  +(tmz, ids) return tmz
22:44:50 2937    PRAGMA interface(c,'+',"pesadi",11);   --  +(dat, iym) return dat
22:44:50 2938    PRAGMA interface(c,'+',"pesadi",12);   --  +(dat, ids) return dat
22:44:50 2939    PRAGMA interface(c,'+',"pes_flip",13); --  +(iym, tsp) return tsp
22:44:50 2940    PRAGMA interface(c,'+',"pes_flip",14); --  +(iym, tsz) return tsz -- ICD #100
22:44:50 2941    PRAGMA interface(c,'+',"pes_flip",15); --  +(iym, dat) return dat
22:44:50 2942    PRAGMA interface(c,'+',"pes_flip",16); --  +(ids, tsp) return tsp
22:44:50 2943    PRAGMA interface(c,'+',"pes_flip",17); --  +(ids, tsz) return tsz
22:44:50 2944    PRAGMA interface(c,'+',"pes_flip",18); --  +(ids, tim) return tim
22:44:50 2945    PRAGMA interface(c,'+',"pes_flip",19); --  +(ids, tmz) return tmz
22:44:50 2946    PRAGMA interface(c,'+',"pes_flip",20); --  +(ids, dat) return dat
22:44:50 2947    PRAGMA interface(c,'+',"pesaii",21);   --  +(ids, ids) return ids
22:44:50 2948    PRAGMA interface(c,'+',"pesaii",22);   --  +(iym, iym) return iym
22:44:50 2949    PRAGMA interface(c,'+',"pesati",23);   --  +(ltz, iym) return ltz
22:44:50 2950    PRAGMA interface(c,'+',"pesati",24);   --  +(ltz, ids) return ltz
22:44:50 2951    PRAGMA interface(c,'+',"pes_flip",25);--  +(iym, ltz) return ltz
22:44:50 2952    PRAGMA interface(c,'+',"pes_flip",26);--  +(ids, ltz) return ltz
22:44:50 2953    -- Datetime subtraction
22:44:50 2954    PRAGMA interface(c,'-',"pessti",6);    --  -(tsp, iym) return tsp
22:44:50 2955    PRAGMA interface(c,'-',"pessti",7);    --  -(tsp, ids) return tsp
22:44:50 2956    PRAGMA interface(c,'-',"pessti",8);    --  -(tsz, iym) return tsz
22:44:50 2957    PRAGMA interface(c,'-',"pessti",9);    --  -(tsz, ids) return tsz
22:44:50 2958    PRAGMA interface(c,'-',"pessti",10);   --  -(tim, ids) return tim
22:44:50 2959    PRAGMA interface(c,'-',"pessti",11);   --  -(tmz, ids) return tmz
22:44:50 2960    PRAGMA interface(c,'-',"pessdi",12);   --  -(dat, iym) return dat
22:44:50 2961    PRAGMA interface(c,'-',"pessdi",13);   --  -(dat, ids) return dat
22:44:50 2962    PRAGMA interface(c,'-',"pessii",14);   --  -(iym, iym) return iym
22:44:50 2963    PRAGMA interface(c,'-',"pessii",15);   --  -(ids, ids) return ids
22:44:50 2964    PRAGMA interface(c,'-',"pessttds",16); --  -(tim, tim) return ids
22:44:50 2965    PRAGMA interface(c,'-',"pessttds",17); --  -(tsp, tsp) return ids
22:44:50 2966    PRAGMA interface(c,'-',"pessttds",18); --  -(tmz, tmz) return ids
22:44:50 2967    PRAGMA interface(c,'-',"pessttds",19); --  -(tsz, tsz) return ids
22:44:50 2968    PRAGMA interface(c,'-',"pessti",20);   --  -(ltz, iym) return iym
22:44:50 2969    PRAGMA interface(c,'-',"pessti",21);   --  -(ltz, ids) return ids
22:44:50 2970    PRAGMA interface(c,'-',"pessttds",22); --  -(ltz, ltz) return ids
22:44:50 2971    PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",1);
22:44:50 2972    PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",2);
22:44:50 2973    PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",3);
22:44:50 2974    PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",4);
22:44:50 2975    PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessddds",5);
22:44:50 2976    PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",6);
22:44:50 2977    PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",1);
22:44:50 2978    PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",2);
22:44:50 2979    PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessddym",3);
22:44:50 2980    PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",4);
22:44:50 2981    -- Datetime multiplication
22:44:50 2982    PRAGMA interface(c,'*',"pesmni",2);    --  *(num, iym) return iym
22:44:50 2983    PRAGMA interface(c,'*',"pesmni",3);    --  *(num, ids) return ids
22:44:50 2984    PRAGMA interface(c,'*',"pes_flip",4);  --  *(iym, num) return iym
22:44:50 2985    PRAGMA interface(c,'*',"pes_flip",5);  --  *(ids, num) return ids
22:44:50 2986    -- Datetime division
22:44:50 2987    PRAGMA interface(c,'/',"pesdvin",2);   --  /(iym, num) return iym
22:44:50 2988    PRAGMA interface(c,'/',"pesdvin",3);   --  /(ids, num) return ids
22:44:50 2989    -- TIME
22:44:50 2990    PRAGMA interface(c,'=',"pes_dummy",9);
22:44:50 2991    PRAGMA interface(c,'!=',"pes_invert",9);
22:44:50 2992    PRAGMA interface(c,'>',"pes_flip",8);
22:44:50 2993    PRAGMA interface(c,'<',"pes_dummy",8);
22:44:50 2994    PRAGMA interface(c,'>=',"pes_flip",8);   -- ICD #150
22:44:50 2995    PRAGMA interface(c,'<=',"pes_dummy",8);
22:44:50 2996    -- TIME WITH TIME ZONE
22:44:50 2997    PRAGMA interface(c,'=',"pes_dummy",10);
22:44:50 2998    PRAGMA interface(c,'!=',"pes_invert",10);
22:44:50 2999    PRAGMA interface(c,'>',"pes_flip",9);
22:44:50 3000    PRAGMA interface(c,'<',"pes_dummy",9);
22:44:50 3001    PRAGMA interface(c,'>=',"pes_flip",9);
22:44:50 3002    PRAGMA interface(c,'<=',"pes_dummy",9);
22:44:50 3003    -- TIMESTAMP
22:44:50 3004    PRAGMA interface(c,'=',"pes_dummy",11);
22:44:50 3005    PRAGMA interface(c,'!=',"pes_invert",11);
22:44:50 3006    PRAGMA interface(c,'>',"pes_flip",10);
22:44:50 3007    PRAGMA interface(c,'<',"pes_dummy",10);
22:44:50 3008    PRAGMA interface(c,'>=',"pes_flip",10);
22:44:50 3009    PRAGMA interface(c,'<=',"pes_dummy",10);
22:44:50 3010    -- INTERVAL YEAR TO MONTH
22:44:50 3011    PRAGMA interface(c,'=',"pes_dummy",12);
22:44:50 3012    PRAGMA interface(c,'!=',"pes_invert",12);
22:44:50 3013    PRAGMA interface(c,'>',"pes_flip",11);
22:44:50 3014    PRAGMA interface(c,'<',"pes_dummy",11);
22:44:50 3015    PRAGMA interface(c,'>=',"pes_flip",11);
22:44:50 3016    PRAGMA interface(c,'<=',"pes_dummy",11);
22:44:50 3017    -- INTERVAL DAY TO SECOND
22:44:50 3018    PRAGMA interface(c,'=',"pes_dummy",13);
22:44:50 3019    PRAGMA interface(c,'!=',"pes_invert",13);
22:44:50 3020    PRAGMA interface(c,'>',"pes_flip",12);
22:44:50 3021    PRAGMA interface(c,'<',"pes_dummy",12);
22:44:50 3022    PRAGMA interface(c,'>=',"pes_flip",12);
22:44:50 3023    PRAGMA interface(c,'<=',"pes_dummy",12);
22:44:50 3024    -- TIMESTAMP_TZ_UNCONSTRAINED
22:44:50 3025    PRAGMA interface(c,'=',"pes_dummy",14);
22:44:50 3026    PRAGMA interface(c,'!=',"pes_invert",14);
22:44:50 3027    PRAGMA interface(c,'>',"pes_flip",13);
22:44:50 3028    PRAGMA interface(c,'<',"pes_dummy",13);
22:44:50 3029    PRAGMA interface(c,'>=',"pes_flip",13);
22:44:50 3030    PRAGMA interface(c,'<=',"pes_dummy",13);
22:44:50 3031    -- TIMESTAMP WITH LOCAL TIME ZONE
22:44:50 3032    PRAGMA interface(c,'=',"pes_dummy",15);
22:44:50 3033    PRAGMA interface(c,'!=',"pes_invert",15);
22:44:50 3034    PRAGMA interface(c,'>',"pes_flip",14);
22:44:50 3035    PRAGMA interface(c,'<',"pes_dummy",14);
22:44:50 3036    PRAGMA interface(c,'>=',"pes_flip",14);
22:44:50 3037    PRAGMA interface(c,'<=',"pes_dummy",14);
22:44:50 3038    -- Other datetime functions
22:44:50 3039    PRAGMA interface(c,'CURRENT_DATE',"pescdt",1);
22:44:50 3040    PRAGMA interface(c,'CURRENT_TIME',"pesctm",1);
22:44:50 3041    PRAGMA interface(c,'CURRENT_TIMESTAMP',"pescts",1);
22:44:50 3042    --  Internal calls to evaluate datetime/interval literals without NLS parms.
22:44:50 3043    PRAGMA interface(c,SYS_LITERALTOYMINTERVAL,"pesc2ymi",1);
22:44:50 3044    PRAGMA interface(c,SYS_LITERALTODSINTERVAL,"pesc2dsi",1);
22:44:50 3045    PRAGMA interface(c,SYS_LITERALTOTIME,"pesc2tim",1);
22:44:50 3046    PRAGMA interface(c,SYS_LITERALTOTZTIME,"pesc2tim",1);
22:44:50 3047    PRAGMA interface(c,SYS_LITERALTOTIMESTAMP,"pesc2tsp",1);
22:44:50 3048    PRAGMA interface(c,SYS_LITERALTOTZTIMESTAMP,"pesc2tsp",1);
22:44:50 3049    PRAGMA interface(c,SYS_LITERALTODATE,"pesc2date",1);
22:44:50 3050    -- extract(field from expr)
22:44:50 3051    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",1);
22:44:50 3052    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",2);
22:44:50 3053    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",3);   -- ICD #200
22:44:50 3054    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",4);
22:44:50 3055    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",5);
22:44:50 3056    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefdt",6);
22:44:50 3057    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",7);
22:44:50 3058    PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",8);
22:44:50 3059    -- datetime is null
22:44:50 3060    PRAGMA interface(c,'IS NULL',"pes_dummy",15); -- time
22:44:50 3061    PRAGMA interface(c,'IS NULL',"pes_dummy",16); -- time wtz
22:44:50 3062    PRAGMA interface(c,'IS NULL',"pes_dummy",17); -- timestamp
22:44:50 3063    PRAGMA interface(c,'IS NULL',"pes_dummy",18); -- timestamp wtz
22:44:50 3064    PRAGMA interface(c,'IS NULL',"pes_dummy",19); -- timestamp lwtz
22:44:50 3065    PRAGMA interface(c,'IS NULL',"pes_dummy",20); -- interval ym
22:44:50 3066    PRAGMA interface(c,'IS NULL',"pes_dummy",21); -- interval ds
22:44:50 3067  
22:44:50 3068    -- 8.2 LOB Built-in Functions
22:44:50 3069    PRAGMA interface(c,length, "peslcln",2);    -- LOB LENGTH
22:44:50 3070    PRAGMA interface(c,lengthb,"peslclb",2);    -- LOB LENGTHB
22:44:50 3071    PRAGMA interface(c,substr, "peslcst",2);    -- LOB SUBSTR
22:44:50 3072    PRAGMA interface(c,substrb,"peslcsb",2);    -- LOB SUBSTRB
22:44:50 3073    PRAGMA interface(c,instr,  "peslcin",2);    -- LOB INSTR
22:44:50 3074    PRAGMA interface(c,instrb, "peslcib",2);    -- LOB INSTRB
22:44:50 3075    PRAGMA interface(c,'||',   "peslcct",2);    -- LOB '||'
22:44:50 3076    PRAGMA interface(c,concat, "peslcct",2);    -- LOB CONCAT
22:44:50 3077    PRAGMA interface(c,lpad,   "peslclp",3);    -- LOB LPAD
22:44:50 3078    PRAGMA interface(c,lpad,   "peslclp",4);    -- LOB LPAD
22:44:50 3079    PRAGMA interface(c,rpad,   "peslcrp",3);    -- LOB RPAD
22:44:50 3080    PRAGMA interface(c,rpad,   "peslcrp",4);    -- LOB RPAD
22:44:50 3081    PRAGMA interface(c,lower,  "peslclr",2);    -- LOB LOWER
22:44:50 3082    PRAGMA interface(c,upper,  "peslcup",2);    -- LOB UPPER
22:44:50 3083    PRAGMA interface(c,ltrim,  "peslclm",3);    -- LOB LTRIM
22:44:50 3084    PRAGMA interface(c,ltrim,  "peslclm",4);    -- LOB LTRIM
22:44:50 3085    PRAGMA interface(c,rtrim,  "peslcrm",3);    -- LOB RTRIM
22:44:50 3086    PRAGMA interface(c,rtrim,  "peslcrm",4);    -- LOB RTRIM
22:44:50 3087    PRAGMA interface(c,trim,   "peslctr",2);    -- LOB TRIM
22:44:50 3088    PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",4); -- LOB TRIM
22:44:50 3089    PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",5); -- LOB TRIM
22:44:50 3090    PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",6); -- LOB TRIM
22:44:50 3091    PRAGMA interface(c,'LIKE', "peslclk",3);    -- LOB LIKE
22:44:50 3092    PRAGMA interface(c,'LIKE', "peslcl2",4);    -- LOB LIKE
22:44:50 3093    PRAGMA interface(c,nvl,"peslcnl",18);       -- LOB NVL
22:44:50 3094    PRAGMA interface(c,replace, "peslcrl",2);   -- LOB REPLACE
22:44:50 3095  
22:44:50 3096       -- LOB Relational Operators
22:44:50 3097       -- LHS: CLOB,    RHS:CLOB
22:44:50 3098    PRAGMA interface(c,'=' ,"pes_dummy",16);     -- LOB '='
22:44:50 3099    PRAGMA interface(c,'!=',"pes_invert",16);    -- LOB '!='
22:44:50 3100    PRAGMA interface(c,'>' ,"pes_flip",15);      -- LOB '>'
22:44:50 3101    PRAGMA interface(c,'<' ,"pes_dummy",15);     -- LOB '<'
22:44:50 3102    PRAGMA interface(c,'>=',"pes_flip",15);      -- LOB '>='
22:44:50 3103    PRAGMA interface(c,'<=',"pes_dummy",15);       -- LOB '<='
22:44:50 3104       -- LHS: CLOB,     RHS:VARCHAR2
22:44:50 3105    PRAGMA interface(c,'=' ,"pesleq2",17);       -- LOB '='
22:44:50 3106    PRAGMA interface(c,'!=',"pes_invert",17);    -- LOB '!='
22:44:50 3107    PRAGMA interface(c,'>' ,"pes_flip",16);      -- LOB '>'
22:44:50 3108    PRAGMA interface(c,'<' ,"pesllt2",16);       -- LOB '<'
22:44:50 3109    PRAGMA interface(c,'>=',"pes_flip",16);      -- LOB '>='
22:44:50 3110    PRAGMA interface(c,'<=',"peslle2",16);       -- LOB '<='  -- ICD #250
22:44:50 3111       -- LHS: VARCHAR2, RHS:CLOB
22:44:50 3112    PRAGMA interface(c,'=' ,"pes_flip",18);      -- LOB '='
22:44:50 3113    PRAGMA interface(c,'!=',"pes_flip",18);      -- LOB '!='
22:44:50 3114    PRAGMA interface(c,'>' ,"pes_flip",17);      -- LOB '>'
22:44:50 3115    PRAGMA interface(c,'<' ,"pesllt3",17);       -- LOB '<'
22:44:50 3116    PRAGMA interface(c,'>=',"pes_flip",17);      -- LOB '>='
22:44:50 3117    PRAGMA interface(c,'<=',"peslle3",17);       -- LOB '<='
22:44:50 3118  
22:44:50 3119    PRAGMA interface(c,length, "peslbln",3);    -- BLOB LENGTH
22:44:50 3120    PRAGMA interface(c,lengthb,"peslblb",3);    -- BLOB LENGTHB
22:44:50 3121    -- End of 8.2 LOB Built-in Functions
22:44:50 3122  
22:44:50 3123  
22:44:50 3124    PRAGMA interface(c,tz_offset,"pestzo",1);
22:44:50 3125    PRAGMA interface(c,from_tz,"pesftz",1);
22:44:50 3126  
22:44:50 3127    PRAGMA interface(c,ISNCHAR,"pesinc", 1);
22:44:50 3128  
22:44:50 3129    PRAGMA interface(c,CONVERT,"pescnv", 1);
22:44:50 3130    PRAGMA interface(c,CONVERT,"pescnv", 2);
22:44:50 3131    PRAGMA interface(c,CONVERT,"peslccnv", 3);  -- LOB CONVERT
22:44:50 3132    PRAGMA interface(c,CONVERT,"peslccnv", 4);  -- LOB CONVERT
22:44:50 3133  
22:44:50 3134    PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",1);
22:44:50 3135    PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",2);
22:44:50 3136    PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",3);
22:44:50 3137  
22:44:50 3138    PRAGMA interface(c,TO_CHAR,"pesdtm2c",7); -- datetime
22:44:50 3139    PRAGMA interface(c,TO_CHAR,"pesdtm2c",8);
22:44:50 3140    PRAGMA interface(c,TO_CHAR,"pesdtm2c",9);
22:44:50 3141    PRAGMA interface(c,TO_CHAR,"pesdtm2c",10);
22:44:50 3142    PRAGMA interface(c,TO_CHAR,"pesdtm2c",11);
22:44:50 3143    PRAGMA interface(c,TO_CHAR,"pesdtm2c",12);
22:44:50 3144    PRAGMA interface(c,TO_CHAR,"pesdtm2c",13);
22:44:50 3145    PRAGMA interface(c,TO_CHAR,"pesdtm2c",14);
22:44:50 3146    PRAGMA interface(c,TO_CHAR,"pesdtm2c",15);
22:44:50 3147    PRAGMA interface(c,TO_CHAR,"pesdtm2c",16);
22:44:50 3148    PRAGMA interface(c,TO_CHAR,"pesitv2c",17); -- interval
22:44:50 3149    PRAGMA interface(c,TO_CHAR,"pesitv2c",18);
22:44:50 3150    PRAGMA interface(c,TO_CHAR,"pesitv2c",19);
22:44:50 3151    PRAGMA interface(c,TO_CHAR,"pesitv2c",20);
22:44:50 3152  
22:44:50 3153    --#### new_names pragmas
22:44:50 3154  
22:44:50 3155    -- This is an internal pragma that restricts the use
22:44:50 3156    -- of particular new entries in package standard.
22:44:50 3157    -- It is only valid in package standard.
22:44:50 3158    -- Note that left out of the 8.1.5 set are non datetime
22:44:50 3159    -- entries urowid, "UROWID ", self_is_null and trim.
22:44:50 3160  
22:44:50 3161    pragma new_names('8.1.5',
22:44:50 3162                     time,"TIME WITH TIME ZONE",
22:44:50 3163                     timestamp,"TIMESTAMP WITH TIME ZONE",
22:44:50 3164                     "INTERVAL DAY TO SECOND",
22:44:50 3165                     "INTERVAL YEAR TO MONTH",
22:44:50 3166                     to_time, to_timestamp,
22:44:50 3167                     to_time_tz, to_timestamp_tz,
22:44:50 3168                     " SYS$DSINTERVALSUBTRACT",
22:44:50 3169                     " SYS$YMINTERVALSUBTRACT",
22:44:50 3170                     to_yminterval,to_dsinterval,
22:44:50 3171                     NUMTOYMINTERVAL, NUMTODSINTERVAL,
22:44:50 3172                     current_date,
22:44:50 3173                     current_time,current_timestamp);
22:44:50 3174  
22:44:50 3175    pragma new_names('8.1.6',
22:44:50 3176                     dbtimezone, sessiontimezone, localtimestamp,
22:44:50 3177                     localtime,
22:44:50 3178                     cube, rollup, grouping, "TIMESTAMP WITH LOCAL TIME ZONE");
22:44:50 3179  
22:44:50 3180    -- Should there be a 8.2 new names pragma ?
22:44:50 3181  
22:44:50 3182    -- 8.2 UCS2/UCS4/Complete Built-in Functions
22:44:50 3183  
22:44:50 3184    PRAGMA interface(c,INSTR2,"pesist2",1);
22:44:50 3185    PRAGMA interface(c,INSTR4,"pesist4",1);
22:44:50 3186    PRAGMA interface(c,INSTRC,"pesistc",1);
22:44:50 3187  
22:44:50 3188    PRAGMA interface(c,LENGTH2,"peslen2",1);
22:44:50 3189    PRAGMA interface(c,LENGTH4,"peslen4",1);
22:44:50 3190    PRAGMA interface(c,LENGTHC,"peslenc",1);
22:44:50 3191  
22:44:50 3192    PRAGMA interface(c,LIKE2,"peslik2",1);
22:44:50 3193    PRAGMA interface(c,LIKE2,"pesli22",2);
22:44:50 3194    PRAGMA interface(c,LIKE4,"peslik4",1);
22:44:50 3195    PRAGMA interface(c,LIKE4,"pesli42",2);
22:44:50 3196    PRAGMA interface(c,LIKEC,"peslikc",1);
22:44:50 3197    PRAGMA interface(c,LIKEC,"peslic2",2);
22:44:50 3198  
22:44:50 3199    PRAGMA interface(c,SUBSTR2,"pes_dummy",1);
22:44:50 3200    PRAGMA interface(c,SUBSTR4,"pes_dummy",1);
22:44:50 3201    PRAGMA interface(c,SUBSTRC,"pes_dummy",1);
22:44:50 3202    PRAGMA interface(c,SYS_EXTRACT_UTC,"pessexu");
22:44:50 3203    PRAGMA interface(c,COMPOSE,"pescomp");
22:44:50 3204    PRAGMA interface(c,DECOMPOSE,"pesdcmp");
22:44:50 3205  
22:44:50 3206  
22:44:50 3207  
22:44:50 3208    -- End of 8.2 UCS2/UCS4/Complete Built-in Functions
22:44:50 3209  
22:44:50 3210    -- Begin REGEXP support (10iR1) --
22:44:50 3211    PRAGMA interface(c,regexp_like,    "pes_dummy",1);
22:44:50 3212    PRAGMA interface(c,regexp_instr,   "pes_dummy",1);    -- ICD #300
22:44:50 3213    PRAGMA interface(c,regexp_substr,  "pes_dummy",1);
22:44:50 3214    PRAGMA interface(c,regexp_replace, "pes_dummy",1);
22:44:50 3215    PRAGMA interface(c,regexp_count,   "pes_dummy",1);
22:44:50 3216    PRAGMA interface(c,regexp_like,    "pes_dummy",2);    -- LOB REGEXP_LIKE
22:44:50 3217    PRAGMA interface(c,regexp_instr,   "pes_dummy",2);    -- LOB REGEXP_INSTR
22:44:50 3218    PRAGMA interface(c,regexp_substr,  "pes_dummy",2);    -- LOB REGEXP_SUBSTR
22:44:50 3219    PRAGMA interface(c,regexp_replace, "pes_dummy",2);    -- LOB REGEXP_REPLACE
22:44:50 3220    PRAGMA interface(c,regexp_count,   "pes_dummy",2);    -- LOB REGEXP_COUNT
22:44:50 3221    PRAGMA interface(c,regexp_replace, "pes_dummy",3);    -- LOB REGEXP_REPLACE
22:44:50 3222  
22:44:50 3223    -- End of REGEXP Built-in Functions --
22:44:50 3224  
22:44:50 3225  
22:44:50 3226    -- 10i Binary Floating-point Built-in Functions
22:44:50 3227  
22:44:50 3228    PRAGMA interface(c,'IS NAN',"pesnanf",2);
22:44:50 3229    PRAGMA interface(c,'IS NAN',"pesnand",3);
22:44:50 3230    PRAGMA interface(c,'IS INFINITE',"pesinf",1);
22:44:50 3231    PRAGMA interface(c,'IS INFINITE',"pesinff",2);
22:44:50 3232    PRAGMA interface(c,'IS INFINITE',"pesinfd",3);
22:44:50 3233    PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",2);
22:44:50 3234    PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",3);
22:44:50 3235    PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",2);
22:44:50 3236    PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",3);
22:44:50 3237    PRAGMA interface(c,TO_CHAR,"pesflt2c",21);
22:44:50 3238    PRAGMA interface(c,TO_CHAR,"pesdbl2c",22);
22:44:50 3239    PRAGMA interface(c,TO_CHAR,"pesflt2c",23);
22:44:50 3240    PRAGMA interface(c,TO_CHAR,"pesdbl2c",24);
22:44:50 3241    PRAGMA interface(c,TO_NCHAR,"pesflt2c",6);
22:44:50 3242    PRAGMA interface(c,TO_NCHAR,"pesdbl2c",7);
22:44:50 3243    PRAGMA interface(c,TO_NCHAR,"pesflt2c",8);
22:44:50 3244    PRAGMA interface(c,TO_NCHAR,"pesdbl2c",9);
22:44:50 3245    PRAGMA interface(c,'REMAINDER',"pesrem", 1);
22:44:50 3246    PRAGMA interface(c,REMAINDER,"pesrem", 2);
22:44:50 3247    PRAGMA interface(c,'REMAINDER',"pesremf", 3);
22:44:50 3248    PRAGMA interface(c,REMAINDER,"pesremf", 4);
22:44:50 3249    PRAGMA interface(c,'REMAINDER',"pesremd", 5);
22:44:50 3250    PRAGMA interface(c,REMAINDER,"pesremd", 6);
22:44:50 3251    PRAGMA interface(c,ABS,"pes_dummy",2);
22:44:50 3252    PRAGMA interface(c,ABS,"pes_dummy",3);
22:44:50 3253    PRAGMA interface(c,ABS,"pes_dummy",4);
22:44:50 3254    PRAGMA interface(c,ATAN,"pesatand",2);
22:44:50 3255    PRAGMA interface(c,'REM',"pesmodf", 2);
22:44:50 3256    PRAGMA interface(c,'MOD',"pesmodf", 2);
22:44:50 3257    PRAGMA interface(c,'REM',"pesmodd", 3);
22:44:50 3258    PRAGMA interface(c,'MOD',"pesmodd", 3);
22:44:50 3259    PRAGMA interface(c,floor,"pesflof", 2);
22:44:50 3260    PRAGMA interface(c,floor,"pesflod", 3);
22:44:50 3261    PRAGMA interface(c,CEIL,"pesceif", 2);
22:44:50 3262    PRAGMA interface(c,CEIL,"pesceid", 3);
22:44:50 3263    PRAGMA interface (c, SQRT, "pessqtf", 2);
22:44:50 3264    PRAGMA interface (c, SQRT, "pessqtd", 3);
22:44:50 3265    PRAGMA interface(c,SIGN,"pessgnf", 2);
22:44:50 3266    PRAGMA interface(c,SIGN,"pessgnd", 3);
22:44:50 3267    PRAGMA interface(c,SIGN,"pessgni", 4);
22:44:50 3268    PRAGMA interface(c,cos,"pescosd", 2);
22:44:50 3269    PRAGMA interface(c,sin,"pessind",2);
22:44:50 3270    PRAGMA interface(c,TAN,"pestand",2);
22:44:50 3271    PRAGMA interface(c,COSH,"pescshd",2);
22:44:50 3272    PRAGMA interface(c,SINH,"pessnhd",2);   -- ICD #350
22:44:50 3273    PRAGMA interface(c,TANH,"pestnhd",2);
22:44:50 3274    PRAGMA interface(c,EXP,"pesexpd",2);
22:44:50 3275    PRAGMA interface(c,LN,"peslnd",2);
22:44:50 3276    PRAGMA interface(c,LOG,"peslogd",2);
22:44:50 3277    PRAGMA interface(c,TRUNC,"pestruf",4);
22:44:50 3278    PRAGMA interface(c,TRUNC,"pestrud",5);
22:44:50 3279    PRAGMA interface(c,TRUNC,"pestrui",6);
22:44:50 3280    PRAGMA interface(c,ROUND,"pesrndf",4);
22:44:50 3281    PRAGMA interface(c,ROUND,"pesrndd",5);
22:44:50 3282    PRAGMA interface(c,ROUND,"pesrndi",6);
22:44:50 3283    PRAGMA interface(c,POWER,"pespowd",2);
22:44:50 3284  
22:44:50 3285    -- End of 10i Binary Floating-point Built-in Functions
22:44:50 3286  
22:44:50 3287    -- ICDs for MULTISET
22:44:50 3288  
22:44:50 3289    PRAGMA interface(c,CARDINALITY,"pesmcnt");
22:44:50 3290    PRAGMA interface(c,'IS EMPTY',"pesmie");
22:44:50 3291    PRAGMA interface(c,'IS NOT EMPTY',"pes_invert",1);
22:44:50 3292    -- ICDs which used to be in the body of standard, but which new COG can
22:44:50 3293    -- handle directly
22:44:50 3294  
22:44:50 3295    -- NOT (some ICD)
22:44:50 3296    PRAGMA interface(c,NOT_LIKE,"pes_invert",1);
22:44:50 3297    PRAGMA interface(c,NOT_LIKE,"pes_invert",2);
22:44:50 3298    PRAGMA interface(c,NOT_LIKE,"pes_invert",3);
22:44:50 3299    PRAGMA interface(c,NOT_LIKE,"pes_invert",4);
22:44:50 3300    PRAGMA interface(c,NOT_LIKE2,"pes_invert",1);
22:44:50 3301    PRAGMA interface(c,NOT_LIKE2,"pes_invert",2);
22:44:50 3302    PRAGMA interface(c,NOT_LIKE4,"pes_invert",1);
22:44:50 3303    PRAGMA interface(c,NOT_LIKE4,"pes_invert",2);
22:44:50 3304    PRAGMA interface(c,NOT_LIKEC,"pes_invert",1);
22:44:50 3305    PRAGMA interface(c,NOT_LIKEC,"pes_invert",2);
22:44:50 3306    PRAGMA interface(c,'IS NOT NAN',"pes_invert",2);
22:44:50 3307    PRAGMA interface(c,'IS NOT NAN',"pes_invert",3);
22:44:50 3308    PRAGMA interface(c,'IS NOT INFINITE',"pes_invert",1);
22:44:50 3309    PRAGMA interface(c,'IS NOT INFINITE',"pes_invert",2);
22:44:50 3310    PRAGMA interface(c,'IS NOT INFINITE',"pes_invert",3);
22:44:50 3311  
22:44:50 3312    -- datetime is not null
22:44:50 3313    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",15); -- time
22:44:50 3314    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",16); -- time wtz
22:44:50 3315    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",17); -- timestamp
22:44:50 3316    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",18); -- timestamp wtz
22:44:50 3317    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",19); -- timestamp lwtz
22:44:50 3318    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",20); -- interval ym
22:44:50 3319    PRAGMA interface(c,'IS NOT NULL',"pes_dummy",21); -- interval ds
22:44:50 3320  
22:44:50 3321    -- Misc
22:44:50 3322    PRAGMA interface(c,'**',   "pespow",1);    -- number
22:44:50 3323    PRAGMA interface(c,'**',   "pespowd",2);   -- binary double
22:44:50 3324    PRAGMA interface(c,ACOS, "pesacosd",2);  -- binary double
22:44:50 3325    PRAGMA interface(c,ASIN, "pesasind",2);  -- binary double
22:44:50 3326    PRAGMA interface(c,ATAN2,"pesatn2d",2);  -- binary double
22:44:50 3327  
22:44:50 3328    -- All the flavors of NVL
22:44:50 3329    PRAGMA interface(c,nvl,"pes_dummy",1);       -- Boolean -- ICD #400
22:44:50 3330    PRAGMA interface(c,nvl,"pes_dummy",2);       -- Varchar2
22:44:50 3331    PRAGMA interface(c,nvl,"pes_dummy",3);       -- Number
22:44:50 3332    PRAGMA interface(c,nvl,"pes_dummy",4);       -- Date
22:44:50 3333    PRAGMA interface(c,nvl,"pes_dummy",5);       -- MLSLabel
22:44:50 3334    PRAGMA interface(c,nvl,"pes_dummy",6);       -- ADT
22:44:50 3335    PRAGMA interface(c,nvl,"pes_dummy",7);       -- Ref ADT
22:44:50 3336    PRAGMA interface(c,nvl,"pes_dummy",8);       -- Collection
22:44:50 3337  
22:44:50 3338  --  Ref Cursor has problems. The MOVCR instruction needs more information than
22:44:50 3339  --  the other MOV* instructions, including the PVM register of the destination
22:44:50 3340  --  This cannot be easily supplied through the generic NVL instruction, so
22:44:50 3341  --  for now, this flavor will continue to have a real body
22:44:50 3342  --  PRAGMA interface(c,nvl,"pes_dummy",9);       -- Ref Cursor
22:44:50 3343  
22:44:50 3344    PRAGMA interface(c,nvl,"pes_dummy",10);       -- Assoc_array
22:44:50 3345    PRAGMA interface(c,nvl,"pes_dummy",11);       -- Time
22:44:50 3346    PRAGMA interface(c,nvl,"pes_dummy",12);       -- Time-tz
22:44:50 3347    PRAGMA interface(c,nvl,"pes_dummy",13);       -- Timestamp
22:44:50 3348    PRAGMA interface(c,nvl,"pes_dummy",14);       -- Timestamp-tz
22:44:50 3349    PRAGMA interface(c,nvl,"pes_dummy",15);       -- Timestamp-ltz
22:44:50 3350    PRAGMA interface(c,nvl,"pes_dummy",16);       -- Intervalym
22:44:50 3351    PRAGMA interface(c,nvl,"pes_dummy",17);       -- Intervalds
22:44:50 3352  --  PRAGMA interface(c,nvl,"pes_dummy",18);       -- Clob (Handled above, ICD)
22:44:50 3353    PRAGMA interface(c,nvl,"pes_dummy",19);       -- Opaque
22:44:50 3354    PRAGMA interface(c,nvl,"pes_dummy",20);       -- Binaryfloat
22:44:50 3355    PRAGMA interface(c,nvl,"pes_dummy",21);       -- Binarydouble
22:44:50 3356    PRAGMA interface(c,nvl,"pes_dummy",22);       -- PLSInteger
22:44:50 3357  
22:44:50 3358    -- 47322: JSON
22:44:50 3359    PRAGMA interface(c," SYS$STANDARD_JSON","pes_dummy",1);
22:44:50 3360  
22:44:50 3361    -- Bug 26851555: round_ties_to_even
22:44:50 3362    PRAGMA interface(c,ROUND_TIES_TO_EVEN,"pesrndeven",1);
22:44:50 3363  
22:44:50 3364    -- Bug 22106671: LOB Extensions
22:44:50 3365    PRAGMA interface(c,TO_CLOB,"peslblb2clb",3);  -- Blob To Clob
22:44:50 3366    PRAGMA interface(c,TO_CLOB,"peslbfi2clb",4);  -- BFile To Clob
22:44:50 3367    PRAGMA interface(c,TO_BLOB,"peslbfi2blb",2);  -- BFile To Blob
22:44:50 3368    PRAGMA interface(c,TO_CHAR,"peslblb2txt",25); -- Blob To Text
22:44:50 3369    PRAGMA interface(c,TO_CHAR,"peslbfi2txt",26); -- BFile To Text
22:44:50 3370  
22:44:50 3371    /* End of 19.1 LOB Builtin Functions. */
22:44:50 3372  
22:44:50 3373    -- The following pragma overrides any other setting of the timestamp,
22:44:50 3374    -- and is used so that we recognize the client-side and server-side instances
22:44:50 3375    -- of package STANDARD as being the same.  Package STANDARD is special in
22:44:50 3376    -- that it is really the root of the PL/SQL dependencies graph; as such it
22:44:50 3377    -- itself doesn't ever need recompiling due to changes to things below it.
22:44:50 3378    -- The pragma mechanism used here is currently ignored except for
22:44:50 3379    -- package STANDARD, but in future may not be.  Do NOT add similar pragmas
22:44:50 3380    -- to your own code as it may in future interfere with the package
22:44:50 3381    -- consistency maintenance mechanisms and could have dire results.
22:44:50 3382  
22:44:50 3383    --#### timestamp pragma (please keep this last)
22:44:50 3384    pragma TIMESTAMP('2018-07-16:00:00:00');
22:44:50 3385  end;
22:44:50 3386  
22:44:50 3387  /

Package created.

Elapsed: 00:00:00.61
22:44:51 sys@jpcdip04> @?/rdbms/admin/sqlsessend.sql
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem $Header: rdbms/admin/sqlsessend.sql /main/3 2018/07/25 13:50:02 surman Exp $
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem sqlsessend.sql
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
22:44:51 sys@jpcdip04> Rem All rights reserved.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    NAME
22:44:51 sys@jpcdip04> Rem      sqlsessend.sql - SQL session end
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    DESCRIPTION
22:44:51 sys@jpcdip04> Rem      Any commands which should be run at the end of all oracle
22:44:51 sys@jpcdip04> Rem      supplied scripts.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    NOTES
22:44:51 sys@jpcdip04> Rem      See sqlsessstart.sql for the corresponding start script.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:44:51 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessend.sql
22:44:51 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessend.sql
22:44:51 sys@jpcdip04> Rem    SQL_PHASE: MISC
22:44:51 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:44:51 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:44:51 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:44:51 sys@jpcdip04> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
22:44:51 sys@jpcdip04> Rem    surman      03/08/13 - 16462837: Common start and end scripts
22:44:51 sys@jpcdip04> Rem    surman      03/08/13 - Created
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> alter session set "_ORACLE_SCRIPT" = false;

Session altered.

Elapsed: 00:00:00.00
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> @@stdbody.sql
22:44:51 sys@jpcdip04> @@?/rdbms/admin/sqlsessstart.sql
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem $Header: rdbms/admin/sqlsessstart.sql /main/3 2018/07/25 13:50:02 surman Exp $
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem sqlsessstart.sql
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
22:44:51 sys@jpcdip04> Rem All rights reserved.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    NAME
22:44:51 sys@jpcdip04> Rem      sqlsessstart.sql - SQL session start
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    DESCRIPTION
22:44:51 sys@jpcdip04> Rem      Any commands which should be run at the start of all oracle
22:44:51 sys@jpcdip04> Rem      supplied scripts.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    NOTES
22:44:51 sys@jpcdip04> Rem      See sqlsessend.sql for the corresponding end script.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:44:51 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessstart.sql
22:44:51 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessstart.sql
22:44:51 sys@jpcdip04> Rem    SQL_PHASE: MISC
22:44:51 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:44:51 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:44:51 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:44:51 sys@jpcdip04> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
22:44:51 sys@jpcdip04> Rem    surman      03/08/13 - 16462837: Common start and end scripts
22:44:51 sys@jpcdip04> Rem    surman      03/08/13 - Created
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> alter session set "_ORACLE_SCRIPT" = true;

Session altered.

Elapsed: 00:00:00.00
22:44:51 sys@jpcdip04> create or replace
22:44:51   2  package body STANDARD is         -- careful on this line; SED edit occurs!
22:44:51   3  
22:44:51   4  subtype Cursor_Handle is binary_integer range 0..255;
22:44:51   5  
22:44:51   6  INVALID_USERENV_PARAMETER exception;
22:44:51   7  pragma EXCEPTION_INIT(INVALID_USERENV_PARAMETER, -2003);
22:44:51   8  
22:44:51   9  -- This exception is used by several sped-up STANDARD functions' ICDs to
22:44:51  10  -- indicate that the ICD is unable to compute the result, and that SQL should
22:44:51  11  -- be used to do the computation.
22:44:51  12  ICD_UNABLE_TO_COMPUTE exception;
22:44:51  13  pragma EXCEPTION_INIT(ICD_UNABLE_TO_COMPUTE, -6594);
22:44:51  14  
22:44:51  15  -- icds
22:44:51  16  
22:44:51  17    function pesxlt(ch VARCHAR2 CHARACTER SET ANY_CS,
22:44:51  18                    cpy VARCHAR2 CHARACTER SET ch%CHARSET,
22:44:51  19                    frm VARCHAR2 CHARACTER SET ch%CHARSET,
22:44:51  20                    too VARCHAR2 CHARACTER SET ch%CHARSET)
22:44:51  21          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:51  22      pragma interface (c,pesxlt);
22:44:51  23  
22:44:51  24  -- trig fns
22:44:51  25    function pesxco(c VARCHAR2 CHARACTER SET ANY_CS, format VARCHAR2) return raw;
22:44:51  26      pragma interface (c,pesxco);
22:44:51  27  
22:44:51  28    function pesxup(ch VARCHAR2 CHARACTER SET ANY_CS, format VARCHAR2)
22:44:51  29          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:51  30      pragma interface (c,pesxup);
22:44:51  31  
22:44:51  32    function pesxlo(ch VARCHAR2 CHARACTER SET ANY_CS, format VARCHAR2)
22:44:51  33          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:51  34      pragma interface (c,pesxlo);
22:44:51  35  
22:44:51  36    function pesxcp(ch VARCHAR2 CHARACTER SET ANY_CS, format VARCHAR2)
22:44:51  37          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:51  38      pragma interface (c,pesxcp);
22:44:51  39  
22:44:51  40  -- end of NLS icds
22:44:51  41  
22:44:51  42  -- begin trusted icds
22:44:51  43  -- Comparisons
22:44:51  44  -- Conversions
22:44:51  45  --  function peslts(label MLSLABEL,format VARCHAR2) return VARCHAR2;
22:44:51  46  --    pragma interface (c,peslts);
22:44:51  47  --  function pesstl(label varchar2,format VARCHAR2) return MLSLABEL;
22:44:51  48  --    pragma interface (c,pesstl);
22:44:51  49  -- end trusted icds
22:44:51  50  -----------------------------------------------------------
22:44:51  51  
22:44:51  52    -- Body for sqlerrm. Not necessary, since COG special-cases this flavor
22:44:51  53    -- of sqlerrm, and never actually calls the body. But the body is required
22:44:51  54    -- because the spec has no pragma builtin or interface on it. So just whine
22:44:51  55    -- if this is ever called
22:44:51  56    function sqlerrm return varchar2 is
22:44:51  57    begin
22:44:51  58      RAISE program_error;
22:44:51  59      return NULL;
22:44:51  60    end sqlerrm;
22:44:51  61  
22:44:51  62    function pessdx (ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:51  63          return VARCHAR2 CHARACTER SET ch%CHARSET;
22:44:51  64      pragma interface (c,pessdx);
22:44:51  65  
22:44:51  66    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
22:44:51  67    -- the old 'select soundex(...) from dual;' thing.  This allows us to do the
22:44:51  68    -- SELECT from PL/SQL rather than having to do it from C (within the ICD.)
22:44:51  69    function SOUNDEX(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:51  70          return VARCHAR2 CHARACTER SET ch%CHARSET is
22:44:51  71      c VARCHAR2(2000) CHARACTER SET ch%CHARSET;
22:44:51  72    begin
22:44:51  73      c := pessdx(ch);
22:44:51  74      return c;
22:44:51  75    exception
22:44:51  76      when ICD_UNABLE_TO_COMPUTE then
22:44:51  77        select soundex(ch) into c from sys.dual;
22:44:51  78        return c;
22:44:51  79    end SOUNDEX;
22:44:51  80  
22:44:51  81    function TRANSLATE(STR1 VARCHAR2 CHARACTER SET ANY_CS,
22:44:51  82                       SRC VARCHAR2 CHARACTER SET STR1%CHARSET,
22:44:51  83                       DEST VARCHAR2 CHARACTER SET STR1%CHARSET)
22:44:51  84          return VARCHAR2 CHARACTER SET STR1%CHARSET is
22:44:51  85    begin
22:44:51  86      if str1 is null then return str1; else
22:44:51  87          -- The substr and concat in arg list to pesxlt is done to
22:44:51  88          -- allocate a modifiable COPY of the first arg, STR1. This
22:44:51  89          -- operation is a complete cheat, because we pass the copy
22:44:51  90          -- as an IN parm, and modify it on the sly.
22:44:51  91      return pesxlt(STR1, substr(str1,1,1) || substr(str1,2),
22:44:51  92                             SRC, DEST);
22:44:51  93      end if;
22:44:51  94    end TRANSLATE;
22:44:51  95  
22:44:51  96   function 'IS NAN' (N NUMBER) RETURN BOOLEAN is
22:44:51  97   begin
22:44:51  98     if N IS NULL then
22:44:51  99       return NULL;
22:44:51 100     else
22:44:51 101       return FALSE;
22:44:51 102     end if;
22:44:51 103   end 'IS NAN';
22:44:51 104  
22:44:51 105   function 'IS NOT NAN' (N NUMBER) RETURN BOOLEAN is
22:44:51 106   begin
22:44:51 107     if N IS NULL then
22:44:51 108       return NULL;
22:44:51 109     else
22:44:51 110       return TRUE;
22:44:51 111     end if;
22:44:51 112   end 'IS NOT NAN';
22:44:51 113  
22:44:51 114   function NANVL(n1 NUMBER, n2 NUMBER) return NUMBER is
22:44:51 115   begin
22:44:51 116     return (n1);
22:44:51 117   end NANVL;
22:44:51 118  
22:44:51 119   function NANVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT is
22:44:51 120   begin
22:44:51 121     if f1 is nan then return (f2); else return (f1); end if;
22:44:51 122   end NANVL;
22:44:51 123  
22:44:51 124   function NANVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE is
22:44:51 125   begin
22:44:51 126     if d1 is nan then return (d2); else return (d1); end if;
22:44:51 127   end NANVL;
22:44:51 128  
22:44:51 129   function TO_DATE(LEFT NUMBER, RIGHT VARCHAR2) return DATE IS
22:44:51 130   begin
22:44:51 131     return (TO_DATE(TO_char(LEFT), RIGHT));
22:44:51 132   end TO_DATE;
22:44:51 133  
22:44:51 134    -- Bug 27091470: Calling SYS_CONTEXT results in a considerable
22:44:51 135    -- speed-up as opposed to directly calling SQL like before.
22:44:51 136    -- If for some reason, the ICD cannot be called, then SYS_CONTEXT
22:44:51 137    -- will draw upon SQL's routine. This change is applied to UID
22:44:51 138    -- and USER.
22:44:51 139  
22:44:51 140    function UID return PLS_INTEGER is
22:44:51 141    begin
22:44:51 142          return SYS_CONTEXT('USERENV', 'SESSION_USERID');
22:44:51 143    end;
22:44:51 144  
22:44:51 145    function USER return varchar2 is
22:44:51 146    begin
22:44:51 147          return SYS_CONTEXT('USERENV', 'SESSION_USER');
22:44:51 148    end;
22:44:51 149  
22:44:51 150  
22:44:51 151    function pesuen(envstr VARCHAR2) return VARCHAR2;
22:44:51 152      pragma interface (c,pesuen);
22:44:51 153  
22:44:51 154    -- Bug 27091470: In order to get this function to execute faster, the
22:44:51 155    -- pesuen() ICD is in progress of being deprecated, as SYS_CONTEXT features
22:44:51 156    -- a cleaner and faster execution. In case the ICD is unavailable,
22:44:51 157    -- SYS_CONTEXT will call SQL like before. There are exceptions to this rule,
22:44:51 158    -- of course:
22:44:51 159    --    * ENTRYID: In the case pesuen() returns '0', SYS_CONTEXT returns NULL.
22:44:51 160    --               This difference is currently being investigated.
22:44:51 161    --
22:44:51 162    --    * SCHEMAID: This case runs all right. It's not included within the 'IN'
22:44:51 163    --                clause, as the SYS_CONTEXT parameter is named differently.
22:44:51 164    --
22:44:51 165    --    * PID: We have not found whether it's possible to get this value by
22:44:51 166    --           means of SYS_CONTEXT.
22:44:51 167    --
22:44:51 168    -- Partially deprecated: Only ENTRYID and PID still call pesuen() ICD and
22:44:51 169    -- if an exception is raised, then SQL. The rest have been moved to
22:44:51 170    -- calling SYS_CONTEXT.
22:44:51 171    --
22:44:51 172    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
22:44:51 173    -- the old 'select userenv(...) from dual;' thing.  This allows us to do the
22:44:51 174    -- select from PL/SQL rather than having to do it from C (within the ICD.)
22:44:51 175    function USERENV (envstr varchar2) return varchar2 is
22:44:51 176    c varchar2(255);
22:44:51 177    begin
22:44:51 178      if envstr is null then
22:44:51 179        raise INVALID_USERENV_PARAMETER;
22:44:51 180      end if;
22:44:51 181      c := upper(envstr);
22:44:51 182  
22:44:51 183      -- The comment below refers to a partially deprecated functionality. It
22:44:51 184      -- is still applied to only ENTRYID and PID parameters.
22:44:51 185  
22:44:51 186      -- Gaak: we can't replace the following with a single block of code based
22:44:51 187      -- around 'USERENV(c)' because passing USERENV() anything but a string
22:44:51 188      -- literal parameter result in ORA-2003: Invalid USERENV parameter!  This
22:44:51 189      -- also means that we must manually update this file whenever RDBMS adds a
22:44:51 190      -- new option.
22:44:51 191      if c = 'COMMITSCN' then
22:44:51 192        raise USERENV_COMMITSCN_ERROR;
22:44:51 193      elsif c in ('TERMINAL', 'SESSIONID', 'LANGUAGE', 'LANG',
22:44:51 194                  'INSTANCE', 'CLIENT_INFO', 'ISDBA', 'SID') then
22:44:51 195        c := SYS_CONTEXT('USERENV', c);
22:44:51 196      elsif c = 'ENTRYID' then
22:44:51 197        begin
22:44:51 198          c := pesuen(c);
22:44:51 199        exception
22:44:51 200          when ICD_UNABLE_TO_COMPUTE then
22:44:51 201            select userenv('ENTRYID') into c from sys.dual;
22:44:51 202        end;
22:44:51 203      elsif c = 'SCHEMAID' then
22:44:51 204        c := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMAID');
22:44:51 205      elsif c = 'PID' then
22:44:51 206        begin
22:44:51 207          c := pesuen(c);
22:44:51 208        exception
22:44:51 209          when ICD_UNABLE_TO_COMPUTE then
22:44:51 210            select userenv('PID') into c from sys.dual;
22:44:51 211        end;
22:44:51 212      else
22:44:51 213        raise INVALID_USERENV_PARAMETER;
22:44:51 214      end if;
22:44:51 215      return c;
22:44:51 216    end;
22:44:51 217  
22:44:51 218  -- Trusted*Oracle additions
22:44:51 219  
22:44:51 220    Function ROWLABEL return MLSLABEL is
22:44:51 221          begin return null; end;
22:44:51 222  -- removed - now builtin's
22:44:51 223  
22:44:51 224  --  Function TO_CHAR(label MLSLABEL, format varchar2 := '')
22:44:51 225  --       return VARCHAR2 is
22:44:51 226  --    begin return peslts(label,format); end;
22:44:51 227  --
22:44:51 228  --  Function TO_LABEL(label varchar2, format varchar2 := '')
22:44:51 229  --       return MLSLABEL is
22:44:51 230  --    begin return pesstl(label,format); end;
22:44:51 231  
22:44:51 232  -- group functions
22:44:51 233    Function LUB (label MLSLABEL) return MLSLABEL is
22:44:51 234          begin return null; end;
22:44:51 235    Function GLB (label MLSLABEL) return MLSLABEL is
22:44:51 236          begin return null; end;
22:44:51 237  
22:44:51 238  -- end of Trusted*Oracle additions
22:44:51 239  
22:44:51 240  
22:44:51 241  -- beginning of NLS routines
22:44:51 242  -- replaced with new versions 6/3/92 JEM
22:44:51 243  
22:44:51 244    function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS) return RAW is
22:44:51 245    begin
22:44:51 246      return pesxco(c,'');
22:44:51 247    end NLSSORT;
22:44:51 248  
22:44:51 249    function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:51 250          return VARCHAR2 CHARACTER SET ch%CHARSET is
22:44:51 251    begin
22:44:51 252      return pesxup(ch,'');
22:44:51 253    end NLS_UPPER;
22:44:51 254  
22:44:51 255    function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:51 256          return VARCHAR2 CHARACTER SET ch%CHARSET is
22:44:51 257    begin
22:44:51 258      return pesxlo(ch,'');
22:44:51 259    end NLS_LOWER;
22:44:51 260  
22:44:51 261    function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
22:44:51 262          return VARCHAR2 CHARACTER SET ch%CHARSET is
22:44:51 263    begin
22:44:51 264      return pesxcp(ch,'');
22:44:51 265    end NLS_INITCAP;
22:44:51 266  
22:44:51 267    function NLS_CHARSET_NAME(csetid PLS_INTEGER)
22:44:51 268      return VARCHAR2 is
22:44:51 269     v varchar2(2000);
22:44:51 270    begin
22:44:51 271     select nls_charset_name(csetid) into v from sys.dual;
22:44:51 272     return v;
22:44:51 273    end NLS_CHARSET_NAME;
22:44:51 274  
22:44:51 275    function NLS_CHARSET_ID(csetname VARCHAR2)
22:44:51 276      return PLS_INTEGER is
22:44:51 277     i PLS_INTEGER;
22:44:51 278    begin
22:44:51 279     select nls_charset_id(csetname) into i from sys.dual;
22:44:51 280     return i;
22:44:51 281    end NLS_CHARSET_ID;
22:44:51 282  
22:44:51 283    function NLS_CHARSET_DECL_LEN(bytecnt NUMBER, csetid NUMBER)
22:44:51 284      return PLS_INTEGER is
22:44:51 285     i PLS_INTEGER;
22:44:51 286    begin
22:44:51 287     select nls_charset_decl_len(bytecnt, csetid) into i from sys.dual;
22:44:51 288     return i;
22:44:51 289    end NLS_CHARSET_DECL_LEN;
22:44:51 290  -- end of NLS routines
22:44:51 291  
22:44:51 292  
22:44:51 293  -- DUMP and VSIZE are now not allowed in non-sql plsql, has code to forbid
22:44:51 294  -- it there, and is defined as a builtin in stdspc. The body will not be
22:44:51 295  -- called in plsql.
22:44:51 296  --- CMB
22:44:51 297  ----
22:44:51 298  -- dump
22:44:51 299  -- dump( expr [,display_format[,start_pos[,length]]]) return varchar2
22:44:51 300  -- how large should the plsql varchar2 string be
22:44:51 301  --
22:44:51 302  
22:44:51 303  -- why do we need these dummy bodies for LEVEL and ROWNUM?
22:44:51 304  
22:44:51 305    function LEVEL return NUMBER is
22:44:51 306          begin return 0.0; end;
22:44:51 307  
22:44:51 308    function ROWNUM return NUMBER is
22:44:51 309          begin return 0.0; end;
22:44:51 310  
22:44:51 311  --
22:44:51 312  -- ACOS, ASIN, ATAN, ATAN2
22:44:51 313  --   These functions return NULL if any of the inputs are NULL
22:44:51 314  --
22:44:51 315    function pesacos(n NUMBER) return NUMBER;
22:44:51 316      pragma interface (c,pesacos);
22:44:51 317  
22:44:51 318    function pesasin(n NUMBER) return NUMBER;
22:44:51 319      pragma interface (c,pesasin);
22:44:51 320  
22:44:51 321    function pesatn2(x NUMBER, y NUMBER) return NUMBER;
22:44:51 322      pragma interface (c,pesatn2);
22:44:51 323  
22:44:51 324    function ACOS(n NUMBER) return NUMBER is
22:44:51 325    begin
22:44:51 326      if (n > 1) or (n < -1) then raise VALUE_ERROR; end if;
22:44:51 327      return pesacos(n);
22:44:51 328    end ACOS;
22:44:51 329  
22:44:51 330    function ASIN(n NUMBER) return NUMBER is
22:44:51 331    begin
22:44:51 332      if (n > 1) or (n < -1) then raise VALUE_ERROR; end if;
22:44:51 333      return pesasin(n);
22:44:51 334    end ASIN;
22:44:51 335  
22:44:51 336    function ATAN2(x NUMBER, y NUMBER) return NUMBER is
22:44:51 337    begin
22:44:51 338      if ((x = 0) and (y = 0)) then raise VALUE_ERROR; end if;
22:44:51 339      return pesatn2(x, y);
22:44:51 340    end ATAN2;
22:44:51 341  
22:44:51 342  --****************************************************************
22:44:51 343  
22:44:51 344    -- This body is required, and will be called
22:44:51 345    function NVL (B1 "<REF_CURSOR_1>", B2 "<REF_CURSOR_1>")
22:44:51 346          return "<REF_CURSOR_1>" is
22:44:51 347    begin
22:44:51 348      if (B1 IS NULL) then return(B2); else return(B1); end if;
22:44:51 349    end NVL;
22:44:51 350  
22:44:51 351    /* these are special internal functions
22:44:51 352       they are potential dangerous and not to be used by customers */
22:44:51 353    function "SYS$LOB_REPLICATION" (x in blob) return blob
22:44:51 354          is begin return x; end;
22:44:51 355    function "SYS$LOB_REPLICATION" (x in clob character set any_cs)
22:44:51 356      return clob character set x%charset
22:44:51 357    is begin return x; end;
22:44:51 358  
22:44:51 359    --  Generic SQL DDL routine
22:44:51 360    --
22:44:51 361    --  This used to use plzopn, plzosq, etc. declared above;  now we use a
22:44:51 362    --  single bundled call.  Move these defs here so new ICD will not disturb
22:44:51 363    --  the ordering of the list.
22:44:51 364  
22:44:51 365    FUNCTION plzsql(stmt VARCHAR2) RETURN binary_integer;
22:44:51 366    PRAGMA interface (c,plzsql);
22:44:51 367  
22:44:51 368    procedure SQL_DDL(Stmt VARCHAR2) is
22:44:51 369           rc Binary_Integer;
22:44:51 370           DDL_ERROR exception;
22:44:51 371    Begin
22:44:51 372           rc := plzsql(Stmt);
22:44:51 373           if ( rc IS NOT NULL ) then
22:44:51 374                  RAISE DDL_ERROR;
22:44:51 375           end if;
22:44:51 376    End;
22:44:51 377  
22:44:51 378    --  SQL Transaction routines
22:44:51 379  
22:44:51 380    procedure SET_TRANSACTION_USE (vc varchar2) is
22:44:51 381    Begin
22:44:51 382           SQL_DDL('SET TRANSACTION USE ROLLBACK SEGMENT ' || vc);
22:44:51 383    End;
22:44:51 384  
22:44:51 385    procedure COMMIT is
22:44:51 386    Begin
22:44:51 387           SQL_DDL('COMMIT');
22:44:51 388    End;
22:44:51 389  
22:44:51 390    procedure COMMIT_CM (vc varchar2) is
22:44:51 391    Begin
22:44:51 392      -- bug13944958:
22:44:51 393      -- COMMIT_CM procedure takes the input argument "vs" as the comment string
22:44:51 394      -- to execute the SQL DDL "COMMIT work comment 'vc'" statement.
22:44:51 395      -- The input comment string to the COMMIT statement is vulnerable to
22:44:51 396      -- SQL injection because it may contain single-quotes.
22:44:51 397      -- Before we manually quote the comment string, we need to escape any
22:44:51 398      -- embedded quotes first.
22:44:51 399      SQL_DDL('COMMIT work comment ' || '''' ||
22:44:51 400              replace(vc, '''', '''''') || '''');
22:44:51 401    End;
22:44:51 402  
22:44:51 403    procedure ROLLBACK_NR is
22:44:51 404    Begin
22:44:51 405           SQL_DDL('ROLLBACK');
22:44:51 406    End;
22:44:51 407  
22:44:51 408    procedure ROLLBACK_SV(Save_Point CHAR) is
22:44:51 409    Begin
22:44:51 410           SQL_DDL('ROLLBACK TO ' || Save_Point);
22:44:51 411    End;
22:44:51 412  
22:44:51 413    procedure SAVEPOINT(Save_Point CHAR) is
22:44:51 414    begin
22:44:51 415           SQL_DDL('SAVEPOINT ' || Save_Point);
22:44:51 416    end;
22:44:51 417  
22:44:51 418  
22:44:51 419  ------ Datetime code starts here ------
22:44:51 420  
22:44:51 421  
22:44:51 422  -- functions to create intervals from constituent parts.
22:44:51 423  
22:44:51 424    function pesn2ymi(numerator number, units number)
22:44:51 425      return yminterval_unconstrained;
22:44:51 426    pragma interface (c,pesn2ymi);
22:44:51 427    function pesn2dsi(numerator number, units number)
22:44:51 428       return dsinterval_unconstrained;
22:44:51 429    pragma interface (c,pesn2dsi);
22:44:51 430  
22:44:51 431   function NUMTOYMINTERVAL(numerator number, units varchar2 character set any_cs)
22:44:51 432       return yminterval_unconstrained
22:44:51 433       IS unitno NUMBER := 0;
22:44:51 434          unitstr VARCHAR2(5) character set units%charset := upper(trim(units));
22:44:51 435       begin
22:44:51 436       IF (unitstr = 'YEAR')  THEN unitno := 1;
22:44:51 437       elsif (unitstr = 'MONTH') THEN unitno := 2;
22:44:51 438       END IF;
22:44:51 439       return pesn2ymi(numerator,unitno);
22:44:51 440       -- IF unitno := 0 core will RAISE correct error
22:44:51 441       end;
22:44:51 442  
22:44:51 443   function NUMTODSINTERVAL(numerator number, units varchar2 character set any_cs)
22:44:51 444       return dsinterval_unconstrained
22:44:51 445       IS unitno NUMBER := 0;
22:44:51 446          unitstr VARCHAR2(6) character set units%charset := upper(trim(units));
22:44:51 447       begin
22:44:51 448       IF (unitstr = 'DAY') THEN  unitno := 1;
22:44:51 449       elsif (unitstr = 'HOUR') THEN unitno := 2;
22:44:51 450       elsif (unitstr = 'MINUTE') THEN  unitno := 3;
22:44:51 451       elsif (unitstr = 'SECOND') THEN unitno := 4;
22:44:51 452       END IF;
22:44:51 453       return pesn2dsi(numerator,unitno);
22:44:51 454       -- IF unitno = 0 core will RAISE correct error
22:44:51 455       end;
22:44:51 456  
22:44:51 457    function pessdt return DATE;
22:44:51 458      pragma interface (c,pessdt);
22:44:51 459  
22:44:51 460    -- Bug 1287775: back to calling ICD.
22:44:51 461    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
22:44:51 462    -- the old 'SELECT SYSDATE FROM DUAL;' thing.  This allows us to do the
22:44:51 463    -- SELECT from PL/SQL rather than having to do it from C (within the ICD.)
22:44:51 464    function sysdate return date is
22:44:51 465      d date;
22:44:51 466    begin
22:44:51 467      d := pessdt;
22:44:51 468      return d;
22:44:51 469    exception
22:44:51 470      when ICD_UNABLE_TO_COMPUTE then
22:44:51 471        select sysdate into d from sys.dual;
22:44:51 472        return d;
22:44:51 473    end;
22:44:51 474  
22:44:51 475    function pesguid return RAW;
22:44:51 476      pragma interface (c,pesguid);
22:44:51 477  
22:44:51 478    function SYS_GUID return raw is
22:44:51 479      c raw(16);
22:44:51 480    begin
22:44:51 481      c := pesguid;
22:44:51 482      return c;
22:44:51 483    exception
22:44:51 484      when ICD_UNABLE_TO_COMPUTE then
22:44:51 485          select sys_guid() into c from sys.dual;
22:44:51 486          return c;
22:44:51 487    end;
22:44:51 488  
22:44:51 489    function pessysctx2(namespace varchar2, attribute varchar2) return varchar2;
22:44:51 490      pragma interface (c,pessysctx2);
22:44:51 491  
22:44:51 492    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
22:44:51 493    -- the old 'select sys_context(...) from dual;' thing.  This allows us to do
22:44:51 494    -- the select from PL/SQL rather than having to do it from C (within the ICD.)
22:44:51 495    function SYS_CONTEXT(namespace varchar2, attribute varchar2)
22:44:51 496      return varchar2 is
22:44:51 497    c varchar2(4000);
22:44:51 498    BEGIN
22:44:51 499      c := pessysctx2(namespace, attribute);
22:44:51 500      return c;
22:44:51 501    exception
22:44:51 502      when ICD_UNABLE_TO_COMPUTE then
22:44:51 503        select sys_context(namespace,attribute) into c from sys.dual;
22:44:51 504        return c;
22:44:51 505    end;
22:44:51 506  
22:44:51 507  -- time zone functions
22:44:51 508  
22:44:51 509    function pessts return timestamp_tz_unconstrained;
22:44:51 510      pragma interface (c,pessts);
22:44:51 511  
22:44:51 512    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
22:44:51 513    -- the old 'SELECT systimestamp FROM dual;' thing.  This allows us to do the
22:44:51 514    -- SELECT from PL/SQL rather than having to do it from C (within the ICD.)
22:44:51 515    FUNCTION systimestamp RETURN timestamp_tz_unconstrained
22:44:51 516    IS  t timestamp_tz_unconstrained;
22:44:51 517    BEGIN
22:44:51 518      t := pessts;
22:44:51 519      RETURN t;
22:44:51 520    EXCEPTION
22:44:51 521      WHEN ICD_UNABLE_TO_COMPUTE THEN
22:44:51 522        SELECT systimestamp INTO t FROM sys.dual;
22:44:51 523        RETURN t;
22:44:51 524    END;
22:44:51 525  
22:44:51 526    function pesdbtz return varchar2;
22:44:51 527      pragma interface (c,pesdbtz);
22:44:51 528  
22:44:51 529    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
22:44:51 530    -- the old 'SELECT dbtimezone FROM dual;' thing.  This allows us to do the
22:44:51 531    -- SELECT from PL/SQL rather than having to do it from C (within the ICD.)
22:44:51 532    FUNCTION dbtimezone RETURN varchar2
22:44:51 533    IS  t VARCHAR2(75);                                -- == TZNMSTRLEN [2213965]
22:44:51 534    BEGIN
22:44:51 535      t := pesdbtz;
22:44:51 536      RETURN t;
22:44:51 537    EXCEPTION
22:44:51 538      WHEN ICD_UNABLE_TO_COMPUTE THEN
22:44:51 539        SELECT dbtimezone INTO t FROM sys.dual;
22:44:51 540        RETURN t;
22:44:51 541    END;
22:44:51 542  
22:44:51 543    FUNCTION localtimestamp RETURN timestamp_unconstrained
22:44:51 544    IS t timestamp_tz_unconstrained := current_timestamp;
22:44:51 545    BEGIN
22:44:51 546     RETURN (cast(t AS timestamp_unconstrained));
22:44:51 547    END;
22:44:51 548  
22:44:51 549    FUNCTION localtime RETURN time_unconstrained
22:44:51 550    IS t time_tz_unconstrained := current_time;
22:44:51 551    BEGIN
22:44:51 552     RETURN (cast(t AS time_unconstrained));
22:44:51 553    END;
22:44:51 554  
22:44:51 555    function pessysctx3(namespace varchar2, attribute varchar2,
22:44:51 556                        newoptional varchar2) return varchar2;
22:44:51 557      pragma interface (c,pessysctx3);
22:44:51 558  
22:44:51 559    -- Special: if the ICD raises ICD_UNABLE_TO_COMPUTE, that means we should do
22:44:51 560    -- the old 'select sys_context(...) from dual;' thing.  This allows us to do
22:44:51 561    -- the select from PL/SQL rather than having to do it from C (within the ICD.)
22:44:51 562    function SYS_CONTEXT(namespace varchar2, attribute varchar2,
22:44:51 563                         newoptional varchar2)
22:44:51 564      return varchar2 is
22:44:51 565    c varchar2(4000);
22:44:51 566    BEGIN
22:44:51 567      c := pessysctx3(namespace, attribute, newoptional);
22:44:51 568      return c;
22:44:51 569    exception
22:44:51 570      when ICD_UNABLE_TO_COMPUTE then
22:44:51 571        select sys_context(namespace,attribute,newoptional) into c from sys.dual;
22:44:51 572        return c;
22:44:51 573    end;
22:44:51 574  
22:44:51 575    function TO_NCLOB(cl CLOB CHARACTER SET ANY_CS) return NCLOB is
22:44:51 576    begin
22:44:51 577      return cl;
22:44:51 578    end;
22:44:51 579    function TO_CLOB(cl CLOB CHARACTER SET ANY_CS) return CLOB is
22:44:51 580    begin
22:44:51 581      return cl;
22:44:51 582    end;
22:44:51 583  
22:44:51 584    function NCHR(n INTEGER) return NVARCHAR2 is
22:44:51 585    begin
22:44:51 586      return CHR(n using NCHAR_CS);
22:44:51 587    end;
22:44:51 588  
22:44:51 589  -- REFs of opaque types are not yet supported.
22:44:51 590  --  function NVL (B1 REF "<OPAQUE_1>", B2 REF "<OPAQUE_1>")
22:44:51 591  --         return REF "<OPAQUE_1>" is
22:44:51 592  --  begin
22:44:51 593  --    if (B1 IS NULL) then return(B2); else return(B1); end if;
22:44:51 594  --  end NVL;
22:44:51 595  
22:44:51 596  
22:44:51 597  -- END OF PACKAGE standard
22:44:51 598  end;
22:44:51 599  
22:44:51 600  
22:44:51 601  
22:44:51 602  /

Package body created.

Elapsed: 00:00:00.06
22:44:51 sys@jpcdip04> @?/rdbms/admin/sqlsessend.sql
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem $Header: rdbms/admin/sqlsessend.sql /main/3 2018/07/25 13:50:02 surman Exp $
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem sqlsessend.sql
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
22:44:51 sys@jpcdip04> Rem All rights reserved.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    NAME
22:44:51 sys@jpcdip04> Rem      sqlsessend.sql - SQL session end
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    DESCRIPTION
22:44:51 sys@jpcdip04> Rem      Any commands which should be run at the end of all oracle
22:44:51 sys@jpcdip04> Rem      supplied scripts.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    NOTES
22:44:51 sys@jpcdip04> Rem      See sqlsessstart.sql for the corresponding start script.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:44:51 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessend.sql
22:44:51 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessend.sql
22:44:51 sys@jpcdip04> Rem    SQL_PHASE: MISC
22:44:51 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:44:51 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:44:51 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:44:51 sys@jpcdip04> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
22:44:51 sys@jpcdip04> Rem    surman      03/08/13 - 16462837: Common start and end scripts
22:44:51 sys@jpcdip04> Rem    surman      03/08/13 - Created
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> alter session set "_ORACLE_SCRIPT" = false;

Session altered.

Elapsed: 00:00:00.00
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> grant execute on STANDARD to public;

Grant succeeded.

Elapsed: 00:00:00.20
22:44:51 sys@jpcdip04> @?/rdbms/admin/sqlsessend.sql
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem $Header: rdbms/admin/sqlsessend.sql /main/3 2018/07/25 13:50:02 surman Exp $
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem sqlsessend.sql
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
22:44:51 sys@jpcdip04> Rem All rights reserved.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    NAME
22:44:51 sys@jpcdip04> Rem      sqlsessend.sql - SQL session end
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    DESCRIPTION
22:44:51 sys@jpcdip04> Rem      Any commands which should be run at the end of all oracle
22:44:51 sys@jpcdip04> Rem      supplied scripts.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    NOTES
22:44:51 sys@jpcdip04> Rem      See sqlsessstart.sql for the corresponding start script.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:44:51 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessend.sql
22:44:51 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessend.sql
22:44:51 sys@jpcdip04> Rem    SQL_PHASE: MISC
22:44:51 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:44:51 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:44:51 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:44:51 sys@jpcdip04> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
22:44:51 sys@jpcdip04> Rem    surman      03/08/13 - 16462837: Common start and end scripts
22:44:51 sys@jpcdip04> Rem    surman      03/08/13 - Created
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> alter session set "_ORACLE_SCRIPT" = false;

Session altered.

Elapsed: 00:00:00.00
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> @@&dbmsstdx
22:44:51 sys@jpcdip04> rem
22:44:51 sys@jpcdip04> rem $Header: rdbms/admin/dbmsstdx.sql /main/32 2015/02/15 21:52:00 sylin Exp $
22:44:51 sys@jpcdip04> rem
22:44:51 sys@jpcdip04> Rem Copyright (c) 1991, 2015, Oracle and/or its affiliates.
22:44:51 sys@jpcdip04> Rem All rights reserved.
22:44:51 sys@jpcdip04> Rem    NAME
22:44:51 sys@jpcdip04> Rem      stdext.sql - Kernel extensions to package standard
22:44:51 sys@jpcdip04> Rem    DESCRIPTION
22:44:51 sys@jpcdip04> Rem      Routines in this package do not need to be qualified by the
22:44:51 sys@jpcdip04> Rem      owner or package name, similar to the behaviour of package
22:44:51 sys@jpcdip04> Rem      'standard'.  This package mostly contains utility routines for
22:44:51 sys@jpcdip04> Rem      triggers.
22:44:51 sys@jpcdip04> Rem    RETURNS
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    NOTES
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem BEGIN SQL_FILE_METADATA
22:44:51 sys@jpcdip04> Rem SQL_SOURCE_FILE: rdbms/admin/dbmsstdx.sql
22:44:51 sys@jpcdip04> Rem SQL_SHIPPED_FILE: rdbms/admin/dbmsstdx.sql
22:44:51 sys@jpcdip04> Rem SQL_PHASE: DBMSSTDX
22:44:51 sys@jpcdip04> Rem SQL_STARTUP_MODE: NORMAL
22:44:51 sys@jpcdip04> Rem SQL_IGNORABLE_ERRORS: NONE
22:44:51 sys@jpcdip04> Rem SQL_CALLING_FILE: rdbms/admin/cdstrt.sql
22:44:51 sys@jpcdip04> Rem END SQL_FILE_METADATA
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:44:51 sys@jpcdip04> Rem     sylin      01/22/15  - 20387919: add ora_max_name_len_supported
22:44:51 sys@jpcdip04> Rem     traney     12/04/14  - 41716: long identifiers
22:44:51 sys@jpcdip04> Rem     surman     12/29/13  - 13922626: Update SQL metadata
22:44:51 sys@jpcdip04> Rem     rpang      07/23/12  - 14362485: add original_sql_txt
22:44:51 sys@jpcdip04> Rem     surman     03/27/12  - 13615447: Add SQL patching tags
22:44:51 sys@jpcdip04> Rem     lvbcheng   01/13/11  - 128: dbms_id and dbms_quoted_id
22:44:51 sys@jpcdip04> Rem     dalpern    03/17/09  - bug 7646876: applying_crossedition_trigger
22:44:51 sys@jpcdip04> Rem     sagrawal   05/15/06  - sys_GetTriggerState
22:44:51 sys@jpcdip04> Rem     gviswana   05/24/01  - CREATE OR REPLACE SYNONYM
22:44:51 sys@jpcdip04> Rem     ykunitom   04/04/01  - fix bug 1473966
22:44:51 sys@jpcdip04> Rem     weiwang    05/02/00  - add error functions
22:44:51 sys@jpcdip04> Rem     najain     04/25/00  - add partition_pos function
22:44:51 sys@jpcdip04> Rem     najain     04/14/00  - add sqltext attr. func
22:44:51 sys@jpcdip04> Rem     weiwang    02/28/00 -  fix bug 1209532
22:44:51 sys@jpcdip04> Rem     weiwang    08/02/99 -  change name_list_t to ora_name_list_t
22:44:51 sys@jpcdip04> Rem     weiwang    02/09/99 -  add isdropcolumn, isaltercolumn
22:44:51 sys@jpcdip04> Rem     weiwang    09/15/98 -  add function des_encrypted_password
22:44:51 sys@jpcdip04> Rem     weiwang    06/11/98 -  add function dictionary_obj_owner
22:44:51 sys@jpcdip04> Rem     jkrishna   05/05/98 -  support for error events
22:44:51 sys@jpcdip04> Rem     jkrishna   04/01/98 -  adding system event callouts
22:44:51 sys@jpcdip04> Rem     cbarclay   11/06/96 -  remove kkxl*em
22:44:51 sys@jpcdip04> Rem     mmonajje   09/16/96 -  Fixing bug 244014; Adding RESTRICT_REFERENCES pr
22:44:51 sys@jpcdip04> Rem     ramkrish   06/28/96 -  Add EMPTY_BLOB, EMPTY_CLOB routines
22:44:51 sys@jpcdip04> Rem     hjakobss   10/16/94 -  bug 151485 - remove sql_ddl
22:44:51 sys@jpcdip04> Rem     jwijaya    04/05/93 -  merge changes from branch 1.3.312.1
22:44:51 sys@jpcdip04> Rem     jwijaya    03/26/93 -  bug 157348
22:44:51 sys@jpcdip04> Rem     rkooi      11/28/92 -  add 'keep' option to raise_application_error
22:44:51 sys@jpcdip04> Rem     rkooi      10/25/92 -  deal with null arg to rae
22:44:51 sys@jpcdip04> Rem     glumpkin   10/21/92 -  Renamed from STDEXT.SQL
22:44:51 sys@jpcdip04> Rem     mmoore     09/24/92 - #(130568) add callback for commit comment
22:44:51 sys@jpcdip04> Rem     rkooi      09/02/92 -  change pls_integer to binary_integer
22:44:51 sys@jpcdip04> Rem     mmoore     08/12/92 -  override the savepoint command in standard
22:44:51 sys@jpcdip04> Rem     rkooi      06/10/92 -  add 'do not change' comment
22:44:51 sys@jpcdip04> Rem     mmoore     04/14/92 -  move begin_oltp to package transaction
22:44:51 sys@jpcdip04> Rem     rkooi      04/06/92 -  merge changes from branch 1.7.300.1
22:44:51 sys@jpcdip04> Rem     rkooi      04/02/92 -  split dbms_standard into separate pkgs
22:44:51 sys@jpcdip04> Rem     maporter   03/25/92 -  renumber 8200 to 8175
22:44:51 sys@jpcdip04> Rem     rbamford   03/07/92 -  add BEGIN_OLTP_TRANSACTION
22:44:51 sys@jpcdip04> Rem     mroberts   02/21/92 -  delete extra rollback_sv procedure
22:44:51 sys@jpcdip04> Rem     rkooi      02/17/92 -  add set_role and related procedures
22:44:51 sys@jpcdip04> Rem     mroberts   02/14/92 -  add execute_ddl internal
22:44:51 sys@jpcdip04> Rem     mmoore     02/06/92 -  change name of package
22:44:51 sys@jpcdip04> Rem     mmoore     01/14/92 -  add rollback_nr
22:44:51 sys@jpcdip04> Rem     mmoore     01/09/92 -  speed up
22:44:51 sys@jpcdip04> Rem      rkooi      11/24/91 -  rename to stdext.sql from stdext.pls
22:44:51 sys@jpcdip04> Rem      rkooi      08/26/91 -  get rid of stack_application_error
22:44:51 sys@jpcdip04> Rem      rkooi      05/08/91 -  change name to standard_extension
22:44:51 sys@jpcdip04> Rem      rkooi      05/02/91 -  forgot skip_row procedure
22:44:51 sys@jpcdip04> Rem      mmoore     05/02/91 -  move trigger icds to psd, use varchar2 in
22:44:51 sys@jpcdip04> Rem                             rae/sae
22:44:51 sys@jpcdip04> Rem      rkooi      04/23/91 -  add 'skip_row' procedure, commit etc.
22:44:51 sys@jpcdip04> Rem                             procedures.
22:44:51 sys@jpcdip04> Rem      Moore      04/02/91 -  fix typo
22:44:51 sys@jpcdip04> Rem      Moore      03/28/91 -  add boolean trigger functions
22:44:51 sys@jpcdip04> Rem      Kooi       03/17/91 -  Creation
22:44:51 sys@jpcdip04> Rem      Kooi       03/12/91 -  change name to standard_utilities
22:44:51 sys@jpcdip04> Rem      Kooi       02/26/91 -  get rid of raise now that psdkse does it
22:44:51 sys@jpcdip04> Rem      Kooi       02/26/91 -  Creation
22:44:51 sys@jpcdip04> ------------------------------------------------------------------------------
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> @@?/rdbms/admin/sqlsessstart.sql
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem $Header: rdbms/admin/sqlsessstart.sql /main/3 2018/07/25 13:50:02 surman Exp $
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem sqlsessstart.sql
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
22:44:51 sys@jpcdip04> Rem All rights reserved.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    NAME
22:44:51 sys@jpcdip04> Rem      sqlsessstart.sql - SQL session start
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    DESCRIPTION
22:44:51 sys@jpcdip04> Rem      Any commands which should be run at the start of all oracle
22:44:51 sys@jpcdip04> Rem      supplied scripts.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    NOTES
22:44:51 sys@jpcdip04> Rem      See sqlsessend.sql for the corresponding end script.
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:44:51 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessstart.sql
22:44:51 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessstart.sql
22:44:51 sys@jpcdip04> Rem    SQL_PHASE: MISC
22:44:51 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:44:51 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:44:51 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:44:51 sys@jpcdip04> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
22:44:51 sys@jpcdip04> Rem    surman      03/08/13 - 16462837: Common start and end scripts
22:44:51 sys@jpcdip04> Rem    surman      03/08/13 - Created
22:44:51 sys@jpcdip04> Rem
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> alter session set "_ORACLE_SCRIPT" = true;

Session altered.

Elapsed: 00:00:00.00
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> REM *****************************************************************
22:44:51 sys@jpcdip04> REM THIS PACKAGE MUST NOT BE MODIFIED BY THE CUSTOMER.  DOING SO
22:44:51 sys@jpcdip04> REM COULD CAUSE INTERNAL ERRORS AND SECURITY VIOLATIONS IN THE RDBMS.
22:44:51 sys@jpcdip04> REM *****************************************************************
22:44:51 sys@jpcdip04> 
22:44:51 sys@jpcdip04> create or replace package dbms_standard is
22:44:51   2  
22:44:51   3    -- constant defines maximum name length possible
22:44:51   4    ORA_MAX_NAME_LEN constant pls_integer := 128;
22:44:51   5  
22:44:51   6    -- types
22:44:51   7     type ora_name_list_t is table of varchar2(2*(ORA_MAX_NAME_LEN+2)+1);
22:44:51   8  
22:44:51   9    -- DBMS_ID and DBMS_QUOTED_ID define the length of identifiers
22:44:51  10    -- in objects for SQL, PL/SQL and users.
22:44:51  11     subtype dbms_id is varchar2(ORA_MAX_NAME_LEN);
22:44:51  12     subtype dbms_quoted_id is varchar2(ORA_MAX_NAME_LEN+2);
22:44:51  13  
22:44:51  14     subtype dbms_id_30 is varchar2(30);
22:44:51  15     subtype dbms_quoted_id_30 is varchar2(32);
22:44:51  16     subtype dbms_id_128 is varchar2(ORA_MAX_NAME_LEN);
22:44:51  17     subtype dbms_quoted_id_128 is varchar2(ORA_MAX_NAME_LEN+2);
22:44:51  18  
22:44:51  19    -- Trigger Operations
22:44:51  20    procedure raise_application_error(num binary_integer, msg varchar2,
22:44:51  21        keeperrorstack boolean default FALSE);
22:44:51  22      pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
22:44:51  23      pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
22:44:51  24    function inserting return boolean;
22:44:51  25      pragma interface (C, inserting);                       -- 2
22:44:51  26      pragma restrict_references (inserting, WNPS, RNPS, WNDS);
22:44:51  27    function deleting  return boolean;
22:44:51  28      pragma interface (C, deleting);                        -- 3
22:44:51  29      pragma restrict_references (deleting, WNPS, RNPS, WNDS);
22:44:51  30    function updating  return boolean;
22:44:51  31      pragma interface (C, updating);                        -- 4
22:44:51  32      pragma restrict_references (updating, WNPS, RNPS, WNDS);
22:44:51  33    function updating (colnam varchar2) return boolean;
22:44:51  34      pragma interface (C, updating);                        -- 5
22:44:51  35      pragma restrict_references (updating, WNPS, RNPS, WNDS);
22:44:51  36  
22:44:51  37    -- Transaction Commands
22:44:51  38    procedure commit;
22:44:51  39      pragma interface (C, commit);                          -- 6
22:44:51  40    procedure commit_cm(vc varchar2);
22:44:51  41      pragma interface (C, commit_cm);                       -- 7
22:44:51  42    procedure rollback_nr;
22:44:51  43      pragma interface (C, rollback_nr);                     -- 8
22:44:51  44    procedure rollback_sv(save_point varchar2);
22:44:51  45      pragma interface (C, rollback_sv);                     -- 9
22:44:51  46    procedure savepoint(save_point varchar2);
22:44:51  47      pragma interface (C, savepoint);                       -- 10
22:44:51  48    procedure set_transaction_use(vc varchar2);
22:44:51  49      pragma interface (C, set_transaction_use);             -- 11
22:44:51  50  
22:44:51  51  
22:44:51  52    -- Functions supported for system events
22:44:51  53    -- Null or zero will be returned if called in inappropriate occasions
22:44:51  54    -- error functions only search for the top 5 errors in the error stack
22:44:51  55  
22:44:51  56    function sysevent return varchar2 ;                      -- 12
22:44:51  57      pragma interface (C, sysevent);
22:44:51  58      pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
22:44:51  59    function dictionary_obj_type return varchar2 ;           -- 13
22:44:51  60      pragma interface (C, dictionary_obj_type);
22:44:51  61      pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
22:44:51  62     function dictionary_obj_owner return varchar2 ;           -- 14
22:44:51  63      pragma interface (C, dictionary_obj_owner);
22:44:51  64      pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
22:44:51  65    function dictionary_obj_name return varchar2 ;           -- 15
22:44:51  66      pragma interface (C, dictionary_obj_name);
22:44:51  67      pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
22:44:51  68    function database_name return varchar2 ;                 -- 16
22:44:51  69      pragma interface (C, database_name);
22:44:51  70      pragma restrict_references (database_name, WNPS, RNPS, WNDS);
22:44:51  71    function instance_num return binary_integer ;            -- 17
22:44:51  72      pragma interface (C, instance_num);
22:44:51  73      pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
22:44:51  74    function login_user return varchar2 ;                    -- 18
22:44:51  75      pragma interface (C, login_user);
22:44:51  76      pragma restrict_references (login_user, WNPS, RNPS, WNDS);
22:44:51  77    function is_servererror (errno binary_integer)
22:44:51  78                  return boolean ;                           -- 19
22:44:51  79      pragma interface (C, is_servererror);
22:44:51  80      pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);
22:44:51  81  
22:44:51  82    function server_error(position binary_integer)
22:44:51  83                          return binary_integer ;           -- 20
22:44:51  84      pragma interface (C, server_error);
22:44:51  85      pragma restrict_references (server_error, WNPS, RNPS, WNDS);
22:44:51  86    function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
22:44:51  87      pragma interface (C, des_encrypted_password);
22:44:51  88      pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
22:44:51  89    function is_alter_column (column_name varchar2)
22:44:51  90                  return boolean ;                           -- 22
22:44:51  91      pragma interface (C, is_alter_column);
22:44:51  92      pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
22:44:51  93    function is_drop_column (column_name varchar2)
22:44:51  94                  return boolean ;                           -- 23
22:44:51  95      pragma interface (C, is_drop_column);
22:44:51  96      pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
22:44:51  97    function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
22:44:51  98      pragma interface (C, grantee);
22:44:51  99      pragma restrict_references (grantee, WNPS, RNPS, WNDS);
22:44:51 100    function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
22:44:51 101      pragma interface (C, revokee);
22:44:51 102      pragma restrict_references (revokee, WNPS, RNPS, WNDS);
22:44:51 103    function privilege_list (priv_list out ora_name_list_t)
22:44:51 104                  return binary_integer ;                    -- 26
22:44:51 105      pragma interface (C, privilege_list);
22:44:51 106      pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
22:44:51 107    function with_grant_option return boolean ;                    -- 27
22:44:51 108      pragma interface (C, with_grant_option);
22:44:51 109      pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
22:44:51 110    function dictionary_obj_owner_list (owner_list out ora_name_list_t)
22:44:51 111                  return binary_integer;                           -- 28
22:44:51 112      pragma interface (C, dictionary_obj_owner_list);
22:44:51 113      pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
22:44:51 114    function dictionary_obj_name_list (object_list out ora_name_list_t)
22:44:51 115                  return binary_integer;                           -- 29
22:44:51 116      pragma interface (C, dictionary_obj_name_list);
22:44:51 117      pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
22:44:51 118    function is_creating_nested_table return boolean;              -- 30
22:44:51 119      pragma interface (C, is_creating_nested_table);
22:44:51 120      pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
22:44:51 121    function client_ip_address return varchar2;                    -- 31
22:44:51 122      pragma interface (C, client_ip_address);
22:44:51 123      pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
22:44:51 124    function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
22:44:51 125      pragma interface (C, sql_txt);
22:44:51 126      pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
22:44:51 127    function server_error_msg (position binary_integer) return varchar2; -- 33
22:44:51 128      pragma interface (C, server_error_msg);
22:44:51 129      pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
22:44:51 130    function server_error_depth return binary_integer;              -- 34
22:44:51 131      pragma interface (C, server_error_depth);
22:44:51 132      pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
22:44:51 133    function server_error_num_params (position binary_integer)
22:44:51 134                                     return binary_integer;         -- 35
22:44:51 135      pragma interface (C, server_error_num_params);
22:44:51 136      pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
22:44:51 137    function server_error_param(position binary_integer, param binary_integer)
22:44:51 138                                return varchar2;                    -- 36
22:44:51 139      pragma interface (C, server_error_param);
22:44:51 140      pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
22:44:51 141    function partition_pos return binary_integer;                  -- 37
22:44:51 142      pragma interface (C, partition_pos);
22:44:51 143      pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);
22:44:51 144  
22:44:51 145    function sys_GetTriggerState  return pls_integer;
22:44:51 146      pragma interface (C, Sys_GetTriggerState);                        -- 38
22:44:51 147      pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
22:44:51 148    function applying_crossedition_trigger return boolean;
22:44:51 149      pragma interface (C, applying_crossedition_trigger);              -- 39
22:44:51 150      pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
22:44:51 151  
22:44:51 152    function original_sql_txt (sql_text out ora_name_list_t)
22:44:51 153             return binary_integer;                                     -- 40
22:44:51 154      pragma interface (C, original_sql_txt);
22:44:51 155      pragma restrict_references (original_sql_txt, WNPS, RNPS, WNDS);
22:44:51 156  
22:44:51 157  /*-----------------------------------------------------------------------------
22:44:51 158    Function: return maximum name length supported
22:44:51 159      If compatible >= 12.2.0.0, returns 128.
22:44:51 160      If compatible < 12.2.0.0, returns 30.
22:44:51 161   */
22:44:51 162  
22:44:51 163    function ora_max_name_len_supported return pls_integer;
22:44:51 164      pragma interface (C, ora_max_name_len_supported);
22:44:51 165  end;
22:44:51 166  /

Package created.

Elapsed: 00:00:00.16
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> create or replace public synonym dbms_standard for sys.dbms_standard
22:44:52   2  /

Synonym created.

Elapsed: 00:00:00.01
22:44:52 sys@jpcdip04> grant execute on dbms_standard to public
22:44:52   2  /

Grant succeeded.

Elapsed: 00:00:00.00
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> @?/rdbms/admin/sqlsessend.sql
22:44:52 sys@jpcdip04> Rem
22:44:52 sys@jpcdip04> Rem $Header: rdbms/admin/sqlsessend.sql /main/3 2018/07/25 13:50:02 surman Exp $
22:44:52 sys@jpcdip04> Rem
22:44:52 sys@jpcdip04> Rem sqlsessend.sql
22:44:52 sys@jpcdip04> Rem
22:44:52 sys@jpcdip04> Rem Copyright (c) 2013, 2018, Oracle and/or its affiliates.
22:44:52 sys@jpcdip04> Rem All rights reserved.
22:44:52 sys@jpcdip04> Rem
22:44:52 sys@jpcdip04> Rem    NAME
22:44:52 sys@jpcdip04> Rem      sqlsessend.sql - SQL session end
22:44:52 sys@jpcdip04> Rem
22:44:52 sys@jpcdip04> Rem    DESCRIPTION
22:44:52 sys@jpcdip04> Rem      Any commands which should be run at the end of all oracle
22:44:52 sys@jpcdip04> Rem      supplied scripts.
22:44:52 sys@jpcdip04> Rem
22:44:52 sys@jpcdip04> Rem    NOTES
22:44:52 sys@jpcdip04> Rem      See sqlsessstart.sql for the corresponding start script.
22:44:52 sys@jpcdip04> Rem
22:44:52 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:44:52 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/sqlsessend.sql
22:44:52 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/sqlsessend.sql
22:44:52 sys@jpcdip04> Rem    SQL_PHASE: MISC
22:44:52 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:44:52 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:44:52 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:44:52 sys@jpcdip04> Rem
22:44:52 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:44:52 sys@jpcdip04> Rem    surman      05/04/18 - 27464252: Update SQL_PHASE
22:44:52 sys@jpcdip04> Rem    surman      03/08/13 - 16462837: Common start and end scripts
22:44:52 sys@jpcdip04> Rem    surman      03/08/13 - Created
22:44:52 sys@jpcdip04> Rem
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> alter session set "_ORACLE_SCRIPT" = false;

Session altered.

Elapsed: 00:00:00.00
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> alter session set "_force_standard_compile"=FALSE;

Session altered.

Elapsed: 00:00:00.01
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> -- Step (III)
22:44:52 sys@jpcdip04> --
22:44:52 sys@jpcdip04> -- Invalidate views and synonyms which depend (directly or indirectly) on
22:44:52 sys@jpcdip04> -- invalid objects.
22:44:52 sys@jpcdip04> begin
22:44:52   2    loop
22:44:52   3      update obj$ o_outer set status = 6
22:44:52   4      where     type# in (4, 5)
22:44:52   5            and status not in (5, 6)
22:44:52   6            and linkname is null
22:44:52   7            and ((subname is null) or (subname <> 'DBMS_DBUPGRADE_BABY'))
22:44:52   8            and exists (select o.obj# from obj$ o, dependency$ d
22:44:52   9                        where     d.d_obj# = o_outer.obj#
22:44:52  10                              and d.p_obj# = o.obj#
22:44:52  11                              and (bitand(d.property, 1) = 1)
22:44:52  12                              and o.status > 1);
22:44:52  13      exit when sql%notfound;
22:44:52  14    end loop;
22:44:52  15  end;
22:44:52  16  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.06
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> commit;

Commit complete.

Elapsed: 00:00:00.00
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.01
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> -- Step (IV)
22:44:52 sys@jpcdip04> --
22:44:52 sys@jpcdip04> -- Delete Diana for tables, views, and sequences
22:44:52 sys@jpcdip04> --
22:44:52 sys@jpcdip04> -- The DELETEs are coded in chunks using a PL/SQL loop to avoid running
22:44:52 sys@jpcdip04> -- into rollback segment limits.
22:44:52 sys@jpcdip04> --
22:44:52 sys@jpcdip04> begin
22:44:52   2  
22:44:52   3     loop
22:44:52   4        delete from idl_ub1$ where
22:44:52   5           obj# in (select o.obj# from obj$ o where o.type# in (2, 4, 6))
22:44:52   6           and rownum < 5000;
22:44:52   7        exit when sql%rowcount = 0;
22:44:52   8        commit;
22:44:52   9     end loop;
22:44:52  10  
22:44:52  11     --
22:44:52  12     -- IDL_UB2$ must use dynamic SQL because its PIECE type is not
22:44:52  13     -- understood by PL/SQL.
22:44:52  14     --
22:44:52  15     loop
22:44:52  16        execute immediate
22:44:52  17           'delete from idl_ub2$ where
22:44:52  18            obj# in (select o.obj# from obj$ o where o.type# in (2, 4, 6))
22:44:52  19            and rownum < 5000';
22:44:52  20        exit when sql%rowcount = 0;
22:44:52  21        commit;
22:44:52  22     end loop;
22:44:52  23  
22:44:52  24     --
22:44:52  25     -- IDL_SB4$ must use dynamic SQL because its PIECE type is not
22:44:52  26     -- understood by PL/SQL.
22:44:52  27     --
22:44:52  28     loop
22:44:52  29        execute immediate
22:44:52  30           'delete from idl_sb4$ where
22:44:52  31            obj# in (select o.obj# from obj$ o where o.type# in (2, 4, 6))
22:44:52  32            and rownum < 5000';
22:44:52  33        exit when sql%rowcount = 0;
22:44:52  34        commit;
22:44:52  35     end loop;
22:44:52  36  
22:44:52  37     loop
22:44:52  38        delete from idl_char$ where
22:44:52  39           obj# in (select o.obj# from obj$ o where o.type# in (2, 4, 6))
22:44:52  40           and rownum < 5000;
22:44:52  41        exit when sql%rowcount = 0;
22:44:52  42        commit;
22:44:52  43     end loop;
22:44:52  44  end;
22:44:52  45  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.07
22:44:52 sys@jpcdip04> commit;

Commit complete.

Elapsed: 00:00:00.00
22:44:52 sys@jpcdip04> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.00
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> Rem Continue even if there are SQL errors
22:44:52 sys@jpcdip04> WHENEVER SQLERROR CONTINUE;
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> Rem ===========================================================================
22:44:52 sys@jpcdip04> Rem END utlip.sql
22:44:52 sys@jpcdip04> Rem ===========================================================================
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> -- explicitly compile these now, before close/reopen. Otherwise they would
22:44:52 sys@jpcdip04> -- be used/validated within PDB Open, where such patching (clearing of dict
22:44:52 sys@jpcdip04> -- rows) can't be done.
22:44:52 sys@jpcdip04> alter session set "_ORACLE_SCRIPT"=true;

Session altered.

Elapsed: 00:00:00.01
22:44:52 sys@jpcdip04> alter public synonym ALL_OBJECTS compile;

Synonym altered.

Elapsed: 00:00:00.17
22:44:52 sys@jpcdip04> alter view SYS.V_$PARAMETER compile;

View altered.

Elapsed: 00:00:00.03
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> WHENEVER SQLERROR CONTINUE;
22:44:52 sys@jpcdip04> alter type SYS.ANYDATA compile;

Type altered.

Elapsed: 00:00:00.20
22:44:52 sys@jpcdip04> WHENEVER SQLERROR EXIT;
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> alter session set "_ORACLE_SCRIPT"=false;

Session altered.

Elapsed: 00:00:00.00
22:44:52 sys@jpcdip04> 
22:44:52 sys@jpcdip04> alter pluggable database "&pdbname" close immediate instances=all;

Pluggable database altered.

Elapsed: 00:00:29.90
22:45:22 sys@jpcdip04> alter pluggable database "&pdbname" open restricted;

Warning: PDB altered with errors.

Elapsed: 00:00:17.02
22:45:39 sys@jpcdip04> 
22:45:39 sys@jpcdip04> -- mark old version types as valid, as utlrp skips these
22:45:39 sys@jpcdip04> update sys.obj$ set status = 1
22:45:39   2    where type#=13 and subname is not null and status > 1;

153 rows updated.

Elapsed: 00:00:00.04
22:45:39 sys@jpcdip04> commit;

Commit complete.

Elapsed: 00:00:00.04
22:45:39 sys@jpcdip04> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.01
22:45:39 sys@jpcdip04> 
22:45:39 sys@jpcdip04> -- 26434999: set concurrent stats gathering to OFF, save original value
22:45:39 sys@jpcdip04> COLUMN concurrent NEW_VALUE concurrent
22:45:39 sys@jpcdip04> select dbms_stats.get_prefs('CONCURRENT') concurrent from dual;

CONCURRENT
--------------------------------------------------------------------------------
OFF

1 row selected.

Elapsed: 00:00:38.75
22:46:18 sys@jpcdip04> exec dbms_stats.set_global_prefs('CONCURRENT', 'OFF');

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.03
22:46:18 sys@jpcdip04> 
22:46:18 sys@jpcdip04> @@?/rdbms/admin/utlrp
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem $Header: rdbms/admin/utlrp.sql /main/23 2017/03/20 12:21:12 raeburns Exp $
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem utlrp.sql
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem Copyright (c) 1998, 2017, Oracle and/or its affiliates.
22:46:18 sys@jpcdip04> Rem All rights reserved.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem    NAME
22:46:18 sys@jpcdip04> Rem      utlrp.sql - Recompile invalid objects
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem    DESCRIPTION
22:46:18 sys@jpcdip04> Rem     This script recompiles invalid objects in the database.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem     When run as one of the last steps during upgrade or downgrade,
22:46:18 sys@jpcdip04> Rem     this script will validate all remaining invalid objects. It will
22:46:18 sys@jpcdip04> Rem     also run a component validation procedure for each component in
22:46:18 sys@jpcdip04> Rem     the database. See the README notes for your current release and
22:46:18 sys@jpcdip04> Rem     the Oracle Database Upgrade book for more information about
22:46:18 sys@jpcdip04> Rem     using utlrp.sql
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem     Although invalid objects are automatically re-validated when used,
22:46:18 sys@jpcdip04> Rem     it is useful to run this script after an upgrade or downgrade and
22:46:18 sys@jpcdip04> Rem     after applying a patch. This minimizes latencies caused by
22:46:18 sys@jpcdip04> Rem     on-demand recompilation. Oracle strongly recommends running this
22:46:18 sys@jpcdip04> Rem     script after upgrades, downgrades and patches.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem   NOTES
22:46:18 sys@jpcdip04> Rem      * This script must be run using SQL*PLUS.
22:46:18 sys@jpcdip04> Rem      * You must be connected AS SYSDBA to run this script.
22:46:18 sys@jpcdip04> Rem      * There should be no other DDL on the database while running the
22:46:18 sys@jpcdip04> Rem        script.  Not following this recommendation may lead to deadlocks.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:46:18 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/utlrp.sql
22:46:18 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/utlrp.sql
22:46:18 sys@jpcdip04> Rem    SQL_PHASE: UTILITY
22:46:18 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:46:18 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:46:18 sys@jpcdip04> Rem    SQL_CALLING_FILE: NONE
22:46:18 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:46:18 sys@jpcdip04> Rem    raeburns    03/09/17 - Bug 25616909: Use UTILITY for SQL_PHASE
22:46:18 sys@jpcdip04> Rem    gviswana    06/26/03 - Switch default to parallel if appropriate
22:46:18 sys@jpcdip04> Rem    gviswana    06/12/03 - Switch default back to serial
22:46:18 sys@jpcdip04> Rem    gviswana    05/20/03 - 2814808: Automatic parallelism tuning
22:46:18 sys@jpcdip04> Rem    rburns      04/28/03 - timestamps and serveroutput for diagnostics
22:46:18 sys@jpcdip04> Rem    gviswana    04/13/03 - utlrcmp.sql load -> catproc
22:46:18 sys@jpcdip04> Rem    gviswana    06/25/02 - Add documentation
22:46:18 sys@jpcdip04> Rem    gviswana    11/12/01 - Use utl_recomp.recomp_serial
22:46:18 sys@jpcdip04> Rem    rdecker     11/09/01 - ADD ALTER library support FOR bug 1952368
22:46:18 sys@jpcdip04> Rem    rburns      11/12/01 - validate all components after compiles
22:46:18 sys@jpcdip04> Rem    rburns      11/06/01 - fix invalid CATPROC call
22:46:18 sys@jpcdip04> Rem    rburns      09/29/01 - use 9.2.0
22:46:18 sys@jpcdip04> Rem    rburns      09/20/01 - add check for CATPROC valid
22:46:18 sys@jpcdip04> Rem    rburns      07/06/01 - get version from instance view
22:46:18 sys@jpcdip04> Rem    rburns      05/09/01 - fix for use with 8.1.x
22:46:18 sys@jpcdip04> Rem    arithikr    04/17/01 - 1703753: recompile object type# 29,32,33
22:46:18 sys@jpcdip04> Rem    skabraha    09/25/00 - validate is now a keyword
22:46:18 sys@jpcdip04> Rem    kosinski    06/14/00 - Persistent parameters
22:46:18 sys@jpcdip04> Rem    skabraha    06/05/00 - validate tables also
22:46:18 sys@jpcdip04> Rem    jdavison    04/11/00 - Modify usage notes for 8.2 changes.
22:46:18 sys@jpcdip04> Rem    rshaikh     09/22/99 - quote name for recompile
22:46:18 sys@jpcdip04> Rem    ncramesh    08/04/98 - change for sqlplus
22:46:18 sys@jpcdip04> Rem    usundara    06/03/98 - merge from 8.0.5
22:46:18 sys@jpcdip04> Rem    usundara    04/29/98 - creation (split from utlirp.sql).
22:46:18 sys@jpcdip04> Rem                           Mark Ramacher (mramache) was the original
22:46:18 sys@jpcdip04> Rem                           author of this script.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> 
22:46:18 sys@jpcdip04> Rem ===========================================================================
22:46:18 sys@jpcdip04> Rem BEGIN utlrp.sql
22:46:18 sys@jpcdip04> Rem ===========================================================================
22:46:18 sys@jpcdip04> 
22:46:18 sys@jpcdip04> @@utlprp.sql 0
22:46:18 sys@jpcdip04> Rem Copyright (c) 2003, 2017, Oracle and/or its affiliates.
22:46:18 sys@jpcdip04> Rem All rights reserved.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem    NAME
22:46:18 sys@jpcdip04> Rem      utlprp.sql - Recompile invalid objects in the database
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem    DESCRIPTION
22:46:18 sys@jpcdip04> Rem      This script recompiles invalid objects in the database.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem      This script is typically used to recompile invalid objects
22:46:18 sys@jpcdip04> Rem      remaining at the end of a database upgrade or downgrade.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem      Although invalid objects are automatically recompiled on demand,
22:46:18 sys@jpcdip04> Rem      running this script ahead of time will reduce or eliminate
22:46:18 sys@jpcdip04> Rem      latencies due to automatic recompilation.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem      This script is a wrapper based on the UTL_RECOMP package.
22:46:18 sys@jpcdip04> Rem      UTL_RECOMP provides a more general recompilation interface,
22:46:18 sys@jpcdip04> Rem      including options to recompile objects in a single schema. Please
22:46:18 sys@jpcdip04> Rem      see the documentation for package UTL_RECOMP for more details.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem    INPUTS
22:46:18 sys@jpcdip04> Rem      The degree of parallelism for recompilation can be controlled by
22:46:18 sys@jpcdip04> Rem      providing a parameter to this script. If this parameter is 0 or
22:46:18 sys@jpcdip04> Rem      NULL, UTL_RECOMP will automatically determine the appropriate
22:46:18 sys@jpcdip04> Rem      level of parallelism based on Oracle parameters cpu_count and
22:46:18 sys@jpcdip04> Rem      parallel_threads_per_cpu. If the parameter is 1, sequential
22:46:18 sys@jpcdip04> Rem      recompilation is used. Please see the documentation for package
22:46:18 sys@jpcdip04> Rem      UTL_RECOMP for more details.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem    NOTES
22:46:18 sys@jpcdip04> Rem      * You must be connected AS SYSDBA to run this script.
22:46:18 sys@jpcdip04> Rem      * There should be no other DDL on the database while running the
22:46:18 sys@jpcdip04> Rem        script.  Not following this recommendation may lead to deadlocks.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem    BEGIN SQL_FILE_METADATA
22:46:18 sys@jpcdip04> Rem    SQL_SOURCE_FILE: rdbms/admin/utlprp.sql
22:46:18 sys@jpcdip04> Rem    SQL_SHIPPED_FILE: rdbms/admin/utlprp.sql
22:46:18 sys@jpcdip04> Rem    SQL_PHASE: UTILITY
22:46:18 sys@jpcdip04> Rem    SQL_STARTUP_MODE: NORMAL
22:46:18 sys@jpcdip04> Rem    SQL_IGNORABLE_ERRORS: NONE
22:46:18 sys@jpcdip04> Rem    SQL_CALLING_FILE: utlrp.sql
22:46:18 sys@jpcdip04> Rem    END SQL_FILE_METADATA
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> Rem    MODIFIED   (MM/DD/YY)
22:46:18 sys@jpcdip04> Rem    thbaby      05/11/17 - Bug 26046188: disable redirection in Proxy PDB
22:46:18 sys@jpcdip04> Rem    raeburns    04/15/17 - Bug 25790192: Add SQL_METADATA
22:46:18 sys@jpcdip04> Rem    jmuller     12/09/14 - Fix bug 19728696 (sort of): clarify comments
22:46:18 sys@jpcdip04> Rem    pyam        04/08/14 - 18478064: factor out to reenable_indexes.sql
22:46:18 sys@jpcdip04> Rem    kquinn      11/01/11 - 13059165: amend 'OBJECTS WITH ERRORS' SQL
22:46:18 sys@jpcdip04> Rem    cdilling    05/15/10 - fix bug 9712478 - call local enquote_name
22:46:18 sys@jpcdip04> Rem    anighosh    02/19/09 - #(8264899): re-enabling of function based indexes
22:46:18 sys@jpcdip04> Rem                           not needed.
22:46:18 sys@jpcdip04> Rem    cdilling    07/21/08 - check bitand for functional index - bug 7243270
22:46:18 sys@jpcdip04> Rem    cdilling    01/21/08 - add support for ORA-30552
22:46:18 sys@jpcdip04> Rem    cdilling    08/27/07 - check disabled indexes only
22:46:18 sys@jpcdip04> Rem    cdilling    05/22/07 - add support for ORA-38301
22:46:18 sys@jpcdip04> Rem    cdilling    02/19/07 - 5530085 - renable invalid indexes
22:46:18 sys@jpcdip04> Rem    rburns      03/17/05 - use dbms_registry_sys
22:46:18 sys@jpcdip04> Rem    gviswana    02/07/05 - Post-compilation diagnostics
22:46:18 sys@jpcdip04> Rem    gviswana    09/09/04 - Auto tuning and diagnosability
22:46:18 sys@jpcdip04> Rem    rburns      09/20/04 - fix validate_components
22:46:18 sys@jpcdip04> Rem    gviswana    12/09/03 - Move functional-index re-enable here
22:46:18 sys@jpcdip04> Rem    gviswana    06/04/03 - gviswana_bug-2814808
22:46:18 sys@jpcdip04> Rem    gviswana    05/28/03 - Created
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> 
22:46:18 sys@jpcdip04> SET VERIFY OFF;
22:46:18 sys@jpcdip04> 
22:46:18 sys@jpcdip04> Rem Bug 26046188: In a Proxy PDB, all top-level statements are redirected to
22:46:18 sys@jpcdip04> Rem the target (PDB) of the Proxy PDB. Set underscore parameter so that
22:46:18 sys@jpcdip04> Rem automatic redirection is turned off. This is needed so that utlrp/utlprp
22:46:18 sys@jpcdip04> Rem can be used to recompile objects in Proxy PDB.
22:46:18 sys@jpcdip04> Rem
22:46:18 sys@jpcdip04> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
22:46:18 sys@jpcdip04> 
22:46:18 sys@jpcdip04> SELECT dbms_registry_sys.time_stamp('utlrp_bgn') as timestamp from dual;

TIMESTAMP
--------------------------------------------------------------------------------
COMP_TIMESTAMP UTLRP_BGN              2024-03-06 22:46:18

1 row selected.

Elapsed: 00:00:00.56
22:46:18 sys@jpcdip04> 
22:46:18 sys@jpcdip04> DOC
22:46:18 DOC>   The following PL/SQL block invokes UTL_RECOMP to recompile invalid
22:46:18 DOC>   objects in the database. Recompilation time is proportional to the
22:46:18 DOC>   number of invalid objects in the database, so this command may take
22:46:18 DOC>   a long time to execute on a database with a large number of invalid
22:46:18 DOC>   objects.
22:46:18 DOC>
22:46:18 DOC>   Use the following queries to track recompilation progress:
22:46:18 DOC>
22:46:18 DOC>   1. Query returning the number of invalid objects remaining. This
22:46:18 DOC>      number should decrease with time.
22:46:18 DOC>         SELECT COUNT(*) FROM obj$ WHERE status IN (4, 5, 6);
22:46:18 DOC>
22:46:18 DOC>   2. Query returning the number of objects compiled so far. This number
22:46:18 DOC>      should increase with time.
22:46:18 DOC>         SELECT COUNT(*) FROM UTL_RECOMP_COMPILED;
22:46:18 DOC>
22:46:18 DOC>   This script automatically chooses serial or parallel recompilation
22:46:18 DOC>   based on the number of CPUs available (parameter cpu_count) multiplied
22:46:18 DOC>   by the number of threads per CPU (parameter parallel_threads_per_cpu).
22:46:18 DOC>   On RAC, this number is added across all RAC nodes.
22:46:18 DOC>
22:46:18 DOC>   UTL_RECOMP uses DBMS_SCHEDULER to create jobs for parallel
22:46:18 DOC>   recompilation. Jobs are created without instance affinity so that they
22:46:18 DOC>   can migrate across RAC nodes. Use the following queries to verify
22:46:18 DOC>   whether UTL_RECOMP jobs are being created and run correctly:
22:46:18 DOC>
22:46:18 DOC>   1. Query showing jobs created by UTL_RECOMP
22:46:18 DOC>         SELECT job_name FROM dba_scheduler_jobs
22:46:18 DOC>            WHERE job_name like 'UTL_RECOMP_SLAVE_%';
22:46:18 DOC>
22:46:18 DOC>   2. Query showing UTL_RECOMP jobs that are running
22:46:18 DOC>         SELECT job_name FROM dba_scheduler_running_jobs
22:46:18 DOC>            WHERE job_name like 'UTL_RECOMP_SLAVE_%';
22:46:18 DOC>#
22:46:18 sys@jpcdip04> 
22:46:18 sys@jpcdip04> DECLARE
22:46:18   2     threads pls_integer := &&1;
22:46:18   3  BEGIN
22:46:18   4     utl_recomp.recomp_parallel(threads);
22:46:18   5  END;
22:46:18   6  /

-
0

1 row selected.

Elapsed: 00:00:00.01
22:51:08 sys@jpcdip04> 
22:51:08 sys@jpcdip04> -- run ALTER TABLE UPGRADE on table dependents of common types
22:51:08 sys@jpcdip04> -- note this is done after noncdb_to_pdb(2), because between (1) and (2),
22:51:08 sys@jpcdip04> -- the driver was changed to only compute signatures
22:51:08 sys@jpcdip04> DECLARE
22:51:08   2    cursor c is
22:51:08   3      select u.name owner, o.name object_name
22:51:08   4        from sys.obj$ o, sys.user$ u
22:51:08   5      where o.type#=2 and u.user#=o.owner# and obj# in
22:51:08   6        (select d_obj# from sys.dependency$ d, sys.obj$ typo where
22:51:08   7         typo.type#=13 and typo.obj#=d.p_obj# and d.p_timestamp <> typo.stime and
22:51:08   8         bitand(typo.flags, 196608)<>0 and
22:51:08   9         bitand(typo.flags, 134217728)=&fedobjflag);
22:51:08  10  BEGIN
22:51:08  11    FOR tab in c
22:51:08  12    LOOP
22:51:08  13      BEGIN
22:51:08  14        execute immediate 'ALTER TABLE ' ||
22:51:08  15                          dbms_assert.enquote_name(tab.owner, FALSE) || '.' ||
22:51:08  16                          dbms_assert.enquote_name(tab.object_name, FALSE) ||
22:51:08  17                          ' UPGRADE';
22:51:08  18      EXCEPTION
22:51:08  19        WHEN OTHERS THEN
22:51:08  20        BEGIN
22:51:08  21          IF (sqlcode = -600 or sqlcode = -602 or sqlcode = -603) THEN
22:51:08  22            raise;
22:51:08  23          END IF;
22:51:08  24        END;
22:51:08  25      END;
22:51:08  26    END LOOP;
22:51:08  27    commit;
22:51:08  28  END;
22:51:08  29  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.04
22:51:08 sys@jpcdip04> 
22:51:08 sys@jpcdip04> alter session set &scriptparam=false;

Session altered.

Elapsed: 00:00:00.00
22:51:08 sys@jpcdip04> 
22:51:08 sys@jpcdip04> alter pluggable database "&pdbname" close immediate instances=all;

Pluggable database altered.

Elapsed: 00:00:00.17
22:51:09 sys@jpcdip04> alter session set container = CDB$ROOT;

Session altered.

Elapsed: 00:00:00.00
22:51:09 sys@jpcdip04> alter system flush shared_pool;

System altered.

Elapsed: 00:00:00.01
22:51:09 sys@jpcdip04> /

System altered.

Elapsed: 00:00:00.01
22:51:09 sys@jpcdip04> /

System altered.

Elapsed: 00:00:00.00
22:51:09 sys@jpcdip04> alter session set container = "&pdbname";

Session altered.

Elapsed: 00:00:00.00
22:51:09 sys@jpcdip04> 
22:51:09 sys@jpcdip04> alter session set "_enable_view_pdb"=false;

Session altered.

Elapsed: 00:00:00.00
22:51:09 sys@jpcdip04> 
22:51:09 sys@jpcdip04> -- leave the PDB in the same state it was when we started
22:51:09 sys@jpcdip04> BEGIN
22:51:09   2    execute immediate '&open_sql &restricted_state';
22:51:09   3  EXCEPTION
22:51:09   4    WHEN OTHERS THEN
22:51:09   5    BEGIN
22:51:09   6      IF (sqlcode <> -900) THEN
22:51:09   7        RAISE;
22:51:09   8      END IF;
22:51:09   9    END;
22:51:09  10  END;
22:51:09  11  /

PL/SQL procedure successfully completed.

Elapsed: 00:00:00.00
22:51:09 sys@jpcdip04> 
22:51:09 sys@jpcdip04> WHENEVER SQLERROR CONTINUE;
22:51:09 sys@jpcdip04> 
22:51:09 sys@jpcdip04> 
22:51:09 sys@jpcdip04> 
22:51:09 sys@jpcdip04> -- restore old settings
22:51:09 sys@jpcdip04> START ncdb2pdb.settings.sql
SP2-0310: unable to open file "ncdb2pdb.settings.sql"
22:51:09 sys@jpcdip04> 
22:51:09 sys@jpcdip04> 
22:51:09 sys@jpcdip04> prompt Abriendo y verificando la nueva pdb
Abriendo y verificando la nueva pdb
22:51:09 sys@jpcdip04> alter pluggable database jpcdip04_s2 open read write;

Pluggable database altered.

Elapsed: 00:00:02.31
22:51:11 sys@jpcdip04> show pdbs

    CON_ID CON_NAME                       OPEN MODE  RESTRICTED
---------- ------------------------------ ---------- ----------
         4 JPCDIP04_S2                    READ WRITE NO
22:51:11 sys@jpcdip04> 
22:51:11 sys@jpcdip04> Prompt mostrando datafiles de la CDB
mostrando datafiles de la CDB
22:51:11 sys@jpcdip04> set linesize window
22:51:11 sys@jpcdip04> col file_name format A60
22:51:11 sys@jpcdip04> select file_id, file_name from cdb_data_files;

   FILE_ID FILE_NAME
---------- ------------------------------------------------------------
        25 /u01/app/oracle/oradata/JPCDIP04/jpcdip04_s2/users01.dbf
        24 /u01/app/oracle/oradata/JPCDIP04/jpcdip04_s2/undotbs01.dbf
        23 /u01/app/oracle/oradata/JPCDIP04/jpcdip04_s2/sysaux01.dbf
        22 /u01/app/oracle/oradata/JPCDIP04/jpcdip04_s2/system01.dbf

4 rows selected.

Elapsed: 00:00:00.03
22:51:11 sys@jpcdip04> 
22:51:11 sys@jpcdip04> pause Analizar resultados, [Enter] para continuar con Limpieza
Analizar resultados, [Enter] para continuar con Limpieza
22:51:11 sys@jpcdip04> 
22:51:11 sys@jpcdip04> prompt borrar PDB
borrar PDB
22:51:11 sys@jpcdip04> alter pluggable database jpcdip04_s2 close;

Pluggable database altered.

Elapsed: 00:00:01.92
22:51:13 sys@jpcdip04> drop  pluggable database jpcdip04_s2 including datafiles;
drop  pluggable database jpcdip04_s2 including datafiles
*
ERROR at line 1:
ORA-01109: database not open


Elapsed: 00:00:00.00
22:51:13 sys@jpcdip04> 
22:51:13 sys@jpcdip04> drop database link clone_link;
drop database link clone_link
                   *
ERROR at line 1:
ORA-01109: database not open


Elapsed: 00:00:00.00
22:51:13 sys@jpcdip04> 
22:51:13 sys@jpcdip04> prompt eliminando usuario en jpcdip01
eliminando usuario en jpcdip01

Database link dropped.

User dropped.

-----------------------------------------------------------------------------------
**CONCLUSIONES
Este ejercicio muestra cómo crear una Pluggable Database (PDB) en una CDB
a partir de una Non CDB utilizando un database link. 
Se inicia iniciando las CDBs involucradas y creando un usuario común en la 
CDB origen para realizar la conexión a través del database link. 
Luego, se crea el database link en la CDB destino y se clona la Non CDB 
en la CDB destino utilizando este enlace de base de datos. 
Después de abrir y verificar la nueva PDB, se realiza la limpieza eliminando
la PDB clonada, el database link y el usuario común.
Este ejercicio ilustra cómo utilizar database links para convertir una Non 
CDB en una PDB y cómo realizar esta operación entre diferentes CDBs. 
Además, resalta la importancia de tener usuarios y permisos adecuados 
para establecer la conexión a través del database link y 
realizar las operaciones de clonación de manera segura y eficiente.