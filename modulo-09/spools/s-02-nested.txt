##JORGE FRANCISCO PEREDA CEBALLOS
##12-04-2024
##Módulo 09. E-02- Nested loop.
-------------------------------------------

###Script
------------------------------------------------------
--@Autor: Jorge Francisco Pereda Ceballos
--@Fecha creación: 12/04/2024
--@Descripción: Ejercicio 02 - Módulo 09. Transformación OR expansion.

define syslogon='sys/system1 as sysdba'
define t_user='control_medico'
define userlogon='&t_user/&t_user'
define autotrace_opt='trace only'


Prompt conectando como &t_user
connect &userlogon

set linesize window

--consulta 1
create index receta_id_cantidad_idx on receta(cantidad);
create index medicamento_nombre_generico_idx on medicamento(nombre_generico);


Prompt conectando como SYS
connect &syslogon

Prompt B. Recolectando estadísticas
begin
  dbms_stats.gather_schema_stats (
      ownname => 'CONTROL_MEDICO',      
      degree  => 2
  );
end;
/

Prompt conectando como &t_user
connect &userlogon

Prompt Configurando autotrace 'set autotrace '
set autotrace &autotrace_opt

Prompt ====  Consulta 1  Nested loop
select m.medicamento_id, r.dias
from receta r
join medicamento m
on m.medicamento_id = r.medicamento_id 
where r.cantidad < 3
and m.nombre_generico like '%A';  

Prompt Eliminando índices
drop index receta_id_cantidad_idx;
drop index medicamento_nombre_generico_idx;

------------------------------------------------------


###Salida de ejecución
-----------------------------------------------------
control_medico@jpcdip01> start s-02-nested.sql
conectando como control_medico
Connected.

Index created.


Index created.

conectando como SYS
Connected.
B. Recolectando estadísticas

PL/SQL procedure successfully completed.

conectando como control_medico
Connected.
Configurando autotrace 'set autotrace '
SP2-0158: unknown SET option "only"
====  Consulta 1  Nested loop

no rows selected


Execution Plan
----------------------------------------------------------
Plan hash value: 1356951553

----------------------------------------------------------------------------------------------------------------
| Id  | Operation			      | Name		       | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT		      | 		       |     6 |   252 |    14	 (0)| 00:00:01 |
|   1 |  NESTED LOOPS			      | 		       |     6 |   252 |    14	 (0)| 00:00:01 |
|   2 |   NESTED LOOPS			      | 		       |     6 |   252 |    14	 (0)| 00:00:01 |
|   3 |    TABLE ACCESS BY INDEX ROWID BATCHED| RECETA		       |     6 |    66 |     8	 (0)| 00:00:01 |
|*  4 |     INDEX RANGE SCAN		      | RECETA_ID_CANTIDAD_IDX |     6 |       |     2	 (0)| 00:00:01 |
|*  5 |    INDEX UNIQUE SCAN		      | MEDICAMENTO_PK	       |     1 |       |     0	 (0)| 00:00:01 |
|*  6 |   TABLE ACCESS BY INDEX ROWID	      | MEDICAMENTO	       |     1 |    31 |     1	 (0)| 00:00:01 |
----------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access("R"."CANTIDAD"<3)
   5 - access("M"."MEDICAMENTO_ID"="R"."MEDICAMENTO_ID")
   6 - filter("M"."NOMBRE_GENERICO" LIKE '%A')


Statistics
----------------------------------------------------------
	  1  recursive calls
	  0  db block gets
	 31  consistent gets
	  0  physical reads
	  0  redo size
	432  bytes sent via SQL*Net to client
	507  bytes received via SQL*Net from client
	  1  SQL*Net roundtrips to/from client
	  0  sorts (memory)
	  0  sorts (disk)
	  0  rows processed

Eliminando índices

Index dropped.


Index dropped.

-----------------------------------------------------------------------------

###Comentarios  y conclusiones

Al completar el ejercicio para crear el script s-02-nested.sql, 
pude profundizar en el uso de la técnica Nested Loop Join para realizar operaciones tipo JOIN en Oracle. 
A través del spool, examiné detalladamente el plan de ejecución y evalué la eficiencia de la consulta.
Aunque enfrenté algunos problemas al principio, como la optimización de índices, pude resolverlos ajustando 
adecuadamente las cláusulas WHERE y añadiendo índices adicionales. En general, este ejercicio fue una oportunidad 
invaluable para fortalecer mi comprensión de las técnicas de optimización de consultas en bases de datos relacionales.