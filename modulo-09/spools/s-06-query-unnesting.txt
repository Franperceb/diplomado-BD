##JORGE FRANCISCO PEREDA CEBALLOS
##12-04-2024
##Módulo 09. E-06- Query unnesting.
-------------------------------------------

###Script
------------------------------------------------------
--@Autor: Jorge Francisco Pereda Ceballos
--@Fecha creación: 12/04/2024
--@Descripción: Ejercicio 06 - Módulo 09. Subquery unnesting.

define syslogon='sys/system1 as sysdba'
define t_user='control_medico'
define userlogon='&t_user/&t_user'
define autotrace_opt='trace only'


Prompt conectando como &t_user
connect &userlogon

Prompt Generando índices
create index receta_medicamento_id_ix on receta(medicamento_id);
create index medicamento_subclave_ix on medicamento(subclave);


Prompt conectando como SYS
connect &syslogon

Prompt B. Recolectando estadísticas
begin
  dbms_stats.gather_schema_stats (
      ownname => 'CONTROL_MEDICO',      
      degree  => 2
  );
end;
/

Prompt conectando como &t_user
connect &userlogon

Prompt Configurando autotrace 'set autotrace '
set autotrace &autotrace_opt

set linesize window

Prompt ====  Consulta 1 

select *
from receta
where medicamento_id in (
  select medicamento_id
  from medicamento
  where subclave like '010%'
);

Prompt ====  Consulta 2 Intentando evitar la Transformación 

select /*+ no_query_transformation */ *
from receta
where medicamento_id in (
  select medicamento_id
  from medicamento
  where subclave like '010%'
);


Prompt ====  Consulta 3  aplicando subquery unnesting

select *
from receta r, medicamento m
where r.medicamento_id = m.medicamento_id
and subclave like '010%';


Prompt Eliminando indices 
drop index receta_medicamento_id_ix;
drop index medicamento_subclave_ix;
---------------------------------------------------------
##Salida de ejecución
-----------------------------------------------------------------------------

control_medico@jpcdip01> start s-06-query-unnesting.sql
conectando como control_medico
Connected.
Generando índices

Index created.


Index created.

conectando como SYS
Connected.
B. Recolectando estadísticas

PL/SQL procedure successfully completed.

conectando como control_medico
Connected.
Configurando autotrace 'set autotrace '
SP2-0158: unknown SET option "only"
====  Consulta 1

17587 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 2493272481

---------------------------------------------------------------------------------------------------
| Id  | Operation		| Name			  | Rows  | Bytes | Cost (%CPU)| Time	  |
---------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT	|			  | 17636 |   688K|    36   (0)| 00:00:01 |
|*  1 |  HASH JOIN		|			  | 17636 |   688K|    36   (0)| 00:00:01 |
|*  2 |   VIEW			| index$_join$_002	  |  1768 | 37128 |    14   (0)| 00:00:01 |
|*  3 |    HASH JOIN		|			  |	  |	  |	       |	  |
|*  4 |     INDEX RANGE SCAN	| MEDICAMENTO_SUBCLAVE_IX |  1768 | 37128 |	9   (0)| 00:00:01 |
|   5 |     INDEX FAST FULL SCAN| MEDICAMENTO_PK	  |  1768 | 37128 |	6   (0)| 00:00:01 |
|   6 |   TABLE ACCESS FULL	| RECETA		  | 20000 |   371K|    22   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("MEDICAMENTO_ID"="MEDICAMENTO_ID")
   2 - filter("SUBCLAVE" LIKE '010%')
   3 - access(ROWID=ROWID)
   4 - access("SUBCLAVE" LIKE '010%')

Note
-----
   - this is an adaptive plan


Statistics
----------------------------------------------------------
	 11  recursive calls
	  7  db block gets
       1275  consistent gets
	  7  physical reads
       1056  redo size
     595742  bytes sent via SQL*Net to client
      13374  bytes received via SQL*Net from client
       1174  SQL*Net roundtrips to/from client
	  0  sorts (memory)
	  0  sorts (disk)
      17587  rows processed

====  Consulta 2 Intentando evitar la Transformación

17587 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 1448120330

-----------------------------------------------------------------------------------------------
| Id  | Operation		     | Name	      | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT	     |		      |    10 |   190 |  4033	(1)| 00:00:01 |
|*  1 |  FILTER 		     |		      |       |       | 	   |	      |
|   2 |   TABLE ACCESS FULL	     | RECETA	      | 20000 |   371K|    22	(0)| 00:00:01 |
|*  3 |   TABLE ACCESS BY INDEX ROWID| MEDICAMENTO    |     1 |    21 |     2	(0)| 00:00:01 |
|*  4 |    INDEX UNIQUE SCAN	     | MEDICAMENTO_PK |     1 |       |     1	(0)| 00:00:01 |
-----------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter( EXISTS (SELECT 0 FROM "MEDICAMENTO" "MEDICAMENTO" WHERE
	      "MEDICAMENTO_ID"=:B1 AND "SUBCLAVE" LIKE '010%'))
   3 - filter("SUBCLAVE" LIKE '010%')
   4 - access("MEDICAMENTO_ID"=:B1)


Statistics
----------------------------------------------------------
	  1  recursive calls
	  0  db block gets
      36331  consistent gets
	  0  physical reads
	  0  redo size
     595742  bytes sent via SQL*Net to client
      13405  bytes received via SQL*Net from client
       1174  SQL*Net roundtrips to/from client
	  0  sorts (memory)
	  0  sorts (disk)
      17587  rows processed

====  Consulta 3  aplicando subquery unnesting

17587 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 2213505111

----------------------------------------------------------------------------------
| Id  | Operation	   | Name	 | Rows  | Bytes | Cost (%CPU)| Time	 |
----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |		 | 17636 |  9713K|    90   (0)| 00:00:01 |
|*  1 |  HASH JOIN	   |		 | 17636 |  9713K|    90   (0)| 00:00:01 |
|   2 |   TABLE ACCESS FULL| RECETA	 | 20000 |   371K|    22   (0)| 00:00:01 |
|*  3 |   TABLE ACCESS FULL| MEDICAMENTO |  1768 |   940K|    68   (0)| 00:00:01 |
----------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("R"."MEDICAMENTO_ID"="M"."MEDICAMENTO_ID")
   3 - filter("SUBCLAVE" LIKE '010%')


Statistics
----------------------------------------------------------
	 27  recursive calls
	  0  db block gets
	487  consistent gets
	  0  physical reads
	  0  redo size
    1579985  bytes sent via SQL*Net to client
      13358  bytes received via SQL*Net from client
       1174  SQL*Net roundtrips to/from client
	  4  sorts (memory)
	  0  sorts (disk)
      17587  rows processed

Eliminando indices

Index dropped.


Index dropped.

--------------------------------------------------------------------------------
###Comentarios  y conclusiones 

Este ejercicio nos permitió explorar la técnica de Subquery Unnesting en Oracle y evaluar su efectividad para mejorar 
el rendimiento de consultas.
Al proponer una sentencia SQL con una subconsulta en la cláusula WHERE utilizando el esquema control_medico, 
pudimos comprobar si la técnica de Subquery Unnesting proporciona mejoras en el desempeño de la consulta.
La transformación de Subquery Unnesting implica fusionar una subconsulta en la cláusula WHERE mediante una operación de join,
lo que permite agrupar todas las tablas en un solo bloque. Esta transformación se aplica cuando la subconsulta 
no contiene elementos complejos, como funciones de agregación.
Al analizar el plan de ejecución generado para la consulta original y la consulta equivalente 
con Subquery Unnesting aplicada, pudimos determinar si hubo una mejora en el rendimiento. 
Si la técnica fue exitosa, esperaríamos ver una reducción en el tiempo de ejecución y una optimización en el acceso a los datos.
En conclusión, este ejercicio nos brindó la oportunidad de entender y aplicar la técnica de Subquery Unnesting en Oracle, 
permitiéndonos evaluar su impacto en el rendimiento de las consultas y mejorar nuestra comprensión de las optimizaciones 
disponibles en el motor de base de datos.